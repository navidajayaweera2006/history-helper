{
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-GyMRK",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "question",
            "id": "Prompt-EydHv",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-TextInput-GyMRK{œdataTypeœ:œTextInputœ,œidœ:œTextInput-GyMRKœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-Prompt-EydHv{œfieldNameœ:œquestionœ,œidœ:œPrompt-EydHvœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "TextInput-GyMRK",
        "sourceHandle": "{œdataTypeœ:œTextInputœ,œidœ:œTextInput-GyMRKœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt-EydHv",
        "targetHandle": "{œfieldNameœ:œquestionœ,œidœ:œPrompt-EydHvœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt",
            "id": "Prompt-EydHv",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "GoogleGenerativeAIModel-aADfw",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-Prompt-EydHv{œdataTypeœ:œPromptœ,œidœ:œPrompt-EydHvœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-GoogleGenerativeAIModel-aADfw{œfieldNameœ:œinput_valueœ,œidœ:œGoogleGenerativeAIModel-aADfwœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt-EydHv",
        "sourceHandle": "{œdataTypeœ:œPromptœ,œidœ:œPrompt-EydHvœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "GoogleGenerativeAIModel-aADfw",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œGoogleGenerativeAIModel-aADfwœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GoogleGenerativeAIModel",
            "id": "GoogleGenerativeAIModel-aADfw",
            "name": "text_output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "json_string",
            "id": "JSONtoData-jzHeC",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-GoogleGenerativeAIModel-aADfw{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-aADfwœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-JSONtoData-jzHeC{œfieldNameœ:œjson_stringœ,œidœ:œJSONtoData-jzHeCœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "GoogleGenerativeAIModel-aADfw",
        "sourceHandle": "{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-aADfwœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "JSONtoData-jzHeC",
        "targetHandle": "{œfieldNameœ:œjson_stringœ,œidœ:œJSONtoData-jzHeCœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JSONtoData",
            "id": "JSONtoData-jzHeC",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data_list",
            "id": "DataToDataFrame-4Qo4s",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-JSONtoData-jzHeC{œdataTypeœ:œJSONtoDataœ,œidœ:œJSONtoData-jzHeCœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-DataToDataFrame-4Qo4s{œfieldNameœ:œdata_listœ,œidœ:œDataToDataFrame-4Qo4sœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "JSONtoData-jzHeC",
        "sourceHandle": "{œdataTypeœ:œJSONtoDataœ,œidœ:œJSONtoData-jzHeCœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}",
        "target": "DataToDataFrame-4Qo4s",
        "targetHandle": "{œfieldNameœ:œdata_listœ,œidœ:œDataToDataFrame-4Qo4sœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataToDataFrame",
            "id": "DataToDataFrame-4Qo4s",
            "name": "dataframe",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df",
            "id": "BatchRunComponent-clb8n",
            "inputTypes": [
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataToDataFrame-4Qo4s{œdataTypeœ:œDataToDataFrameœ,œidœ:œDataToDataFrame-4Qo4sœ,œnameœ:œdataframeœ,œoutput_typesœ:[œDataFrameœ]}-BatchRunComponent-clb8n{œfieldNameœ:œdfœ,œidœ:œBatchRunComponent-clb8nœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataToDataFrame-4Qo4s",
        "sourceHandle": "{œdataTypeœ:œDataToDataFrameœ,œidœ:œDataToDataFrame-4Qo4sœ,œnameœ:œdataframeœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "BatchRunComponent-clb8n",
        "targetHandle": "{œfieldNameœ:œdfœ,œidœ:œBatchRunComponent-clb8nœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt",
            "id": "Prompt-BXFAW",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "system_message",
            "id": "BatchRunComponent-clb8n",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-Prompt-BXFAW{œdataTypeœ:œPromptœ,œidœ:œPrompt-BXFAWœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-BatchRunComponent-clb8n{œfieldNameœ:œsystem_messageœ,œidœ:œBatchRunComponent-clb8nœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt-BXFAW",
        "sourceHandle": "{œdataTypeœ:œPromptœ,œidœ:œPrompt-BXFAWœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "BatchRunComponent-clb8n",
        "targetHandle": "{œfieldNameœ:œsystem_messageœ,œidœ:œBatchRunComponent-clb8nœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GoogleGenerativeAIModel",
            "id": "GoogleGenerativeAIModel-bIzoE",
            "name": "model_output",
            "output_types": [
              "LanguageModel"
            ]
          },
          "targetHandle": {
            "fieldName": "model",
            "id": "BatchRunComponent-clb8n",
            "inputTypes": [
              "LanguageModel"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-GoogleGenerativeAIModel-bIzoE{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-bIzoEœ,œnameœ:œmodel_outputœ,œoutput_typesœ:[œLanguageModelœ]}-BatchRunComponent-clb8n{œfieldNameœ:œmodelœ,œidœ:œBatchRunComponent-clb8nœ,œinputTypesœ:[œLanguageModelœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "GoogleGenerativeAIModel-bIzoE",
        "sourceHandle": "{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-bIzoEœ,œnameœ:œmodel_outputœ,œoutput_typesœ:[œLanguageModelœ]}",
        "target": "BatchRunComponent-clb8n",
        "targetHandle": "{œfieldNameœ:œmodelœ,œidœ:œBatchRunComponent-clb8nœ,œinputTypesœ:[œLanguageModelœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-GyMRK",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "question",
            "id": "Prompt-BXFAW",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-TextInput-GyMRK{œdataTypeœ:œTextInputœ,œidœ:œTextInput-GyMRKœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-Prompt-BXFAW{œfieldNameœ:œquestionœ,œidœ:œPrompt-BXFAWœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "TextInput-GyMRK",
        "sourceHandle": "{œdataTypeœ:œTextInputœ,œidœ:œTextInput-GyMRKœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt-BXFAW",
        "targetHandle": "{œfieldNameœ:œquestionœ,œidœ:œPrompt-BXFAWœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataFrameOperationsComponent",
            "id": "DataFrameOperationsComponent-smlgy",
            "name": "output",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df",
            "id": "DataFrameOperationsComponent-k61oZ",
            "inputTypes": [
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataFrameOperationsComponent-smlgy{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-smlgyœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-DataFrameOperationsComponent-k61oZ{œfieldNameœ:œdfœ,œidœ:œDataFrameOperationsComponent-k61oZœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataFrameOperationsComponent-smlgy",
        "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-smlgyœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "DataFrameOperationsComponent-k61oZ",
        "targetHandle": "{œfieldNameœ:œdfœ,œidœ:œDataFrameOperationsComponent-k61oZœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataFrameOperationsComponent",
            "id": "DataFrameOperationsComponent-k61oZ",
            "name": "output",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df_DataFrameOperationsComponent-kXK4V",
            "id": "GroupNode-d6vys",
            "inputTypes": [
              "DataFrame"
            ],
            "proxy": {
              "field": "df",
              "id": "DataFrameOperationsComponent-tKi19"
            },
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataFrameOperationsComponent-k61oZ{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-k61oZœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-GroupNode-d6vys{œfieldNameœ:œdf_DataFrameOperationsComponent-kXK4Vœ,œidœ:œGroupNode-d6vysœ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-tKi19œ},œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataFrameOperationsComponent-k61oZ",
        "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-k61oZœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "GroupNode-d6vys",
        "targetHandle": "{œfieldNameœ:œdf_DataFrameOperationsComponent-kXK4Vœ,œidœ:œGroupNode-d6vysœ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-tKi19œ},œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataFrameOperationsComponent",
            "id": "DataFrameOperationsComponent-k61oZ",
            "name": "output",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df_DataFrameOperationsComponent-rvJsS",
            "id": "GroupNode-k8FUm",
            "inputTypes": [
              "DataFrame"
            ],
            "proxy": {
              "field": "df",
              "id": "DataFrameOperationsComponent-5DYFO"
            },
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataFrameOperationsComponent-k61oZ{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-k61oZœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-GroupNode-k8FUm{œfieldNameœ:œdf_DataFrameOperationsComponent-rvJsSœ,œidœ:œGroupNode-k8FUmœ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-5DYFOœ},œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataFrameOperationsComponent-k61oZ",
        "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-k61oZœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "GroupNode-k8FUm",
        "targetHandle": "{œfieldNameœ:œdf_DataFrameOperationsComponent-rvJsSœ,œidœ:œGroupNode-k8FUmœ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-5DYFOœ},œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataFrameOperationsComponent",
            "id": "DataFrameOperationsComponent-smlgy",
            "name": "output",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df_DataFrameOperationsComponent-rvJsS",
            "id": "GroupNode-6LXK0",
            "inputTypes": [
              "DataFrame"
            ],
            "proxy": {
              "field": "df",
              "id": "DataFrameOperationsComponent-fnitl"
            },
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataFrameOperationsComponent-smlgy{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-smlgyœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-GroupNode-6LXK0{œfieldNameœ:œdf_DataFrameOperationsComponent-rvJsSœ,œidœ:œGroupNode-6LXK0œ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-fnitlœ},œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataFrameOperationsComponent-smlgy",
        "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-smlgyœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "GroupNode-6LXK0",
        "targetHandle": "{œfieldNameœ:œdf_DataFrameOperationsComponent-rvJsSœ,œidœ:œGroupNode-6LXK0œ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-fnitlœ},œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "BatchRunComponent",
            "id": "BatchRunComponent-clb8n",
            "name": "batch_results",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df_DataFrameOperationsComponent-rvJsS",
            "id": "GroupNode-mCw5i",
            "inputTypes": [
              "DataFrame"
            ],
            "proxy": {
              "field": "df",
              "id": "DataFrameOperationsComponent-2Jqrw"
            },
            "type": "other"
          }
        },
        "id": "reactflow__edge-BatchRunComponent-clb8n{œdataTypeœ:œBatchRunComponentœ,œidœ:œBatchRunComponent-clb8nœ,œnameœ:œbatch_resultsœ,œoutput_typesœ:[œDataFrameœ]}-GroupNode-mCw5i{œfieldNameœ:œdf_DataFrameOperationsComponent-rvJsSœ,œidœ:œGroupNode-mCw5iœ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-2Jqrwœ},œtypeœ:œotherœ}",
        "selected": false,
        "source": "BatchRunComponent-clb8n",
        "sourceHandle": "{œdataTypeœ:œBatchRunComponentœ,œidœ:œBatchRunComponent-clb8nœ,œnameœ:œbatch_resultsœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "GroupNode-mCw5i",
        "targetHandle": "{œfieldNameœ:œdf_DataFrameOperationsComponent-rvJsSœ,œidœ:œGroupNode-mCw5iœ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-2Jqrwœ},œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "BatchRunComponent",
            "id": "BatchRunComponent-clb8n",
            "name": "batch_results",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df",
            "id": "DataFrameOperationsComponent-smlgy",
            "inputTypes": [
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-BatchRunComponent-clb8n{œdataTypeœ:œBatchRunComponentœ,œidœ:œBatchRunComponent-clb8nœ,œnameœ:œbatch_resultsœ,œoutput_typesœ:[œDataFrameœ]}-DataFrameOperationsComponent-smlgy{œfieldNameœ:œdfœ,œidœ:œDataFrameOperationsComponent-smlgyœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "BatchRunComponent-clb8n",
        "sourceHandle": "{œdataTypeœ:œBatchRunComponentœ,œidœ:œBatchRunComponent-clb8nœ,œnameœ:œbatch_resultsœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "DataFrameOperationsComponent-smlgy",
        "targetHandle": "{œfieldNameœ:œdfœ,œidœ:œDataFrameOperationsComponent-smlgyœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GroupNode",
            "id": "GroupNode-mCw5i",
            "name": "ParserComponent-rFJn1_parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "json_string",
            "id": "JSONtoData-DrZKW",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-GroupNode-mCw5i{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-mCw5iœ,œnameœ:œParserComponent-rFJn1_parsed_textœ,œoutput_typesœ:[œMessageœ]}-JSONtoData-DrZKW{œfieldNameœ:œjson_stringœ,œidœ:œJSONtoData-DrZKWœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "GroupNode-mCw5i",
        "sourceHandle": "{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-mCw5iœ,œnameœ:œParserComponent-rFJn1_parsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "JSONtoData-DrZKW",
        "targetHandle": "{œfieldNameœ:œjson_stringœ,œidœ:œJSONtoData-DrZKWœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JSONtoData",
            "id": "JSONtoData-DrZKW",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "MultiTemplateParserComponent-72YMA",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-JSONtoData-DrZKW{œdataTypeœ:œJSONtoDataœ,œidœ:œJSONtoData-DrZKWœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-MultiTemplateParserComponent-72YMA{œfieldNameœ:œinput_dataœ,œidœ:œMultiTemplateParserComponent-72YMAœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "JSONtoData-DrZKW",
        "sourceHandle": "{œdataTypeœ:œJSONtoDataœ,œidœ:œJSONtoData-DrZKWœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}",
        "target": "MultiTemplateParserComponent-72YMA",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œMultiTemplateParserComponent-72YMAœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GroupNode",
            "id": "GroupNode-d6vys",
            "name": "ParserComponent-lEXku_parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "json_string",
            "id": "JSONtoData-qjsYa",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-GroupNode-d6vys{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-d6vysœ,œnameœ:œParserComponent-lEXku_parsed_textœ,œoutput_typesœ:[œMessageœ]}-JSONtoData-qjsYa{œfieldNameœ:œjson_stringœ,œidœ:œJSONtoData-qjsYaœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "GroupNode-d6vys",
        "sourceHandle": "{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-d6vysœ,œnameœ:œParserComponent-lEXku_parsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "JSONtoData-qjsYa",
        "targetHandle": "{œfieldNameœ:œjson_stringœ,œidœ:œJSONtoData-qjsYaœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JSONtoData",
            "id": "JSONtoData-qjsYa",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "MultiTemplateParserComponent-TFe9s",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-JSONtoData-qjsYa{œdataTypeœ:œJSONtoDataœ,œidœ:œJSONtoData-qjsYaœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-MultiTemplateParserComponent-TFe9s{œfieldNameœ:œinput_dataœ,œidœ:œMultiTemplateParserComponent-TFe9sœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "JSONtoData-qjsYa",
        "sourceHandle": "{œdataTypeœ:œJSONtoDataœ,œidœ:œJSONtoData-qjsYaœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}",
        "target": "MultiTemplateParserComponent-TFe9s",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œMultiTemplateParserComponent-TFe9sœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MultiTemplateParserComponent",
            "id": "MultiTemplateParserComponent-TFe9s",
            "name": "result_1",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "search_query_2",
            "id": "AstraDB-XcO2c",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-MultiTemplateParserComponent-TFe9s{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-TFe9sœ,œnameœ:œresult_1œ,œoutput_typesœ:[œMessageœ]}-AstraDB-XcO2c{œfieldNameœ:œsearch_query_2œ,œidœ:œAstraDB-XcO2cœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "MultiTemplateParserComponent-TFe9s",
        "sourceHandle": "{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-TFe9sœ,œnameœ:œresult_1œ,œoutput_typesœ:[œMessageœ]}",
        "target": "AstraDB-XcO2c",
        "targetHandle": "{œfieldNameœ:œsearch_query_2œ,œidœ:œAstraDB-XcO2cœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MultiTemplateParserComponent",
            "id": "MultiTemplateParserComponent-TFe9s",
            "name": "result_2",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "search_query_3",
            "id": "AstraDB-XcO2c",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-MultiTemplateParserComponent-TFe9s{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-TFe9sœ,œnameœ:œresult_2œ,œoutput_typesœ:[œMessageœ]}-AstraDB-XcO2c{œfieldNameœ:œsearch_query_3œ,œidœ:œAstraDB-XcO2cœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "MultiTemplateParserComponent-TFe9s",
        "sourceHandle": "{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-TFe9sœ,œnameœ:œresult_2œ,œoutput_typesœ:[œMessageœ]}",
        "target": "AstraDB-XcO2c",
        "targetHandle": "{œfieldNameœ:œsearch_query_3œ,œidœ:œAstraDB-XcO2cœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MultiTemplateParserComponent",
            "id": "MultiTemplateParserComponent-TFe9s",
            "name": "result_3",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "search_query",
            "id": "AstraDB-XcO2c",
            "inputTypes": [
              "Message"
            ],
            "type": "query"
          }
        },
        "id": "reactflow__edge-MultiTemplateParserComponent-TFe9s{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-TFe9sœ,œnameœ:œresult_3œ,œoutput_typesœ:[œMessageœ]}-AstraDB-XcO2c{œfieldNameœ:œsearch_queryœ,œidœ:œAstraDB-XcO2cœ,œinputTypesœ:[œMessageœ],œtypeœ:œqueryœ}",
        "selected": false,
        "source": "MultiTemplateParserComponent-TFe9s",
        "sourceHandle": "{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-TFe9sœ,œnameœ:œresult_3œ,œoutput_typesœ:[œMessageœ]}",
        "target": "AstraDB-XcO2c",
        "targetHandle": "{œfieldNameœ:œsearch_queryœ,œidœ:œAstraDB-XcO2cœ,œinputTypesœ:[œMessageœ],œtypeœ:œqueryœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GroupNode",
            "id": "GroupNode-k8FUm",
            "name": "ParserComponent-rFJn1_parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "json_string",
            "id": "JSONtoData-SWqoH",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-GroupNode-k8FUm{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-k8FUmœ,œnameœ:œParserComponent-rFJn1_parsed_textœ,œoutput_typesœ:[œMessageœ]}-JSONtoData-SWqoH{œfieldNameœ:œjson_stringœ,œidœ:œJSONtoData-SWqoHœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "GroupNode-k8FUm",
        "sourceHandle": "{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-k8FUmœ,œnameœ:œParserComponent-rFJn1_parsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "JSONtoData-SWqoH",
        "targetHandle": "{œfieldNameœ:œjson_stringœ,œidœ:œJSONtoData-SWqoHœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JSONtoData",
            "id": "JSONtoData-SWqoH",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "MultiTemplateParserComponent-FbtVx",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-JSONtoData-SWqoH{œdataTypeœ:œJSONtoDataœ,œidœ:œJSONtoData-SWqoHœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-MultiTemplateParserComponent-FbtVx{œfieldNameœ:œinput_dataœ,œidœ:œMultiTemplateParserComponent-FbtVxœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "JSONtoData-SWqoH",
        "sourceHandle": "{œdataTypeœ:œJSONtoDataœ,œidœ:œJSONtoData-SWqoHœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}",
        "target": "MultiTemplateParserComponent-FbtVx",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œMultiTemplateParserComponent-FbtVxœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MultiTemplateParserComponent",
            "id": "MultiTemplateParserComponent-FbtVx",
            "name": "result_1",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "search_query_2",
            "id": "AstraDB-jm2uO",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-MultiTemplateParserComponent-FbtVx{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-FbtVxœ,œnameœ:œresult_1œ,œoutput_typesœ:[œMessageœ]}-AstraDB-jm2uO{œfieldNameœ:œsearch_query_2œ,œidœ:œAstraDB-jm2uOœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "MultiTemplateParserComponent-FbtVx",
        "sourceHandle": "{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-FbtVxœ,œnameœ:œresult_1œ,œoutput_typesœ:[œMessageœ]}",
        "target": "AstraDB-jm2uO",
        "targetHandle": "{œfieldNameœ:œsearch_query_2œ,œidœ:œAstraDB-jm2uOœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MultiTemplateParserComponent",
            "id": "MultiTemplateParserComponent-FbtVx",
            "name": "result_2",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "search_query_3",
            "id": "AstraDB-jm2uO",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-MultiTemplateParserComponent-FbtVx{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-FbtVxœ,œnameœ:œresult_2œ,œoutput_typesœ:[œMessageœ]}-AstraDB-jm2uO{œfieldNameœ:œsearch_query_3œ,œidœ:œAstraDB-jm2uOœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "MultiTemplateParserComponent-FbtVx",
        "sourceHandle": "{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-FbtVxœ,œnameœ:œresult_2œ,œoutput_typesœ:[œMessageœ]}",
        "target": "AstraDB-jm2uO",
        "targetHandle": "{œfieldNameœ:œsearch_query_3œ,œidœ:œAstraDB-jm2uOœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MultiTemplateParserComponent",
            "id": "MultiTemplateParserComponent-FbtVx",
            "name": "result_3",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "search_query",
            "id": "AstraDB-jm2uO",
            "inputTypes": [
              "Message"
            ],
            "type": "query"
          }
        },
        "id": "reactflow__edge-MultiTemplateParserComponent-FbtVx{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-FbtVxœ,œnameœ:œresult_3œ,œoutput_typesœ:[œMessageœ]}-AstraDB-jm2uO{œfieldNameœ:œsearch_queryœ,œidœ:œAstraDB-jm2uOœ,œinputTypesœ:[œMessageœ],œtypeœ:œqueryœ}",
        "selected": false,
        "source": "MultiTemplateParserComponent-FbtVx",
        "sourceHandle": "{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-FbtVxœ,œnameœ:œresult_3œ,œoutput_typesœ:[œMessageœ]}",
        "target": "AstraDB-jm2uO",
        "targetHandle": "{œfieldNameœ:œsearch_queryœ,œidœ:œAstraDB-jm2uOœ,œinputTypesœ:[œMessageœ],œtypeœ:œqueryœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GroupNode",
            "id": "GroupNode-6LXK0",
            "name": "ParserComponent-rFJn1_parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "json_string",
            "id": "JSONtoData-GtnYW",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-GroupNode-6LXK0{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-6LXK0œ,œnameœ:œParserComponent-rFJn1_parsed_textœ,œoutput_typesœ:[œMessageœ]}-JSONtoData-GtnYW{œfieldNameœ:œjson_stringœ,œidœ:œJSONtoData-GtnYWœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "GroupNode-6LXK0",
        "sourceHandle": "{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-6LXK0œ,œnameœ:œParserComponent-rFJn1_parsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "JSONtoData-GtnYW",
        "targetHandle": "{œfieldNameœ:œjson_stringœ,œidœ:œJSONtoData-GtnYWœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JSONtoData",
            "id": "JSONtoData-GtnYW",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "MultiTemplateParserComponent-qqkk5",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-JSONtoData-GtnYW{œdataTypeœ:œJSONtoDataœ,œidœ:œJSONtoData-GtnYWœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-MultiTemplateParserComponent-qqkk5{œfieldNameœ:œinput_dataœ,œidœ:œMultiTemplateParserComponent-qqkk5œ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "JSONtoData-GtnYW",
        "sourceHandle": "{œdataTypeœ:œJSONtoDataœ,œidœ:œJSONtoData-GtnYWœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}",
        "target": "MultiTemplateParserComponent-qqkk5",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œMultiTemplateParserComponent-qqkk5œ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MultiTemplateParserComponent",
            "id": "MultiTemplateParserComponent-qqkk5",
            "name": "result_1",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "search_query_2",
            "id": "AstraDB-jLVbY",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-MultiTemplateParserComponent-qqkk5{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-qqkk5œ,œnameœ:œresult_1œ,œoutput_typesœ:[œMessageœ]}-AstraDB-jLVbY{œfieldNameœ:œsearch_query_2œ,œidœ:œAstraDB-jLVbYœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "MultiTemplateParserComponent-qqkk5",
        "sourceHandle": "{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-qqkk5œ,œnameœ:œresult_1œ,œoutput_typesœ:[œMessageœ]}",
        "target": "AstraDB-jLVbY",
        "targetHandle": "{œfieldNameœ:œsearch_query_2œ,œidœ:œAstraDB-jLVbYœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MultiTemplateParserComponent",
            "id": "MultiTemplateParserComponent-qqkk5",
            "name": "result_2",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "search_query_3",
            "id": "AstraDB-jLVbY",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-MultiTemplateParserComponent-qqkk5{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-qqkk5œ,œnameœ:œresult_2œ,œoutput_typesœ:[œMessageœ]}-AstraDB-jLVbY{œfieldNameœ:œsearch_query_3œ,œidœ:œAstraDB-jLVbYœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "MultiTemplateParserComponent-qqkk5",
        "sourceHandle": "{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-qqkk5œ,œnameœ:œresult_2œ,œoutput_typesœ:[œMessageœ]}",
        "target": "AstraDB-jLVbY",
        "targetHandle": "{œfieldNameœ:œsearch_query_3œ,œidœ:œAstraDB-jLVbYœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MultiTemplateParserComponent",
            "id": "MultiTemplateParserComponent-qqkk5",
            "name": "result_3",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "search_query",
            "id": "AstraDB-jLVbY",
            "inputTypes": [
              "Message"
            ],
            "type": "query"
          }
        },
        "id": "reactflow__edge-MultiTemplateParserComponent-qqkk5{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-qqkk5œ,œnameœ:œresult_3œ,œoutput_typesœ:[œMessageœ]}-AstraDB-jLVbY{œfieldNameœ:œsearch_queryœ,œidœ:œAstraDB-jLVbYœ,œinputTypesœ:[œMessageœ],œtypeœ:œqueryœ}",
        "selected": false,
        "source": "MultiTemplateParserComponent-qqkk5",
        "sourceHandle": "{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-qqkk5œ,œnameœ:œresult_3œ,œoutput_typesœ:[œMessageœ]}",
        "target": "AstraDB-jLVbY",
        "targetHandle": "{œfieldNameœ:œsearch_queryœ,œidœ:œAstraDB-jLVbYœ,œinputTypesœ:[œMessageœ],œtypeœ:œqueryœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MultiTemplateParserComponent",
            "id": "MultiTemplateParserComponent-72YMA",
            "name": "result_1",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "search_query_2",
            "id": "AstraDB-R9DHR",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-MultiTemplateParserComponent-72YMA{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-72YMAœ,œnameœ:œresult_1œ,œoutput_typesœ:[œMessageœ]}-AstraDB-R9DHR{œfieldNameœ:œsearch_query_2œ,œidœ:œAstraDB-R9DHRœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "MultiTemplateParserComponent-72YMA",
        "sourceHandle": "{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-72YMAœ,œnameœ:œresult_1œ,œoutput_typesœ:[œMessageœ]}",
        "target": "AstraDB-R9DHR",
        "targetHandle": "{œfieldNameœ:œsearch_query_2œ,œidœ:œAstraDB-R9DHRœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MultiTemplateParserComponent",
            "id": "MultiTemplateParserComponent-72YMA",
            "name": "result_2",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "search_query_3",
            "id": "AstraDB-R9DHR",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-MultiTemplateParserComponent-72YMA{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-72YMAœ,œnameœ:œresult_2œ,œoutput_typesœ:[œMessageœ]}-AstraDB-R9DHR{œfieldNameœ:œsearch_query_3œ,œidœ:œAstraDB-R9DHRœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "MultiTemplateParserComponent-72YMA",
        "sourceHandle": "{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-72YMAœ,œnameœ:œresult_2œ,œoutput_typesœ:[œMessageœ]}",
        "target": "AstraDB-R9DHR",
        "targetHandle": "{œfieldNameœ:œsearch_query_3œ,œidœ:œAstraDB-R9DHRœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MultiTemplateParserComponent",
            "id": "MultiTemplateParserComponent-72YMA",
            "name": "result_3",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "search_query",
            "id": "AstraDB-R9DHR",
            "inputTypes": [
              "Message"
            ],
            "type": "query"
          }
        },
        "id": "reactflow__edge-MultiTemplateParserComponent-72YMA{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-72YMAœ,œnameœ:œresult_3œ,œoutput_typesœ:[œMessageœ]}-AstraDB-R9DHR{œfieldNameœ:œsearch_queryœ,œidœ:œAstraDB-R9DHRœ,œinputTypesœ:[œMessageœ],œtypeœ:œqueryœ}",
        "selected": false,
        "source": "MultiTemplateParserComponent-72YMA",
        "sourceHandle": "{œdataTypeœ:œMultiTemplateParserComponentœ,œidœ:œMultiTemplateParserComponent-72YMAœ,œnameœ:œresult_3œ,œoutput_typesœ:[œMessageœ]}",
        "target": "AstraDB-R9DHR",
        "targetHandle": "{œfieldNameœ:œsearch_queryœ,œidœ:œAstraDB-R9DHRœ,œinputTypesœ:[œMessageœ],œtypeœ:œqueryœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Google Generative AI Embeddings",
            "id": "Google Generative AI Embeddings-lV2eD",
            "name": "embeddings",
            "output_types": [
              "Embeddings"
            ]
          },
          "targetHandle": {
            "fieldName": "embedding_model",
            "id": "AstraDB-R9DHR",
            "inputTypes": [
              "Embeddings"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-Google Generative AI Embeddings-lV2eD{œdataTypeœ:œGoogle Generative AI Embeddingsœ,œidœ:œGoogle Generative AI Embeddings-lV2eDœ,œnameœ:œembeddingsœ,œoutput_typesœ:[œEmbeddingsœ]}-AstraDB-R9DHR{œfieldNameœ:œembedding_modelœ,œidœ:œAstraDB-R9DHRœ,œinputTypesœ:[œEmbeddingsœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "Google Generative AI Embeddings-lV2eD",
        "sourceHandle": "{œdataTypeœ:œGoogle Generative AI Embeddingsœ,œidœ:œGoogle Generative AI Embeddings-lV2eDœ,œnameœ:œembeddingsœ,œoutput_typesœ:[œEmbeddingsœ]}",
        "target": "AstraDB-R9DHR",
        "targetHandle": "{œfieldNameœ:œembedding_modelœ,œidœ:œAstraDB-R9DHRœ,œinputTypesœ:[œEmbeddingsœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Google Generative AI Embeddings",
            "id": "Google Generative AI Embeddings-lV2eD",
            "name": "embeddings",
            "output_types": [
              "Embeddings"
            ]
          },
          "targetHandle": {
            "fieldName": "embedding_model",
            "id": "AstraDB-jLVbY",
            "inputTypes": [
              "Embeddings"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-Google Generative AI Embeddings-lV2eD{œdataTypeœ:œGoogle Generative AI Embeddingsœ,œidœ:œGoogle Generative AI Embeddings-lV2eDœ,œnameœ:œembeddingsœ,œoutput_typesœ:[œEmbeddingsœ]}-AstraDB-jLVbY{œfieldNameœ:œembedding_modelœ,œidœ:œAstraDB-jLVbYœ,œinputTypesœ:[œEmbeddingsœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "Google Generative AI Embeddings-lV2eD",
        "sourceHandle": "{œdataTypeœ:œGoogle Generative AI Embeddingsœ,œidœ:œGoogle Generative AI Embeddings-lV2eDœ,œnameœ:œembeddingsœ,œoutput_typesœ:[œEmbeddingsœ]}",
        "target": "AstraDB-jLVbY",
        "targetHandle": "{œfieldNameœ:œembedding_modelœ,œidœ:œAstraDB-jLVbYœ,œinputTypesœ:[œEmbeddingsœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Google Generative AI Embeddings",
            "id": "Google Generative AI Embeddings-lV2eD",
            "name": "embeddings",
            "output_types": [
              "Embeddings"
            ]
          },
          "targetHandle": {
            "fieldName": "embedding_model",
            "id": "AstraDB-jm2uO",
            "inputTypes": [
              "Embeddings"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-Google Generative AI Embeddings-lV2eD{œdataTypeœ:œGoogle Generative AI Embeddingsœ,œidœ:œGoogle Generative AI Embeddings-lV2eDœ,œnameœ:œembeddingsœ,œoutput_typesœ:[œEmbeddingsœ]}-AstraDB-jm2uO{œfieldNameœ:œembedding_modelœ,œidœ:œAstraDB-jm2uOœ,œinputTypesœ:[œEmbeddingsœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "Google Generative AI Embeddings-lV2eD",
        "sourceHandle": "{œdataTypeœ:œGoogle Generative AI Embeddingsœ,œidœ:œGoogle Generative AI Embeddings-lV2eDœ,œnameœ:œembeddingsœ,œoutput_typesœ:[œEmbeddingsœ]}",
        "target": "AstraDB-jm2uO",
        "targetHandle": "{œfieldNameœ:œembedding_modelœ,œidœ:œAstraDB-jm2uOœ,œinputTypesœ:[œEmbeddingsœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Google Generative AI Embeddings",
            "id": "Google Generative AI Embeddings-lV2eD",
            "name": "embeddings",
            "output_types": [
              "Embeddings"
            ]
          },
          "targetHandle": {
            "fieldName": "embedding_model",
            "id": "AstraDB-XcO2c",
            "inputTypes": [
              "Embeddings"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-Google Generative AI Embeddings-lV2eD{œdataTypeœ:œGoogle Generative AI Embeddingsœ,œidœ:œGoogle Generative AI Embeddings-lV2eDœ,œnameœ:œembeddingsœ,œoutput_typesœ:[œEmbeddingsœ]}-AstraDB-XcO2c{œfieldNameœ:œembedding_modelœ,œidœ:œAstraDB-XcO2cœ,œinputTypesœ:[œEmbeddingsœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "Google Generative AI Embeddings-lV2eD",
        "sourceHandle": "{œdataTypeœ:œGoogle Generative AI Embeddingsœ,œidœ:œGoogle Generative AI Embeddings-lV2eDœ,œnameœ:œembeddingsœ,œoutput_typesœ:[œEmbeddingsœ]}",
        "target": "AstraDB-XcO2c",
        "targetHandle": "{œfieldNameœ:œembedding_modelœ,œidœ:œAstraDB-XcO2cœ,œinputTypesœ:[œEmbeddingsœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "RemoveDuplicates",
            "id": "RemoveDuplicates-Im6AN",
            "name": "deduplicated_data_list",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-MMfCE",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-RemoveDuplicates-Im6AN{œdataTypeœ:œRemoveDuplicatesœ,œidœ:œRemoveDuplicates-Im6ANœ,œnameœ:œdeduplicated_data_listœ,œoutput_typesœ:[œDataœ]}-ParserComponent-MMfCE{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-MMfCEœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "RemoveDuplicates-Im6AN",
        "sourceHandle": "{œdataTypeœ:œRemoveDuplicatesœ,œidœ:œRemoveDuplicates-Im6ANœ,œnameœ:œdeduplicated_data_listœ,œoutput_typesœ:[œDataœ]}",
        "target": "ParserComponent-MMfCE",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-MMfCEœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "AstraDB",
            "id": "AstraDB-R9DHR",
            "name": "search_results",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data_list",
            "id": "RemoveDuplicates-Im6AN",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-AstraDB-R9DHR{œdataTypeœ:œAstraDBœ,œidœ:œAstraDB-R9DHRœ,œnameœ:œsearch_resultsœ,œoutput_typesœ:[œDataœ]}-RemoveDuplicates-Im6AN{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-Im6ANœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "AstraDB-R9DHR",
        "sourceHandle": "{œdataTypeœ:œAstraDBœ,œidœ:œAstraDB-R9DHRœ,œnameœ:œsearch_resultsœ,œoutput_typesœ:[œDataœ]}",
        "target": "RemoveDuplicates-Im6AN",
        "targetHandle": "{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-Im6ANœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "AstraDB",
            "id": "AstraDB-jLVbY",
            "name": "search_results",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data_list",
            "id": "RemoveDuplicates-Im6AN",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-AstraDB-jLVbY{œdataTypeœ:œAstraDBœ,œidœ:œAstraDB-jLVbYœ,œnameœ:œsearch_resultsœ,œoutput_typesœ:[œDataœ]}-RemoveDuplicates-Im6AN{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-Im6ANœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "AstraDB-jLVbY",
        "sourceHandle": "{œdataTypeœ:œAstraDBœ,œidœ:œAstraDB-jLVbYœ,œnameœ:œsearch_resultsœ,œoutput_typesœ:[œDataœ]}",
        "target": "RemoveDuplicates-Im6AN",
        "targetHandle": "{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-Im6ANœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "AstraDB",
            "id": "AstraDB-jm2uO",
            "name": "search_results",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data_list",
            "id": "RemoveDuplicates-Im6AN",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-AstraDB-jm2uO{œdataTypeœ:œAstraDBœ,œidœ:œAstraDB-jm2uOœ,œnameœ:œsearch_resultsœ,œoutput_typesœ:[œDataœ]}-RemoveDuplicates-Im6AN{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-Im6ANœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "AstraDB-jm2uO",
        "sourceHandle": "{œdataTypeœ:œAstraDBœ,œidœ:œAstraDB-jm2uOœ,œnameœ:œsearch_resultsœ,œoutput_typesœ:[œDataœ]}",
        "target": "RemoveDuplicates-Im6AN",
        "targetHandle": "{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-Im6ANœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "AstraDB",
            "id": "AstraDB-XcO2c",
            "name": "search_results",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data_list",
            "id": "RemoveDuplicates-Im6AN",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-AstraDB-XcO2c{œdataTypeœ:œAstraDBœ,œidœ:œAstraDB-XcO2cœ,œnameœ:œsearch_resultsœ,œoutput_typesœ:[œDataœ]}-RemoveDuplicates-Im6AN{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-Im6ANœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "AstraDB-XcO2c",
        "sourceHandle": "{œdataTypeœ:œAstraDBœ,œidœ:œAstraDB-XcO2cœ,œnameœ:œsearch_resultsœ,œoutput_typesœ:[œDataœ]}",
        "target": "RemoveDuplicates-Im6AN",
        "targetHandle": "{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-Im6ANœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-MMfCE",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "context",
            "id": "Prompt-Axryi",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-ParserComponent-MMfCE{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-MMfCEœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt-Axryi{œfieldNameœ:œcontextœ,œidœ:œPrompt-Axryiœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-MMfCE",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-MMfCEœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt-Axryi",
        "targetHandle": "{œfieldNameœ:œcontextœ,œidœ:œPrompt-Axryiœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-GyMRK",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "question",
            "id": "Prompt-Axryi",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-TextInput-GyMRK{œdataTypeœ:œTextInputœ,œidœ:œTextInput-GyMRKœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-Prompt-Axryi{œfieldNameœ:œquestionœ,œidœ:œPrompt-Axryiœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "TextInput-GyMRK",
        "sourceHandle": "{œdataTypeœ:œTextInputœ,œidœ:œTextInput-GyMRKœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt-Axryi",
        "targetHandle": "{œfieldNameœ:œquestionœ,œidœ:œPrompt-Axryiœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt",
            "id": "Prompt-Axryi",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "GoogleGenerativeAIModel-C84qd",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-Prompt-Axryi{œdataTypeœ:œPromptœ,œidœ:œPrompt-Axryiœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-GoogleGenerativeAIModel-C84qd{œfieldNameœ:œinput_valueœ,œidœ:œGoogleGenerativeAIModel-C84qdœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt-Axryi",
        "sourceHandle": "{œdataTypeœ:œPromptœ,œidœ:œPrompt-Axryiœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "GoogleGenerativeAIModel-C84qd",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œGoogleGenerativeAIModel-C84qdœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt",
            "id": "Prompt-bcOy9",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "GoogleGenerativeAIModel-oXoJ7",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-Prompt-bcOy9{œdataTypeœ:œPromptœ,œidœ:œPrompt-bcOy9œ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-GoogleGenerativeAIModel-oXoJ7{œfieldNameœ:œinput_valueœ,œidœ:œGoogleGenerativeAIModel-oXoJ7œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt-bcOy9",
        "sourceHandle": "{œdataTypeœ:œPromptœ,œidœ:œPrompt-bcOy9œ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "GoogleGenerativeAIModel-oXoJ7",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œGoogleGenerativeAIModel-oXoJ7œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GoogleGenerativeAIModel",
            "id": "GoogleGenerativeAIModel-C84qd",
            "name": "text_output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "answerfromrag",
            "id": "Prompt-bcOy9",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-GoogleGenerativeAIModel-C84qd{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-C84qdœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-Prompt-bcOy9{œfieldNameœ:œanswerfromragœ,œidœ:œPrompt-bcOy9œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "GoogleGenerativeAIModel-C84qd",
        "sourceHandle": "{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-C84qdœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt-bcOy9",
        "targetHandle": "{œfieldNameœ:œanswerfromragœ,œidœ:œPrompt-bcOy9œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-GyMRK",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "question",
            "id": "Prompt-bcOy9",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-TextInput-GyMRK{œdataTypeœ:œTextInputœ,œidœ:œTextInput-GyMRKœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-Prompt-bcOy9{œfieldNameœ:œquestionœ,œidœ:œPrompt-bcOy9œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "TextInput-GyMRK",
        "sourceHandle": "{œdataTypeœ:œTextInputœ,œidœ:œTextInput-GyMRKœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt-bcOy9",
        "targetHandle": "{œfieldNameœ:œquestionœ,œidœ:œPrompt-bcOy9œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GoogleGenerativeAIModel",
            "id": "GoogleGenerativeAIModel-QPEqu",
            "name": "model_output",
            "output_types": [
              "LanguageModel"
            ]
          },
          "targetHandle": {
            "fieldName": "model",
            "id": "BatchRunComponent-k9142",
            "inputTypes": [
              "LanguageModel"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-GoogleGenerativeAIModel-QPEqu{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-QPEquœ,œnameœ:œmodel_outputœ,œoutput_typesœ:[œLanguageModelœ]}-BatchRunComponent-k9142{œfieldNameœ:œmodelœ,œidœ:œBatchRunComponent-k9142œ,œinputTypesœ:[œLanguageModelœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "GoogleGenerativeAIModel-QPEqu",
        "sourceHandle": "{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-QPEquœ,œnameœ:œmodel_outputœ,œoutput_typesœ:[œLanguageModelœ]}",
        "target": "BatchRunComponent-k9142",
        "targetHandle": "{œfieldNameœ:œmodelœ,œidœ:œBatchRunComponent-k9142œ,œinputTypesœ:[œLanguageModelœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt",
            "id": "Prompt-X0W24",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "system_message",
            "id": "BatchRunComponent-k9142",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-Prompt-X0W24{œdataTypeœ:œPromptœ,œidœ:œPrompt-X0W24œ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-BatchRunComponent-k9142{œfieldNameœ:œsystem_messageœ,œidœ:œBatchRunComponent-k9142œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt-X0W24",
        "sourceHandle": "{œdataTypeœ:œPromptœ,œidœ:œPrompt-X0W24œ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "BatchRunComponent-k9142",
        "targetHandle": "{œfieldNameœ:œsystem_messageœ,œidœ:œBatchRunComponent-k9142œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt",
            "id": "Prompt-LoGYf",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "GoogleGenerativeAIModel-6HIUq",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-Prompt-LoGYf{œdataTypeœ:œPromptœ,œidœ:œPrompt-LoGYfœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-GoogleGenerativeAIModel-6HIUq{œfieldNameœ:œinput_valueœ,œidœ:œGoogleGenerativeAIModel-6HIUqœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt-LoGYf",
        "sourceHandle": "{œdataTypeœ:œPromptœ,œidœ:œPrompt-LoGYfœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "GoogleGenerativeAIModel-6HIUq",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œGoogleGenerativeAIModel-6HIUqœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GoogleGenerativeAIModel",
            "id": "GoogleGenerativeAIModel-6HIUq",
            "name": "text_output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "json_string",
            "id": "JSONtoData-bdh5B",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-GoogleGenerativeAIModel-6HIUq{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-6HIUqœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-JSONtoData-bdh5B{œfieldNameœ:œjson_stringœ,œidœ:œJSONtoData-bdh5Bœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "GoogleGenerativeAIModel-6HIUq",
        "sourceHandle": "{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-6HIUqœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "JSONtoData-bdh5B",
        "targetHandle": "{œfieldNameœ:œjson_stringœ,œidœ:œJSONtoData-bdh5Bœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JSONtoData",
            "id": "JSONtoData-bdh5B",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-Jq0lR",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-JSONtoData-bdh5B{œdataTypeœ:œJSONtoDataœ,œidœ:œJSONtoData-bdh5Bœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-ParserComponent-Jq0lR{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-Jq0lRœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "JSONtoData-bdh5B",
        "sourceHandle": "{œdataTypeœ:œJSONtoDataœ,œidœ:œJSONtoData-bdh5Bœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}",
        "target": "ParserComponent-Jq0lR",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-Jq0lRœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-Jq0lR",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value_1",
            "id": "GoogleSearchAPICore-fbA6H",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-ParserComponent-Jq0lR{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-Jq0lRœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-GoogleSearchAPICore-fbA6H{œfieldNameœ:œinput_value_1œ,œidœ:œGoogleSearchAPICore-fbA6Hœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-Jq0lR",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-Jq0lRœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "GoogleSearchAPICore-fbA6H",
        "targetHandle": "{œfieldNameœ:œinput_value_1œ,œidœ:œGoogleSearchAPICore-fbA6Hœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JSONtoData",
            "id": "JSONtoData-bdh5B",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-XCXGA",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-JSONtoData-bdh5B{œdataTypeœ:œJSONtoDataœ,œidœ:œJSONtoData-bdh5Bœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-ParserComponent-XCXGA{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-XCXGAœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "JSONtoData-bdh5B",
        "sourceHandle": "{œdataTypeœ:œJSONtoDataœ,œidœ:œJSONtoData-bdh5Bœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}",
        "target": "ParserComponent-XCXGA",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-XCXGAœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-XCXGA",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value_2",
            "id": "GoogleSearchAPICore-fbA6H",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-ParserComponent-XCXGA{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-XCXGAœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-GoogleSearchAPICore-fbA6H{œfieldNameœ:œinput_value_2œ,œidœ:œGoogleSearchAPICore-fbA6Hœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-XCXGA",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-XCXGAœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "GoogleSearchAPICore-fbA6H",
        "targetHandle": "{œfieldNameœ:œinput_value_2œ,œidœ:œGoogleSearchAPICore-fbA6Hœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataFrameOperationsComponent",
            "id": "DataFrameOperationsComponent-r917l",
            "name": "output",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df",
            "id": "DataFrameOperationsComponent-NJBFS",
            "inputTypes": [
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataFrameOperationsComponent-r917l{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-r917lœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-DataFrameOperationsComponent-NJBFS{œfieldNameœ:œdfœ,œidœ:œDataFrameOperationsComponent-NJBFSœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataFrameOperationsComponent-r917l",
        "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-r917lœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "DataFrameOperationsComponent-NJBFS",
        "targetHandle": "{œfieldNameœ:œdfœ,œidœ:œDataFrameOperationsComponent-NJBFSœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataFrameOperationsComponent",
            "id": "DataFrameOperationsComponent-XodCC",
            "name": "output",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df",
            "id": "DataFrameOperationsComponent-r917l",
            "inputTypes": [
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataFrameOperationsComponent-XodCC{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-XodCCœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-DataFrameOperationsComponent-r917l{œfieldNameœ:œdfœ,œidœ:œDataFrameOperationsComponent-r917lœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataFrameOperationsComponent-XodCC",
        "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-XodCCœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "DataFrameOperationsComponent-r917l",
        "targetHandle": "{œfieldNameœ:œdfœ,œidœ:œDataFrameOperationsComponent-r917lœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataFrameOperationsComponent",
            "id": "DataFrameOperationsComponent-XodCC",
            "name": "output",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df_DataFrameOperationsComponent-KY06e",
            "id": "GroupNode-E2Cn9",
            "inputTypes": [
              "DataFrame"
            ],
            "proxy": {
              "field": "df",
              "id": "DataFrameOperationsComponent-hzUrd"
            },
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataFrameOperationsComponent-XodCC{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-XodCCœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-GroupNode-E2Cn9{œfieldNameœ:œdf_DataFrameOperationsComponent-KY06eœ,œidœ:œGroupNode-E2Cn9œ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-hzUrdœ},œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataFrameOperationsComponent-XodCC",
        "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-XodCCœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "GroupNode-E2Cn9",
        "targetHandle": "{œfieldNameœ:œdf_DataFrameOperationsComponent-KY06eœ,œidœ:œGroupNode-E2Cn9œ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-hzUrdœ},œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataFrameOperationsComponent",
            "id": "DataFrameOperationsComponent-r917l",
            "name": "output",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df_DataFrameOperationsComponent-KY06e",
            "id": "GroupNode-3CFAR",
            "inputTypes": [
              "DataFrame"
            ],
            "proxy": {
              "field": "df",
              "id": "DataFrameOperationsComponent-VOeUF"
            },
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataFrameOperationsComponent-r917l{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-r917lœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-GroupNode-3CFAR{œfieldNameœ:œdf_DataFrameOperationsComponent-KY06eœ,œidœ:œGroupNode-3CFARœ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-VOeUFœ},œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataFrameOperationsComponent-r917l",
        "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-r917lœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "GroupNode-3CFAR",
        "targetHandle": "{œfieldNameœ:œdf_DataFrameOperationsComponent-KY06eœ,œidœ:œGroupNode-3CFARœ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-VOeUFœ},œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataFrameOperationsComponent",
            "id": "DataFrameOperationsComponent-NJBFS",
            "name": "output",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df_DataFrameOperationsComponent-KY06e",
            "id": "GroupNode-ivTAh",
            "inputTypes": [
              "DataFrame"
            ],
            "proxy": {
              "field": "df",
              "id": "DataFrameOperationsComponent-AhdBA"
            },
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataFrameOperationsComponent-NJBFS{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-NJBFSœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-GroupNode-ivTAh{œfieldNameœ:œdf_DataFrameOperationsComponent-KY06eœ,œidœ:œGroupNode-ivTAhœ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-AhdBAœ},œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataFrameOperationsComponent-NJBFS",
        "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-NJBFSœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "GroupNode-ivTAh",
        "targetHandle": "{œfieldNameœ:œdf_DataFrameOperationsComponent-KY06eœ,œidœ:œGroupNode-ivTAhœ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-AhdBAœ},œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GroupNode",
            "id": "GroupNode-E2Cn9",
            "name": "URLComponent-QfCxw_data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data_list",
            "id": "RemoveDuplicates-ygeiv",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-GroupNode-E2Cn9{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-E2Cn9œ,œnameœ:œURLComponent-QfCxw_dataœ,œoutput_typesœ:[œDataœ]}-RemoveDuplicates-ygeiv{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-ygeivœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "GroupNode-E2Cn9",
        "sourceHandle": "{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-E2Cn9œ,œnameœ:œURLComponent-QfCxw_dataœ,œoutput_typesœ:[œDataœ]}",
        "target": "RemoveDuplicates-ygeiv",
        "targetHandle": "{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-ygeivœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GroupNode",
            "id": "GroupNode-3CFAR",
            "name": "URLComponent-QfCxw_data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data_list",
            "id": "RemoveDuplicates-ygeiv",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-GroupNode-3CFAR{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-3CFARœ,œnameœ:œURLComponent-QfCxw_dataœ,œoutput_typesœ:[œDataœ]}-RemoveDuplicates-ygeiv{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-ygeivœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "GroupNode-3CFAR",
        "sourceHandle": "{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-3CFARœ,œnameœ:œURLComponent-QfCxw_dataœ,œoutput_typesœ:[œDataœ]}",
        "target": "RemoveDuplicates-ygeiv",
        "targetHandle": "{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-ygeivœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GroupNode",
            "id": "GroupNode-ivTAh",
            "name": "URLComponent-QfCxw_data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data_list",
            "id": "RemoveDuplicates-ygeiv",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-GroupNode-ivTAh{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-ivTAhœ,œnameœ:œURLComponent-QfCxw_dataœ,œoutput_typesœ:[œDataœ]}-RemoveDuplicates-ygeiv{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-ygeivœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "GroupNode-ivTAh",
        "sourceHandle": "{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-ivTAhœ,œnameœ:œURLComponent-QfCxw_dataœ,œoutput_typesœ:[œDataœ]}",
        "target": "RemoveDuplicates-ygeiv",
        "targetHandle": "{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-ygeivœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "RemoveDuplicates",
            "id": "RemoveDuplicates-ygeiv",
            "name": "deduplicated_data_list",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data_inputs",
            "id": "MergeDataComponent-uMDUE",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-RemoveDuplicates-ygeiv{œdataTypeœ:œRemoveDuplicatesœ,œidœ:œRemoveDuplicates-ygeivœ,œnameœ:œdeduplicated_data_listœ,œoutput_typesœ:[œDataœ]}-MergeDataComponent-uMDUE{œfieldNameœ:œdata_inputsœ,œidœ:œMergeDataComponent-uMDUEœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "RemoveDuplicates-ygeiv",
        "sourceHandle": "{œdataTypeœ:œRemoveDuplicatesœ,œidœ:œRemoveDuplicates-ygeivœ,œnameœ:œdeduplicated_data_listœ,œoutput_typesœ:[œDataœ]}",
        "target": "MergeDataComponent-uMDUE",
        "targetHandle": "{œfieldNameœ:œdata_inputsœ,œidœ:œMergeDataComponent-uMDUEœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataFrameOperationsComponent",
            "id": "DataFrameOperationsComponent-NJBFS",
            "name": "output",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df",
            "id": "DataFrameOperationsComponent-mxVNC",
            "inputTypes": [
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataFrameOperationsComponent-NJBFS{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-NJBFSœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-DataFrameOperationsComponent-mxVNC{œfieldNameœ:œdfœ,œidœ:œDataFrameOperationsComponent-mxVNCœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataFrameOperationsComponent-NJBFS",
        "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-NJBFSœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "DataFrameOperationsComponent-mxVNC",
        "targetHandle": "{œfieldNameœ:œdfœ,œidœ:œDataFrameOperationsComponent-mxVNCœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataFrameOperationsComponent",
            "id": "DataFrameOperationsComponent-mxVNC",
            "name": "output",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df_DataFrameOperationsComponent-KY06e",
            "id": "GroupNode-0D2IO",
            "inputTypes": [
              "DataFrame"
            ],
            "proxy": {
              "field": "df",
              "id": "DataFrameOperationsComponent-6pM1u"
            },
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataFrameOperationsComponent-mxVNC{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-mxVNCœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-GroupNode-0D2IO{œfieldNameœ:œdf_DataFrameOperationsComponent-KY06eœ,œidœ:œGroupNode-0D2IOœ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-6pM1uœ},œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataFrameOperationsComponent-mxVNC",
        "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-mxVNCœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "GroupNode-0D2IO",
        "targetHandle": "{œfieldNameœ:œdf_DataFrameOperationsComponent-KY06eœ,œidœ:œGroupNode-0D2IOœ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-6pM1uœ},œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataFrameOperationsComponent",
            "id": "DataFrameOperationsComponent-mxVNC",
            "name": "output",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df",
            "id": "DataFrameOperationsComponent-hzkRU",
            "inputTypes": [
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataFrameOperationsComponent-mxVNC{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-mxVNCœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-DataFrameOperationsComponent-hzkRU{œfieldNameœ:œdfœ,œidœ:œDataFrameOperationsComponent-hzkRUœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataFrameOperationsComponent-mxVNC",
        "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-mxVNCœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "DataFrameOperationsComponent-hzkRU",
        "targetHandle": "{œfieldNameœ:œdfœ,œidœ:œDataFrameOperationsComponent-hzkRUœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataFrameOperationsComponent",
            "id": "DataFrameOperationsComponent-hzkRU",
            "name": "output",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df_DataFrameOperationsComponent-KY06e",
            "id": "GroupNode-qAkK7",
            "inputTypes": [
              "DataFrame"
            ],
            "proxy": {
              "field": "df",
              "id": "DataFrameOperationsComponent-UON6D"
            },
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataFrameOperationsComponent-hzkRU{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-hzkRUœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-GroupNode-qAkK7{œfieldNameœ:œdf_DataFrameOperationsComponent-KY06eœ,œidœ:œGroupNode-qAkK7œ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-UON6Dœ},œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataFrameOperationsComponent-hzkRU",
        "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-hzkRUœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "GroupNode-qAkK7",
        "targetHandle": "{œfieldNameœ:œdf_DataFrameOperationsComponent-KY06eœ,œidœ:œGroupNode-qAkK7œ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-UON6Dœ},œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataFrameOperationsComponent",
            "id": "DataFrameOperationsComponent-hzkRU",
            "name": "output",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df_DataFrameOperationsComponent-RPHoF",
            "id": "GroupNode-RJLyv",
            "inputTypes": [
              "DataFrame"
            ],
            "proxy": {
              "field": "df",
              "id": "DataFrameOperationsComponent-w9bzA"
            },
            "type": "other"
          }
        },
        "id": "reactflow__edge-DataFrameOperationsComponent-hzkRU{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-hzkRUœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-GroupNode-RJLyv{œfieldNameœ:œdf_DataFrameOperationsComponent-RPHoFœ,œidœ:œGroupNode-RJLyvœ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-w9bzAœ},œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataFrameOperationsComponent-hzkRU",
        "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-hzkRUœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "GroupNode-RJLyv",
        "targetHandle": "{œfieldNameœ:œdf_DataFrameOperationsComponent-RPHoFœ,œidœ:œGroupNode-RJLyvœ,œinputTypesœ:[œDataFrameœ],œproxyœ:{œfieldœ:œdfœ,œidœ:œDataFrameOperationsComponent-w9bzAœ},œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GroupNode",
            "id": "GroupNode-0D2IO",
            "name": "URLComponent-QfCxw_data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data_list",
            "id": "RemoveDuplicates-ygeiv",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-GroupNode-0D2IO{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-0D2IOœ,œnameœ:œURLComponent-QfCxw_dataœ,œoutput_typesœ:[œDataœ]}-RemoveDuplicates-ygeiv{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-ygeivœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "GroupNode-0D2IO",
        "sourceHandle": "{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-0D2IOœ,œnameœ:œURLComponent-QfCxw_dataœ,œoutput_typesœ:[œDataœ]}",
        "target": "RemoveDuplicates-ygeiv",
        "targetHandle": "{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-ygeivœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GroupNode",
            "id": "GroupNode-qAkK7",
            "name": "URLComponent-QfCxw_data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data_list",
            "id": "RemoveDuplicates-ygeiv",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-GroupNode-qAkK7{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-qAkK7œ,œnameœ:œURLComponent-QfCxw_dataœ,œoutput_typesœ:[œDataœ]}-RemoveDuplicates-ygeiv{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-ygeivœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "GroupNode-qAkK7",
        "sourceHandle": "{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-qAkK7œ,œnameœ:œURLComponent-QfCxw_dataœ,œoutput_typesœ:[œDataœ]}",
        "target": "RemoveDuplicates-ygeiv",
        "targetHandle": "{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-ygeivœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GroupNode",
            "id": "GroupNode-RJLyv",
            "name": "URLComponent-1pggm_data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data_list",
            "id": "RemoveDuplicates-ygeiv",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-GroupNode-RJLyv{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-RJLyvœ,œnameœ:œURLComponent-1pggm_dataœ,œoutput_typesœ:[œDataœ]}-RemoveDuplicates-ygeiv{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-ygeivœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "GroupNode-RJLyv",
        "sourceHandle": "{œdataTypeœ:œGroupNodeœ,œidœ:œGroupNode-RJLyvœ,œnameœ:œURLComponent-1pggm_dataœ,œoutput_typesœ:[œDataœ]}",
        "target": "RemoveDuplicates-ygeiv",
        "targetHandle": "{œfieldNameœ:œdata_listœ,œidœ:œRemoveDuplicates-ygeivœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GoogleSearchAPICore",
            "id": "GoogleSearchAPICore-fbA6H",
            "name": "results",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df",
            "id": "DataFrameOperationsComponent-XodCC",
            "inputTypes": [
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-GoogleSearchAPICore-fbA6H{œdataTypeœ:œGoogleSearchAPICoreœ,œidœ:œGoogleSearchAPICore-fbA6Hœ,œnameœ:œresultsœ,œoutput_typesœ:[œDataFrameœ]}-DataFrameOperationsComponent-XodCC{œfieldNameœ:œdfœ,œidœ:œDataFrameOperationsComponent-XodCCœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "GoogleSearchAPICore-fbA6H",
        "sourceHandle": "{œdataTypeœ:œGoogleSearchAPICoreœ,œidœ:œGoogleSearchAPICore-fbA6Hœ,œnameœ:œresultsœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "DataFrameOperationsComponent-XodCC",
        "targetHandle": "{œfieldNameœ:œdfœ,œidœ:œDataFrameOperationsComponent-XodCCœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MergeDataComponent",
            "id": "MergeDataComponent-uMDUE",
            "name": "combined_data",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "df",
            "id": "BatchRunComponent-k9142",
            "inputTypes": [
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-MergeDataComponent-uMDUE{œdataTypeœ:œMergeDataComponentœ,œidœ:œMergeDataComponent-uMDUEœ,œnameœ:œcombined_dataœ,œoutput_typesœ:[œDataFrameœ]}-BatchRunComponent-k9142{œfieldNameœ:œdfœ,œidœ:œBatchRunComponent-k9142œ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "MergeDataComponent-uMDUE",
        "sourceHandle": "{œdataTypeœ:œMergeDataComponentœ,œidœ:œMergeDataComponent-uMDUEœ,œnameœ:œcombined_dataœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "BatchRunComponent-k9142",
        "targetHandle": "{œfieldNameœ:œdfœ,œidœ:œBatchRunComponent-k9142œ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "BatchRunComponent",
            "id": "BatchRunComponent-k9142",
            "name": "batch_results",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-HDZ1K",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-BatchRunComponent-k9142{œdataTypeœ:œBatchRunComponentœ,œidœ:œBatchRunComponent-k9142œ,œnameœ:œbatch_resultsœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-HDZ1K{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-HDZ1Kœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "BatchRunComponent-k9142",
        "sourceHandle": "{œdataTypeœ:œBatchRunComponentœ,œidœ:œBatchRunComponent-k9142œ,œnameœ:œbatch_resultsœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "ParserComponent-HDZ1K",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-HDZ1Kœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-GyMRK",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input",
            "id": "Prompt-LoGYf",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__TextInput-GyMRK{œdataTypeœ:œTextInputœ,œidœ:œTextInput-GyMRKœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-Prompt-LoGYf{œfieldNameœ:œinputœ,œidœ:œPrompt-LoGYfœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "TextInput-GyMRK",
        "sourceHandle": "{œdataTypeœ:œTextInputœ,œidœ:œTextInput-GyMRKœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt-LoGYf",
        "targetHandle": "{œfieldNameœ:œinputœ,œidœ:œPrompt-LoGYfœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-HDZ1K",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "websearchresultsfromgivenwebsites",
            "id": "Prompt-bcOy9",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-HDZ1K{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-HDZ1Kœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt-bcOy9{œfieldNameœ:œwebsearchresultsfromgivenwebsitesœ,œidœ:œPrompt-bcOy9œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-HDZ1K",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-HDZ1Kœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt-bcOy9",
        "targetHandle": "{œfieldNameœ:œwebsearchresultsfromgivenwebsitesœ,œidœ:œPrompt-bcOy9œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GoogleGenerativeAIModel",
            "id": "GoogleGenerativeAIModel-oXoJ7",
            "name": "text_output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "answer",
            "id": "Prompt-JJiqx",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__GoogleGenerativeAIModel-oXoJ7{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-oXoJ7œ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-Prompt-JJiqx{œfieldNameœ:œanswerœ,œidœ:œPrompt-JJiqxœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "GoogleGenerativeAIModel-oXoJ7",
        "sourceHandle": "{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-oXoJ7œ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt-JJiqx",
        "targetHandle": "{œfieldNameœ:œanswerœ,œidœ:œPrompt-JJiqxœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-MMfCE",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "vector",
            "id": "Prompt-JJiqx",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-MMfCE{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-MMfCEœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt-JJiqx{œfieldNameœ:œvectorœ,œidœ:œPrompt-JJiqxœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-MMfCE",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-MMfCEœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt-JJiqx",
        "targetHandle": "{œfieldNameœ:œvectorœ,œidœ:œPrompt-JJiqxœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-GyMRK",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "question",
            "id": "Prompt-JJiqx",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__TextInput-GyMRK{œdataTypeœ:œTextInputœ,œidœ:œTextInput-GyMRKœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-Prompt-JJiqx{œfieldNameœ:œquestionœ,œidœ:œPrompt-JJiqxœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "TextInput-GyMRK",
        "sourceHandle": "{œdataTypeœ:œTextInputœ,œidœ:œTextInput-GyMRKœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt-JJiqx",
        "targetHandle": "{œfieldNameœ:œquestionœ,œidœ:œPrompt-JJiqxœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-HDZ1K",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "web",
            "id": "Prompt-JJiqx",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-HDZ1K{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-HDZ1Kœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt-JJiqx{œfieldNameœ:œwebœ,œidœ:œPrompt-JJiqxœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-HDZ1K",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-HDZ1Kœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt-JJiqx",
        "targetHandle": "{œfieldNameœ:œwebœ,œidœ:œPrompt-JJiqxœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Memory",
            "id": "Memory-fFchE",
            "name": "messages_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "memory",
            "id": "Prompt-JJiqx",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Memory-fFchE{œdataTypeœ:œMemoryœ,œidœ:œMemory-fFchEœ,œnameœ:œmessages_textœ,œoutput_typesœ:[œMessageœ]}-Prompt-JJiqx{œfieldNameœ:œmemoryœ,œidœ:œPrompt-JJiqxœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Memory-fFchE",
        "sourceHandle": "{œdataTypeœ:œMemoryœ,œidœ:œMemory-fFchEœ,œnameœ:œmessages_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt-JJiqx",
        "targetHandle": "{œfieldNameœ:œmemoryœ,œidœ:œPrompt-JJiqxœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt",
            "id": "Prompt-JJiqx",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "GoogleGenerativeAIModel-rh6y4",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt-JJiqx{œdataTypeœ:œPromptœ,œidœ:œPrompt-JJiqxœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-GoogleGenerativeAIModel-rh6y4{œfieldNameœ:œinput_valueœ,œidœ:œGoogleGenerativeAIModel-rh6y4œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt-JJiqx",
        "sourceHandle": "{œdataTypeœ:œPromptœ,œidœ:œPrompt-JJiqxœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "GoogleGenerativeAIModel-rh6y4",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œGoogleGenerativeAIModel-rh6y4œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GoogleGenerativeAIModel",
            "id": "GoogleGenerativeAIModel-rh6y4",
            "name": "text_output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-Kr85Q",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__GoogleGenerativeAIModel-rh6y4{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-rh6y4œ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-Kr85Q{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-Kr85Qœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "GoogleGenerativeAIModel-rh6y4",
        "sourceHandle": "{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-rh6y4œ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-Kr85Q",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-Kr85Qœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GoogleGenerativeAIModel",
            "id": "GoogleGenerativeAIModel-dusep",
            "name": "text_output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-4QeGI",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__GoogleGenerativeAIModel-dusep{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-dusepœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-4QeGI{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-4QeGIœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "GoogleGenerativeAIModel-dusep",
        "sourceHandle": "{œdataTypeœ:œGoogleGenerativeAIModelœ,œidœ:œGoogleGenerativeAIModel-dusepœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-4QeGI",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-4QeGIœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ConditionalRouter",
            "id": "ConditionalRouter-oksv6",
            "name": "false_result",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "GoogleGenerativeAIModel-dusep",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ConditionalRouter-oksv6{œdataTypeœ:œConditionalRouterœ,œidœ:œConditionalRouter-oksv6œ,œnameœ:œfalse_resultœ,œoutput_typesœ:[œMessageœ]}-GoogleGenerativeAIModel-dusep{œfieldNameœ:œinput_valueœ,œidœ:œGoogleGenerativeAIModel-dusepœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ConditionalRouter-oksv6",
        "sourceHandle": "{œdataTypeœ:œConditionalRouterœ,œidœ:œConditionalRouter-oksv6œ,œnameœ:œfalse_resultœ,œoutput_typesœ:[œMessageœ]}",
        "target": "GoogleGenerativeAIModel-dusep",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œGoogleGenerativeAIModel-dusepœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Agent",
            "id": "Agent-oyi9s",
            "name": "response",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_text",
            "id": "ConditionalRouter-oksv6",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Agent-oyi9s{œdataTypeœ:œAgentœ,œidœ:œAgent-oyi9sœ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}-ConditionalRouter-oksv6{œfieldNameœ:œinput_textœ,œidœ:œConditionalRouter-oksv6œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Agent-oyi9s",
        "sourceHandle": "{œdataTypeœ:œAgentœ,œidœ:œAgent-oyi9sœ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ConditionalRouter-oksv6",
        "targetHandle": "{œfieldNameœ:œinput_textœ,œidœ:œConditionalRouter-oksv6œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "data": {
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-IG2mZ",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "Agent-oyi9s",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ChatInput-IG2mZ{œdataTypeœ:œChatInputœ,œidœ:œChatInput-IG2mZœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-Agent-oyi9s{œfieldNameœ:œinput_valueœ,œidœ:œAgent-oyi9sœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ChatInput-IG2mZ",
        "sourceHandle": "{œdataTypeœ:œChatInputœ,œidœ:œChatInput-IG2mZœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Agent-oyi9s",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œAgent-oyi9sœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "data": {
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-IG2mZ",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "message",
            "id": "ConditionalRouter-oksv6",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ChatInput-IG2mZ{œdataTypeœ:œChatInputœ,œidœ:œChatInput-IG2mZœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-ConditionalRouter-oksv6{œfieldNameœ:œmessageœ,œidœ:œConditionalRouter-oksv6œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ChatInput-IG2mZ",
        "sourceHandle": "{œdataTypeœ:œChatInputœ,œidœ:œChatInput-IG2mZœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ConditionalRouter-oksv6",
        "targetHandle": "{œfieldNameœ:œmessageœ,œidœ:œConditionalRouter-oksv6œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "data": {
          "sourceHandle": {
            "dataType": "ConditionalRouter",
            "id": "ConditionalRouter-oksv6",
            "name": "true_result",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "TextInput-GyMRK",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ConditionalRouter-oksv6{œdataTypeœ:œConditionalRouterœ,œidœ:œConditionalRouter-oksv6œ,œnameœ:œtrue_resultœ,œoutput_typesœ:[œMessageœ]}-TextInput-GyMRK{œfieldNameœ:œinput_valueœ,œidœ:œTextInput-GyMRKœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ConditionalRouter-oksv6",
        "sourceHandle": "{œdataTypeœ:œConditionalRouterœ,œidœ:œConditionalRouter-oksv6œ,œnameœ:œtrue_resultœ,œoutput_typesœ:[œMessageœ]}",
        "target": "TextInput-GyMRK",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œTextInput-GyMRKœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "GoogleGenerativeAIModel-aADfw",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generate text using Google Generative AI.",
            "display_name": "Google Generative AI",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_output_tokens",
              "model_name",
              "api_key",
              "top_p",
              "temperature",
              "n",
              "top_k",
              "tool_model_enabled"
            ],
            "frozen": false,
            "icon": "GoogleGenerativeAI",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": false,
                "method": "text_response",
                "name": "text_output",
                "options": null,
                "required_inputs": [],
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "hidden": false,
                "method": "build_model",
                "name": "model_output",
                "options": null,
                "required_inputs": [
                  "api_key"
                ],
                "selected": "LanguageModel",
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Google API Key",
                "dynamic": false,
                "info": "The Google API Key to use for the Google Generative AI.",
                "input_types": [
                  "Message"
                ],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nimport requests\nfrom loguru import logger\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.google_generative_ai_constants import GOOGLE_GENERATIVE_AI_MODELS\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import DropdownInput, FloatInput, IntInput, SecretStrInput, SliderInput\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.schema import dotdict\n\n\nclass GoogleGenerativeAIComponent(LCModelComponent):\n    display_name = \"Google Generative AI\"\n    description = \"Generate text using Google Generative AI.\"\n    icon = \"GoogleGenerativeAI\"\n    name = \"GoogleGenerativeAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_output_tokens\", display_name=\"Max Output Tokens\", info=\"The maximum number of tokens to generate.\"\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model\",\n            info=\"The name of the model to use.\",\n            options=GOOGLE_GENERATIVE_AI_MODELS,\n            value=\"gemini-1.5-pro\",\n            refresh_button=True,\n            combobox=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Google API Key\",\n            info=\"The Google API Key to use for the Google Generative AI.\",\n            required=True,\n            real_time_refresh=True,\n        ),\n        FloatInput(\n            name=\"top_p\",\n            display_name=\"Top P\",\n            info=\"The maximum cumulative probability of tokens to consider when sampling.\",\n            advanced=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            range_spec=RangeSpec(min=0, max=2, step=0.01),\n            info=\"Controls randomness. Lower values are more deterministic, higher values are more creative.\",\n        ),\n        IntInput(\n            name=\"n\",\n            display_name=\"N\",\n            info=\"Number of chat completions to generate for each prompt. \"\n            \"Note that the API may not return the full n completions if duplicates are generated.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"top_k\",\n            display_name=\"Top K\",\n            info=\"Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"tool_model_enabled\",\n            display_name=\"Tool Model Enabled\",\n            info=\"Whether to use the tool model.\",\n            value=False,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        try:\n            from langchain_google_genai import ChatGoogleGenerativeAI\n        except ImportError as e:\n            msg = \"The 'langchain_google_genai' package is required to use the Google Generative AI model.\"\n            raise ImportError(msg) from e\n\n        google_api_key = self.api_key\n        model = self.model_name\n        max_output_tokens = self.max_output_tokens\n        temperature = self.temperature\n        top_k = self.top_k\n        top_p = self.top_p\n        n = self.n\n\n        return ChatGoogleGenerativeAI(\n            model=model,\n            max_output_tokens=max_output_tokens or None,\n            temperature=temperature,\n            top_k=top_k or None,\n            top_p=top_p or None,\n            n=n or 1,\n            google_api_key=SecretStr(google_api_key).get_secret_value(),\n        )\n\n    def get_models(self, tool_model_enabled: bool | None = None) -> list[str]:\n        try:\n            import google.generativeai as genai\n\n            genai.configure(api_key=self.api_key)\n            model_ids = [\n                model.name.replace(\"models/\", \"\")\n                for model in genai.list_models()\n                if \"generateContent\" in model.supported_generation_methods\n            ]\n            model_ids.sort(reverse=True)\n        except (ImportError, ValueError) as e:\n            logger.exception(f\"Error getting model names: {e}\")\n            model_ids = GOOGLE_GENERATIVE_AI_MODELS\n        if tool_model_enabled:\n            try:\n                from langchain_google_genai.chat_models import ChatGoogleGenerativeAI\n            except ImportError as e:\n                msg = \"langchain_google_genai is not installed.\"\n                raise ImportError(msg) from e\n            for model in model_ids:\n                model_with_tool = ChatGoogleGenerativeAI(\n                    model=self.model_name,\n                    google_api_key=self.api_key,\n                )\n                if not self.supports_tool_calling(model_with_tool):\n                    model_ids.remove(model)\n        return model_ids\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name in {\"base_url\", \"model_name\", \"tool_model_enabled\", \"api_key\"} and field_value:\n            try:\n                if len(self.api_key) == 0:\n                    ids = GOOGLE_GENERATIVE_AI_MODELS\n                else:\n                    try:\n                        ids = self.get_models(tool_model_enabled=self.tool_model_enabled)\n                    except (ImportError, ValueError, requests.exceptions.RequestException) as e:\n                        logger.exception(f\"Error getting model names: {e}\")\n                        ids = GOOGLE_GENERATIVE_AI_MODELS\n                build_config[\"model_name\"][\"options\"] = ids\n                build_config[\"model_name\"][\"value\"] = ids[0]\n            except Exception as e:\n                msg = f\"Error getting model names: {e}\"\n                raise ValueError(msg) from e\n        return build_config\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_output_tokens": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Max Output Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_output_tokens",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model",
                "dynamic": false,
                "info": "The name of the model to use.",
                "name": "model_name",
                "options": [
                  "learnlm-2.0-flash-experimental",
                  "learnlm-1.5-pro-experimental",
                  "gemma-3-4b-it",
                  "gemma-3-27b-it",
                  "gemma-3-1b-it",
                  "gemma-3-12b-it",
                  "gemini-pro-vision",
                  "gemini-exp-1206",
                  "gemini-2.5-pro-preview-03-25",
                  "gemini-2.5-pro-exp-03-25",
                  "gemini-2.5-flash-preview-04-17",
                  "gemini-2.0-pro-exp-02-05",
                  "gemini-2.0-pro-exp",
                  "gemini-2.0-flash-thinking-exp-1219",
                  "gemini-2.0-flash-thinking-exp-01-21",
                  "gemini-2.0-flash-thinking-exp",
                  "gemini-2.0-flash-lite-preview-02-05",
                  "gemini-2.0-flash-lite-preview",
                  "gemini-2.0-flash-lite-001",
                  "gemini-2.0-flash-lite",
                  "gemini-2.0-flash-exp-image-generation",
                  "gemini-2.0-flash-exp",
                  "gemini-2.0-flash-001",
                  "gemini-2.0-flash",
                  "gemini-1.5-pro-latest",
                  "gemini-1.5-pro-002",
                  "gemini-1.5-pro-001",
                  "gemini-1.5-pro",
                  "gemini-1.5-flash-latest",
                  "gemini-1.5-flash-8b-latest",
                  "gemini-1.5-flash-8b-exp-0924",
                  "gemini-1.5-flash-8b-exp-0827",
                  "gemini-1.5-flash-8b-001",
                  "gemini-1.5-flash-8b",
                  "gemini-1.5-flash-002",
                  "gemini-1.5-flash-001-tuning",
                  "gemini-1.5-flash-001",
                  "gemini-1.5-flash",
                  "gemini-1.0-pro-vision-latest"
                ],
                "options_metadata": [],
                "placeholder": "",
                "refresh_button": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "gemini-1.5-flash-latest"
              },
              "n": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "N",
                "dynamic": false,
                "info": "Number of chat completions to generate for each prompt. Note that the API may not return the full n completions if duplicates are generated.",
                "list": false,
                "list_add_label": "Add More",
                "name": "n",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "System message to pass to the model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are a question decomposition specialist working within a multi-agent AI system. Your task is to analyze any user input and break it down into smaller, manageable four sub-questions.\n\nEach sub-question should:\n- Be clear and independent.\n- Be focused on a single concept or task.\n\nDecompose multi-part questions, vague statements, or complicated opinions into simpler components.\n\n**Return your output strictly as a JSON object** in the following format and do not include any additional text or explanation:\n\n[\n  {\n    \"question\": \"First question here.\"\n  },\n  {\n    \"question\": \"Second question here.\"\n  },\n  {\n    \"question\": \"Third question here.\"\n  },\n  {\n    \"question\": \"Fourth question here.\"\n  }\n]\n\nOriginal Question:  \n{question}\n"
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Controls randomness. Lower values are more deterministic, higher values are more creative.",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 2,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              },
              "tool_model_enabled": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Tool Model Enabled",
                "dynamic": false,
                "info": "Whether to use the tool model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "tool_model_enabled",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "top_k": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Top K",
                "dynamic": false,
                "info": "Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_k",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "top_p": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Top P",
                "dynamic": false,
                "info": "The maximum cumulative probability of tokens to consider when sampling.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_p",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "GoogleGenerativeAIModel"
        },
        "id": "GoogleGenerativeAIModel-aADfw",
        "measured": {
          "height": 652,
          "width": 320
        },
        "position": {
          "x": 1278.5135340519535,
          "y": 419.9010516027104
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt-EydHv",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "question"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt",
            "documentation": "",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "prompts",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt Message",
                "hidden": false,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": null,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "question": {
                "advanced": false,
                "display_name": "question",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "question",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "You are a question decomposition specialist. When given user input, break it down into exactly four clear and balanced sub-questions. Focus on extracting the key components of the original question and dividing them evenly in meaning or scope. Each sub-question should be simple, independent, and focused on a specific aspect of the original input.  \n\n**Return your output strictly as a JSON object** with the following structure and no other text:\n\n[\n  (\n    \"question\": \"First question here.\"\n  ),\n  (\n    \"question\": \"Second question here.\"\n  ),\n  (\n    \"question\": \"Third question here.\"\n  ),\n  (\n    \"question\": \"Fourth question here.\"\n  )\n]\n\n\nOriginal Question:  \n{question}"
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt"
        },
        "id": "Prompt-EydHv",
        "measured": {
          "height": 411,
          "width": 320
        },
        "position": {
          "x": 803.7497844227875,
          "y": 481.9766243872875
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "TextInput-GyMRK",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get text inputs from the Playground.",
            "display_name": "Text Input",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value"
            ],
            "frozen": false,
            "icon": "type",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": false,
                "method": "text_response",
                "name": "text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get text inputs from the Playground.\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n"
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Text to be passed as input.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Why did the English begin to focus more on Sri Lanka in the 18th century?"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "TextInput"
        },
        "dragging": false,
        "id": "TextInput-GyMRK",
        "measured": {
          "height": 228,
          "width": 320
        },
        "position": {
          "x": -1500,
          "y": 864.0629841472696
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "JSONtoData-jzHeC",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "category": "data",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Convert a JSON file, JSON from a file path, or a JSON string to a Data object or a list of Data objects",
            "display_name": "Load JSON",
            "documentation": "",
            "edited": false,
            "field_order": [
              "json_file",
              "json_path",
              "json_string"
            ],
            "frozen": false,
            "icon": "braces",
            "key": "JSONtoData",
            "legacy": true,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": false,
                "method": "convert_json_to_data",
                "name": "data",
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.07433131107431833,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom pathlib import Path\n\nfrom json_repair import repair_json\n\nfrom langflow.custom import Component\nfrom langflow.io import FileInput, MessageTextInput, MultilineInput, Output\nfrom langflow.schema import Data\n\n\nclass JSONToDataComponent(Component):\n    display_name = \"Load JSON\"\n    description = (\n        \"Convert a JSON file, JSON from a file path, or a JSON string to a Data object or a list of Data objects\"\n    )\n    icon = \"braces\"\n    name = \"JSONtoData\"\n    legacy = True\n\n    inputs = [\n        FileInput(\n            name=\"json_file\",\n            display_name=\"JSON File\",\n            file_types=[\"json\"],\n            info=\"Upload a JSON file to convert to a Data object or list of Data objects\",\n        ),\n        MessageTextInput(\n            name=\"json_path\",\n            display_name=\"JSON File Path\",\n            info=\"Provide the path to the JSON file as pure text\",\n        ),\n        MultilineInput(\n            name=\"json_string\",\n            display_name=\"JSON String\",\n            info=\"Enter a valid JSON string (object or array) to convert to a Data object or list of Data objects\",\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"data\", display_name=\"Data\", method=\"convert_json_to_data\"),\n    ]\n\n    def convert_json_to_data(self) -> Data | list[Data]:\n        if sum(bool(field) for field in [self.json_file, self.json_path, self.json_string]) != 1:\n            msg = \"Please provide exactly one of: JSON file, file path, or JSON string.\"\n            self.status = msg\n            raise ValueError(msg)\n\n        json_data = None\n\n        try:\n            if self.json_file:\n                resolved_path = self.resolve_path(self.json_file)\n                file_path = Path(resolved_path)\n                if file_path.suffix.lower() != \".json\":\n                    self.status = \"The provided file must be a JSON file.\"\n                else:\n                    json_data = file_path.read_text(encoding=\"utf-8\")\n\n            elif self.json_path:\n                file_path = Path(self.json_path)\n                if file_path.suffix.lower() != \".json\":\n                    self.status = \"The provided file must be a JSON file.\"\n                else:\n                    json_data = file_path.read_text(encoding=\"utf-8\")\n\n            else:\n                json_data = self.json_string\n\n            if json_data:\n                # Try to parse the JSON string\n                try:\n                    parsed_data = json.loads(json_data)\n                except json.JSONDecodeError:\n                    # If JSON parsing fails, try to repair the JSON string\n                    repaired_json_string = repair_json(json_data)\n                    parsed_data = json.loads(repaired_json_string)\n\n                # Check if the parsed data is a list\n                if isinstance(parsed_data, list):\n                    result = [Data(data=item) for item in parsed_data]\n                else:\n                    result = Data(data=parsed_data)\n                self.status = result\n                return result\n\n        except (json.JSONDecodeError, SyntaxError, ValueError) as e:\n            error_message = f\"Invalid JSON or Python literal: {e}\"\n            self.status = error_message\n            raise ValueError(error_message) from e\n\n        except Exception as e:\n            error_message = f\"An error occurred: {e}\"\n            self.status = error_message\n            raise ValueError(error_message) from e\n\n        # An error occurred\n        raise ValueError(self.status)\n"
              },
              "json_file": {
                "_input_type": "FileInput",
                "advanced": false,
                "display_name": "JSON File",
                "dynamic": false,
                "fileTypes": [
                  "json"
                ],
                "file_path": "",
                "info": "Upload a JSON file to convert to a Data object or list of Data objects",
                "list": false,
                "list_add_label": "Add More",
                "name": "json_file",
                "placeholder": "",
                "required": false,
                "show": true,
                "temp_file": false,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "json_path": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "JSON File Path",
                "dynamic": false,
                "info": "Provide the path to the JSON file as pure text",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "json_path",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "json_string": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "JSON String",
                "dynamic": false,
                "info": "Enter a valid JSON string (object or array) to convert to a Data object or list of Data objects",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "json_string",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "JSONtoData"
        },
        "id": "JSONtoData-jzHeC",
        "measured": {
          "height": 442,
          "width": 320
        },
        "position": {
          "x": 1726.8857268865695,
          "y": 616.2315704879836
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Google Generative AI Embeddings-lV2eD",
          "node": {
            "base_classes": [
              "Embeddings"
            ],
            "beta": false,
            "category": "embeddings",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Connect to Google's generative AI embeddings service using the GoogleGenerativeAIEmbeddings class, found in the langchain-google-genai package.",
            "display_name": "Google Generative AI Embeddings",
            "documentation": "https://python.langchain.com/v0.2/docs/integrations/text_embedding/google_generative_ai/",
            "edited": false,
            "field_order": [
              "api_key",
              "model_name"
            ],
            "frozen": false,
            "icon": "Google",
            "key": "Google Generative AI Embeddings",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Embeddings",
                "hidden": false,
                "method": "build_embeddings",
                "name": "embeddings",
                "selected": "Embeddings",
                "tool_mode": true,
                "types": [
                  "Embeddings"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.001,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "API Key",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "# from langflow.field_typing import Data\n\n# TODO: remove ignore once the google package is published with types\nfrom google.ai.generativelanguage_v1beta.types import BatchEmbedContentsRequest\nfrom langchain_core.embeddings import Embeddings\nfrom langchain_google_genai import GoogleGenerativeAIEmbeddings\nfrom langchain_google_genai._common import GoogleGenerativeAIError\n\nfrom langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output, SecretStrInput\n\nMIN_DIMENSION_ERROR = \"Output dimensionality must be at least 1\"\nMAX_DIMENSION_ERROR = (\n    \"Output dimensionality cannot exceed 768. Google's embedding models only support dimensions up to 768.\"\n)\nMAX_DIMENSION = 768\nMIN_DIMENSION = 1\n\n\nclass GoogleGenerativeAIEmbeddingsComponent(Component):\n    display_name = \"Google Generative AI Embeddings\"\n    description = (\n        \"Connect to Google's generative AI embeddings service using the GoogleGenerativeAIEmbeddings class, \"\n        \"found in the langchain-google-genai package.\"\n    )\n    documentation: str = \"https://python.langchain.com/v0.2/docs/integrations/text_embedding/google_generative_ai/\"\n    icon = \"Google\"\n    name = \"Google Generative AI Embeddings\"\n\n    inputs = [\n        SecretStrInput(name=\"api_key\", display_name=\"API Key\", required=True),\n        MessageTextInput(name=\"model_name\", display_name=\"Model Name\", value=\"models/text-embedding-004\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Embeddings\", name=\"embeddings\", method=\"build_embeddings\"),\n    ]\n\n    def build_embeddings(self) -> Embeddings:\n        if not self.api_key:\n            msg = \"API Key is required\"\n            raise ValueError(msg)\n\n        class HotaGoogleGenerativeAIEmbeddings(GoogleGenerativeAIEmbeddings):\n            def __init__(self, *args, **kwargs) -> None:\n                super(GoogleGenerativeAIEmbeddings, self).__init__(*args, **kwargs)\n\n            def embed_documents(\n                self,\n                texts: list[str],\n                *,\n                batch_size: int = 100,\n                task_type: str | None = None,\n                titles: list[str] | None = None,\n                output_dimensionality: int | None = 768,\n            ) -> list[list[float]]:\n                \"\"\"Embed a list of strings.\n\n                Google Generative AI currently sets a max batch size of 100 strings.\n\n                Args:\n                    texts: List[str] The list of strings to embed.\n                    batch_size: [int] The batch size of embeddings to send to the model\n                    task_type: task_type (https://ai.google.dev/api/rest/v1/TaskType)\n                    titles: An optional list of titles for texts provided.\n                    Only applicable when TaskType is RETRIEVAL_DOCUMENT.\n                    output_dimensionality: Optional reduced dimension for the output embedding.\n                    https://ai.google.dev/api/rest/v1/models/batchEmbedContents#EmbedContentRequest\n                Returns:\n                    List of embeddings, one for each text.\n                \"\"\"\n                if output_dimensionality is not None and output_dimensionality < MIN_DIMENSION:\n                    raise ValueError(MIN_DIMENSION_ERROR)\n                if output_dimensionality is not None and output_dimensionality > MAX_DIMENSION:\n                    error_msg = MAX_DIMENSION_ERROR.format(output_dimensionality)\n                    raise ValueError(error_msg)\n\n                embeddings: list[list[float]] = []\n                batch_start_index = 0\n                for batch in GoogleGenerativeAIEmbeddings._prepare_batches(texts, batch_size):\n                    if titles:\n                        titles_batch = titles[batch_start_index : batch_start_index + len(batch)]\n                        batch_start_index += len(batch)\n                    else:\n                        titles_batch = [None] * len(batch)  # type: ignore[list-item]\n\n                    requests = [\n                        self._prepare_request(\n                            text=text,\n                            task_type=task_type,\n                            title=title,\n                            output_dimensionality=output_dimensionality,\n                        )\n                        for text, title in zip(batch, titles_batch, strict=True)\n                    ]\n\n                    try:\n                        result = self.client.batch_embed_contents(\n                            BatchEmbedContentsRequest(requests=requests, model=self.model)\n                        )\n                    except Exception as e:\n                        msg = f\"Error embedding content: {e}\"\n                        raise GoogleGenerativeAIError(msg) from e\n                    embeddings.extend([list(e.values) for e in result.embeddings])\n                return embeddings\n\n            def embed_query(\n                self,\n                text: str,\n                task_type: str | None = None,\n                title: str | None = None,\n                output_dimensionality: int | None = 768,\n            ) -> list[float]:\n                \"\"\"Embed a text.\n\n                Args:\n                    text: The text to embed.\n                    task_type: task_type (https://ai.google.dev/api/rest/v1/TaskType)\n                    title: An optional title for the text.\n                    Only applicable when TaskType is RETRIEVAL_DOCUMENT.\n                    output_dimensionality: Optional reduced dimension for the output embedding.\n                    https://ai.google.dev/api/rest/v1/models/batchEmbedContents#EmbedContentRequest\n\n                Returns:\n                    Embedding for the text.\n                \"\"\"\n                if output_dimensionality is not None and output_dimensionality < MIN_DIMENSION:\n                    raise ValueError(MIN_DIMENSION_ERROR)\n                if output_dimensionality is not None and output_dimensionality > MAX_DIMENSION:\n                    error_msg = MAX_DIMENSION_ERROR.format(output_dimensionality)\n                    raise ValueError(error_msg)\n\n                task_type = task_type or \"RETRIEVAL_QUERY\"\n                return self.embed_documents(\n                    [text],\n                    task_type=task_type,\n                    titles=[title] if title else None,\n                    output_dimensionality=output_dimensionality,\n                )[0]\n\n        return HotaGoogleGenerativeAIEmbeddings(model=self.model_name, google_api_key=self.api_key)\n"
              },
              "model_name": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Model Name",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "model_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "models/text-embedding-004"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Google Generative AI Embeddings"
        },
        "id": "Google Generative AI Embeddings-lV2eD",
        "measured": {
          "height": 371,
          "width": 320
        },
        "position": {
          "x": 3888.1454608116337,
          "y": 55.54995503743686
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "BatchRunComponent-clb8n",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": true,
            "category": "helpers",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Runs an LLM over each row of a DataFrame's column. If no column is set, the entire row is passed.",
            "display_name": "Batch Run",
            "documentation": "",
            "edited": false,
            "field_order": [
              "model",
              "system_message",
              "df",
              "column_name",
              "output_column_name",
              "enable_metadata"
            ],
            "frozen": false,
            "icon": "List",
            "key": "BatchRunComponent",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": false,
                "method": "run_batch",
                "name": "batch_results",
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.007568328950209746,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, cast\n\nimport toml  # type: ignore[import-untyped]\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, HandleInput, MessageTextInput, MultilineInput, Output\nfrom langflow.schema import DataFrame\n\nif TYPE_CHECKING:\n    from langchain_core.runnables import Runnable\n\n\nclass BatchRunComponent(Component):\n    display_name = \"Batch Run\"\n    description = \"Runs an LLM over each row of a DataFrame's column. If no column is set, the entire row is passed.\"\n    icon = \"List\"\n    beta = True\n\n    inputs = [\n        HandleInput(\n            name=\"model\",\n            display_name=\"Language Model\",\n            info=\"Connect the 'Language Model' output from your LLM component here.\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n        ),\n        MultilineInput(\n            name=\"system_message\",\n            display_name=\"Instructions\",\n            info=\"Multi-line system instruction for all rows in the DataFrame.\",\n            required=False,\n        ),\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The DataFrame whose column (specified by 'column_name') we'll treat as text messages.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=(\n                \"The name of the DataFrame column to treat as text messages. \"\n                \"If empty, all columns will be formatted in TOML.\"\n            ),\n            required=False,\n            advanced=False,\n        ),\n        MessageTextInput(\n            name=\"output_column_name\",\n            display_name=\"Output Column Name\",\n            info=\"Name of the column where the model's response will be stored.\",\n            value=\"model_response\",\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"enable_metadata\",\n            display_name=\"Enable Metadata\",\n            info=\"If True, add metadata to the output DataFrame.\",\n            value=False,\n            required=False,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"batch_results\",\n            method=\"run_batch\",\n            info=\"A DataFrame with all original columns plus the model's response column.\",\n        ),\n    ]\n\n    def _format_row_as_toml(self, row: dict[str, Any]) -> str:\n        \"\"\"Convert a dictionary (row) into a TOML-formatted string.\"\"\"\n        formatted_dict = {str(col): {\"value\": str(val)} for col, val in row.items()}\n        return toml.dumps(formatted_dict)\n\n    def _create_base_row(\n        self, original_row: dict[str, Any], model_response: str = \"\", batch_index: int = -1\n    ) -> dict[str, Any]:\n        \"\"\"Create a base row with original columns and additional metadata.\"\"\"\n        row = original_row.copy()\n        row[self.output_column_name] = model_response\n        row[\"batch_index\"] = batch_index\n        return row\n\n    def _add_metadata(\n        self, row: dict[str, Any], *, success: bool = True, system_msg: str = \"\", error: str | None = None\n    ) -> None:\n        \"\"\"Add metadata to a row if enabled.\"\"\"\n        if not self.enable_metadata:\n            return\n\n        if success:\n            row[\"metadata\"] = {\n                \"has_system_message\": bool(system_msg),\n                \"input_length\": len(row.get(\"text_input\", \"\")),\n                \"response_length\": len(row[self.output_column_name]),\n                \"processing_status\": \"success\",\n            }\n        else:\n            row[\"metadata\"] = {\n                \"error\": error,\n                \"processing_status\": \"failed\",\n            }\n\n    async def run_batch(self) -> DataFrame:\n        \"\"\"Process each row in df[column_name] with the language model asynchronously.\n\n        Returns:\n            DataFrame: A new DataFrame containing:\n                - All original columns\n                - The model's response column (customizable name)\n                - 'batch_index' column for processing order\n                - 'metadata' (optional)\n\n        Raises:\n            ValueError: If the specified column is not found in the DataFrame\n            TypeError: If the model is not compatible or input types are wrong\n        \"\"\"\n        model: Runnable = self.model\n        system_msg = self.system_message or \"\"\n        df: DataFrame = self.df\n        col_name = self.column_name or \"\"\n\n        # Validate inputs first\n        if not isinstance(df, DataFrame):\n            msg = f\"Expected DataFrame input, got {type(df)}\"\n            raise TypeError(msg)\n\n        if col_name and col_name not in df.columns:\n            msg = f\"Column '{col_name}' not found in the DataFrame. Available columns: {', '.join(df.columns)}\"\n            raise ValueError(msg)\n\n        try:\n            # Determine text input for each row\n            if col_name:\n                user_texts = df[col_name].astype(str).tolist()\n            else:\n                user_texts = [\n                    self._format_row_as_toml(cast(dict[str, Any], row)) for row in df.to_dict(orient=\"records\")\n                ]\n\n            total_rows = len(user_texts)\n            logger.info(f\"Processing {total_rows} rows with batch run\")\n\n            # Prepare the batch of conversations\n            conversations = [\n                [{\"role\": \"system\", \"content\": system_msg}, {\"role\": \"user\", \"content\": text}]\n                if system_msg\n                else [{\"role\": \"user\", \"content\": text}]\n                for text in user_texts\n            ]\n\n            # Configure the model with project info and callbacks\n            model = model.with_config(\n                {\n                    \"run_name\": self.display_name,\n                    \"project_name\": self.get_project_name(),\n                    \"callbacks\": self.get_langchain_callbacks(),\n                }\n            )\n            # Process batches and track progress\n            responses_with_idx = list(\n                zip(\n                    range(len(conversations)),\n                    await model.abatch(list(conversations)),\n                    strict=True,\n                )\n            )\n\n            # Sort by index to maintain order\n            responses_with_idx.sort(key=lambda x: x[0])\n\n            # Build the final data with enhanced metadata\n            rows: list[dict[str, Any]] = []\n            for idx, (original_row, response) in enumerate(\n                zip(df.to_dict(orient=\"records\"), responses_with_idx, strict=False)\n            ):\n                response_text = response[1].content if hasattr(response[1], \"content\") else str(response[1])\n                row = self._create_base_row(\n                    cast(dict[str, Any], original_row), model_response=response_text, batch_index=idx\n                )\n                self._add_metadata(row, success=True, system_msg=system_msg)\n                rows.append(row)\n\n                # Log progress\n                if (idx + 1) % max(1, total_rows // 10) == 0:\n                    logger.info(f\"Processed {idx + 1}/{total_rows} rows\")\n\n            logger.info(\"Batch processing completed successfully\")\n            return DataFrame(rows)\n\n        except (KeyError, AttributeError) as e:\n            # Handle data structure and attribute access errors\n            logger.error(f\"Data processing error: {e!s}\")\n            error_row = self._create_base_row({col: \"\" for col in df.columns}, model_response=\"\", batch_index=-1)\n            self._add_metadata(error_row, success=False, error=str(e))\n            return DataFrame([error_row])\n"
              },
              "column_name": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Column Name",
                "dynamic": false,
                "info": "The name of the DataFrame column to treat as text messages. If empty, all columns will be formatted in TOML.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The DataFrame whose column (specified by 'column_name') we'll treat as text messages.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "enable_metadata": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Enable Metadata",
                "dynamic": false,
                "info": "If True, add metadata to the output DataFrame.",
                "list": false,
                "list_add_label": "Add More",
                "name": "enable_metadata",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "model": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Language Model",
                "dynamic": false,
                "info": "Connect the 'Language Model' output from your LLM component here.",
                "input_types": [
                  "LanguageModel"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "model",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "output_column_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Output Column Name",
                "dynamic": false,
                "info": "Name of the column where the model's response will be stored.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "output_column_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "model_response"
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Instructions",
                "dynamic": false,
                "info": "Multi-line system instruction for all rows in the DataFrame.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "BatchRunComponent"
        },
        "id": "BatchRunComponent-clb8n",
        "measured": {
          "height": 438,
          "width": 320
        },
        "position": {
          "x": 2626.2957511267673,
          "y": 687.4664747075776
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "DataToDataFrame-4Qo4s",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Converts one or multiple Data objects into a DataFrame. Each Data object corresponds to one row. Fields from `.data` become columns, and the `.text` (if present) is placed in a 'text' column.",
            "display_name": "Data → DataFrame",
            "documentation": "",
            "edited": false,
            "field_order": [
              "data_list"
            ],
            "frozen": false,
            "icon": "table",
            "key": "DataToDataFrame",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": false,
                "method": "build_dataframe",
                "name": "dataframe",
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.01857804455091699,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import DataInput, Output\nfrom langflow.schema import Data, DataFrame\n\n\nclass DataToDataFrameComponent(Component):\n    display_name = \"Data → DataFrame\"\n    description = (\n        \"Converts one or multiple Data objects into a DataFrame. \"\n        \"Each Data object corresponds to one row. Fields from `.data` become columns, \"\n        \"and the `.text` (if present) is placed in a 'text' column.\"\n    )\n    icon = \"table\"\n    name = \"DataToDataFrame\"\n\n    inputs = [\n        DataInput(\n            name=\"data_list\",\n            display_name=\"Data or Data List\",\n            info=\"One or multiple Data objects to transform into a DataFrame.\",\n            is_list=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"dataframe\",\n            method=\"build_dataframe\",\n            info=\"A DataFrame built from each Data object's fields plus a 'text' column.\",\n        ),\n    ]\n\n    def build_dataframe(self) -> DataFrame:\n        \"\"\"Builds a DataFrame from Data objects by combining their fields.\n\n        For each Data object:\n          - Merge item.data (dictionary) as columns\n          - If item.text is present, add 'text' column\n\n        Returns a DataFrame with one row per Data object.\n        \"\"\"\n        data_input = self.data_list\n\n        # If user passed a single Data, it might come in as a single object rather than a list\n        if not isinstance(data_input, list):\n            data_input = [data_input]\n\n        rows = []\n        for item in data_input:\n            if not isinstance(item, Data):\n                msg = f\"Expected Data objects, got {type(item)} instead.\"\n                raise TypeError(msg)\n\n            # Start with a copy of item.data or an empty dict\n            row_dict = dict(item.data) if item.data else {}\n\n            # If the Data object has text, store it under 'text' col\n            text_val = item.get_text()\n            if text_val:\n                row_dict[\"text\"] = text_val\n\n            rows.append(row_dict)\n\n        # Build a DataFrame from these row dictionaries\n        df_result = DataFrame(rows)\n        self.status = df_result  # store in self.status for logs\n        return df_result\n"
              },
              "data_list": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Data or Data List",
                "dynamic": false,
                "info": "One or multiple Data objects to transform into a DataFrame.",
                "input_types": [
                  "Data"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "data_list",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "DataToDataFrame"
        },
        "id": "DataToDataFrame-4Qo4s",
        "measured": {
          "height": 272,
          "width": 320
        },
        "position": {
          "x": 2136.161327640504,
          "y": 771.0354545303835
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt-BXFAW",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "question"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt",
            "documentation": "",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "prompts",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt Message",
                "hidden": false,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": null,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "question": {
                "advanced": false,
                "display_name": "question",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "question",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "You are a semantic search expansion agent. Your task is to take an original user question and one of its decomposed sub-questions, and generate **three diverse rephrasings** of the sub-question for use in semantic search.\n\nThese rephrasings should reflect **natural variations** in how the same idea might be expressed, improving the chance of retrieving relevant documents from a vector database by overcoming the limitations of lexical similarity.\n\nReturn your response strictly as a **JSON object** in the following format, and **do not include any explanations, comments, or additional text**:\n\n  \"search_queries\": [\n    \"First reformulated query here\",\n    \"Second reformulated query here\",\n    \"Third reformulated query here\"\n  ]\n\nOriginal Question: \n{question}  \n\nOnly return the JSON response."
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt"
        },
        "id": "Prompt-BXFAW",
        "measured": {
          "height": 411,
          "width": 320
        },
        "position": {
          "x": 1728.6785502597036,
          "y": 49.78956383093208
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GoogleGenerativeAIModel-bIzoE",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generate text using Google Generative AI.",
            "display_name": "Google Generative AI",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_output_tokens",
              "model_name",
              "api_key",
              "top_p",
              "temperature",
              "n",
              "top_k",
              "tool_model_enabled"
            ],
            "frozen": false,
            "icon": "GoogleGenerativeAI",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": null,
                "method": "text_response",
                "name": "text_output",
                "options": null,
                "required_inputs": [],
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "hidden": false,
                "method": "build_model",
                "name": "model_output",
                "options": null,
                "required_inputs": [
                  "api_key"
                ],
                "selected": "LanguageModel",
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Google API Key",
                "dynamic": false,
                "info": "The Google API Key to use for the Google Generative AI.",
                "input_types": [
                  "Message"
                ],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nimport requests\nfrom loguru import logger\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.google_generative_ai_constants import GOOGLE_GENERATIVE_AI_MODELS\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import DropdownInput, FloatInput, IntInput, SecretStrInput, SliderInput\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.schema import dotdict\n\n\nclass GoogleGenerativeAIComponent(LCModelComponent):\n    display_name = \"Google Generative AI\"\n    description = \"Generate text using Google Generative AI.\"\n    icon = \"GoogleGenerativeAI\"\n    name = \"GoogleGenerativeAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_output_tokens\", display_name=\"Max Output Tokens\", info=\"The maximum number of tokens to generate.\"\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model\",\n            info=\"The name of the model to use.\",\n            options=GOOGLE_GENERATIVE_AI_MODELS,\n            value=\"gemini-1.5-pro\",\n            refresh_button=True,\n            combobox=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Google API Key\",\n            info=\"The Google API Key to use for the Google Generative AI.\",\n            required=True,\n            real_time_refresh=True,\n        ),\n        FloatInput(\n            name=\"top_p\",\n            display_name=\"Top P\",\n            info=\"The maximum cumulative probability of tokens to consider when sampling.\",\n            advanced=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            range_spec=RangeSpec(min=0, max=2, step=0.01),\n            info=\"Controls randomness. Lower values are more deterministic, higher values are more creative.\",\n        ),\n        IntInput(\n            name=\"n\",\n            display_name=\"N\",\n            info=\"Number of chat completions to generate for each prompt. \"\n            \"Note that the API may not return the full n completions if duplicates are generated.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"top_k\",\n            display_name=\"Top K\",\n            info=\"Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"tool_model_enabled\",\n            display_name=\"Tool Model Enabled\",\n            info=\"Whether to use the tool model.\",\n            value=False,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        try:\n            from langchain_google_genai import ChatGoogleGenerativeAI\n        except ImportError as e:\n            msg = \"The 'langchain_google_genai' package is required to use the Google Generative AI model.\"\n            raise ImportError(msg) from e\n\n        google_api_key = self.api_key\n        model = self.model_name\n        max_output_tokens = self.max_output_tokens\n        temperature = self.temperature\n        top_k = self.top_k\n        top_p = self.top_p\n        n = self.n\n\n        return ChatGoogleGenerativeAI(\n            model=model,\n            max_output_tokens=max_output_tokens or None,\n            temperature=temperature,\n            top_k=top_k or None,\n            top_p=top_p or None,\n            n=n or 1,\n            google_api_key=SecretStr(google_api_key).get_secret_value(),\n        )\n\n    def get_models(self, tool_model_enabled: bool | None = None) -> list[str]:\n        try:\n            import google.generativeai as genai\n\n            genai.configure(api_key=self.api_key)\n            model_ids = [\n                model.name.replace(\"models/\", \"\")\n                for model in genai.list_models()\n                if \"generateContent\" in model.supported_generation_methods\n            ]\n            model_ids.sort(reverse=True)\n        except (ImportError, ValueError) as e:\n            logger.exception(f\"Error getting model names: {e}\")\n            model_ids = GOOGLE_GENERATIVE_AI_MODELS\n        if tool_model_enabled:\n            try:\n                from langchain_google_genai.chat_models import ChatGoogleGenerativeAI\n            except ImportError as e:\n                msg = \"langchain_google_genai is not installed.\"\n                raise ImportError(msg) from e\n            for model in model_ids:\n                model_with_tool = ChatGoogleGenerativeAI(\n                    model=self.model_name,\n                    google_api_key=self.api_key,\n                )\n                if not self.supports_tool_calling(model_with_tool):\n                    model_ids.remove(model)\n        return model_ids\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name in {\"base_url\", \"model_name\", \"tool_model_enabled\", \"api_key\"} and field_value:\n            try:\n                if len(self.api_key) == 0:\n                    ids = GOOGLE_GENERATIVE_AI_MODELS\n                else:\n                    try:\n                        ids = self.get_models(tool_model_enabled=self.tool_model_enabled)\n                    except (ImportError, ValueError, requests.exceptions.RequestException) as e:\n                        logger.exception(f\"Error getting model names: {e}\")\n                        ids = GOOGLE_GENERATIVE_AI_MODELS\n                build_config[\"model_name\"][\"options\"] = ids\n                build_config[\"model_name\"][\"value\"] = ids[0]\n            except Exception as e:\n                msg = f\"Error getting model names: {e}\"\n                raise ValueError(msg) from e\n        return build_config\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_output_tokens": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Max Output Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_output_tokens",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model",
                "dynamic": false,
                "info": "The name of the model to use.",
                "name": "model_name",
                "options": [
                  "learnlm-2.0-flash-experimental",
                  "learnlm-1.5-pro-experimental",
                  "gemma-3-4b-it",
                  "gemma-3-27b-it",
                  "gemma-3-1b-it",
                  "gemma-3-12b-it",
                  "gemini-pro-vision",
                  "gemini-exp-1206",
                  "gemini-2.5-pro-preview-03-25",
                  "gemini-2.5-pro-exp-03-25",
                  "gemini-2.5-flash-preview-04-17",
                  "gemini-2.0-pro-exp-02-05",
                  "gemini-2.0-pro-exp",
                  "gemini-2.0-flash-thinking-exp-1219",
                  "gemini-2.0-flash-thinking-exp-01-21",
                  "gemini-2.0-flash-thinking-exp",
                  "gemini-2.0-flash-lite-preview-02-05",
                  "gemini-2.0-flash-lite-preview",
                  "gemini-2.0-flash-lite-001",
                  "gemini-2.0-flash-lite",
                  "gemini-2.0-flash-exp-image-generation",
                  "gemini-2.0-flash-exp",
                  "gemini-2.0-flash-001",
                  "gemini-2.0-flash",
                  "gemini-1.5-pro-latest",
                  "gemini-1.5-pro-002",
                  "gemini-1.5-pro-001",
                  "gemini-1.5-pro",
                  "gemini-1.5-flash-latest",
                  "gemini-1.5-flash-8b-latest",
                  "gemini-1.5-flash-8b-exp-0924",
                  "gemini-1.5-flash-8b-exp-0827",
                  "gemini-1.5-flash-8b-001",
                  "gemini-1.5-flash-8b",
                  "gemini-1.5-flash-002",
                  "gemini-1.5-flash-001-tuning",
                  "gemini-1.5-flash-001",
                  "gemini-1.5-flash",
                  "gemini-1.0-pro-vision-latest"
                ],
                "options_metadata": [],
                "placeholder": "",
                "refresh_button": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "learnlm-2.0-flash-experimental"
              },
              "n": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "N",
                "dynamic": false,
                "info": "Number of chat completions to generate for each prompt. Note that the API may not return the full n completions if duplicates are generated.",
                "list": false,
                "list_add_label": "Add More",
                "name": "n",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "System message to pass to the model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are a semantic search expansion agent. Given an original question and a decomposed sub-question, generate three natural language variations of the sub-question to improve semantic search coverage.  \n\nRespond only with a JSON object in the following format, and include nothing else:\n\n```json\n{\n  \"search_queries\": [\n    \"First variation here\",\n    \"Second variation here\",\n    \"Third variation here\"\n  ]\n}\n```"
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Controls randomness. Lower values are more deterministic, higher values are more creative.",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 2,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              },
              "tool_model_enabled": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Tool Model Enabled",
                "dynamic": false,
                "info": "Whether to use the tool model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "tool_model_enabled",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "top_k": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Top K",
                "dynamic": false,
                "info": "Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_k",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "top_p": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Top P",
                "dynamic": false,
                "info": "The maximum cumulative probability of tokens to consider when sampling.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_p",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "GoogleGenerativeAIModel"
        },
        "id": "GoogleGenerativeAIModel-bIzoE",
        "measured": {
          "height": 652,
          "width": 320
        },
        "position": {
          "x": 2118.5401041424466,
          "y": 38
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "DataFrameOperationsComponent-smlgy",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Perform various operations on a DataFrame.",
            "display_name": "DataFrame Operations",
            "documentation": "",
            "edited": false,
            "field_order": [
              "df",
              "operation",
              "column_name",
              "filter_value",
              "ascending",
              "new_column_name",
              "new_column_value",
              "columns_to_select",
              "num_rows",
              "replace_value",
              "replacement_value"
            ],
            "frozen": false,
            "icon": "table",
            "key": "DataFrameOperationsComponent",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": false,
                "method": "perform_operation",
                "name": "output",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.007568328950209746,
            "template": {
              "_type": "Component",
              "ascending": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "column_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 3
              },
              "operation": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Tail"
              },
              "replace_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "DataFrameOperationsComponent"
        },
        "id": "DataFrameOperationsComponent-smlgy",
        "measured": {
          "height": 354,
          "width": 320
        },
        "position": {
          "x": 3024.605718445465,
          "y": 1178.983820095764
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "DataFrameOperationsComponent-k61oZ",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Perform various operations on a DataFrame.",
            "display_name": "DataFrame Operations",
            "documentation": "",
            "edited": false,
            "field_order": [
              "df",
              "operation",
              "column_name",
              "filter_value",
              "ascending",
              "new_column_name",
              "new_column_value",
              "columns_to_select",
              "num_rows",
              "replace_value",
              "replacement_value"
            ],
            "frozen": false,
            "icon": "table",
            "key": "DataFrameOperationsComponent",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": false,
                "method": "perform_operation",
                "name": "output",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.007568328950209746,
            "template": {
              "_type": "Component",
              "ascending": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "column_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 2
              },
              "operation": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Tail"
              },
              "replace_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "DataFrameOperationsComponent"
        },
        "id": "DataFrameOperationsComponent-k61oZ",
        "measured": {
          "height": 354,
          "width": 320
        },
        "position": {
          "x": 3482.9639570657982,
          "y": 1516.9894937896895
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GroupNode-d6vys",
          "node": {
            "description": "",
            "display_name": "4",
            "documentation": "",
            "flow": {
              "data": {
                "edges": [
                  {
                    "animated": false,
                    "data": {
                      "sourceHandle": {
                        "dataType": "DataFrameOperationsComponent",
                        "id": "DataFrameOperationsComponent-tKi19",
                        "name": "output",
                        "output_types": [
                          "DataFrame"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "input_data",
                        "id": "ParserComponent-wxrA0",
                        "inputTypes": [
                          "DataFrame",
                          "Data"
                        ],
                        "type": "other"
                      }
                    },
                    "id": "reactflow__edge-DataFrameOperationsComponent-tKi19{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-tKi19œ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-wxrA0{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-wxrA0œ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
                    "selected": false,
                    "source": "DataFrameOperationsComponent-tKi19",
                    "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-tKi19œ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
                    "target": "ParserComponent-wxrA0",
                    "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-wxrA0œ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
                  }
                ],
                "nodes": [
                  {
                    "data": {
                      "id": "DataFrameOperationsComponent-tKi19",
                      "node": {
                        "base_classes": [
                          "DataFrame"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Perform various operations on a DataFrame.",
                        "display_name": "DataFrame Operations",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "df",
                          "operation",
                          "column_name",
                          "filter_value",
                          "ascending",
                          "new_column_name",
                          "new_column_value",
                          "columns_to_select",
                          "num_rows",
                          "replace_value",
                          "replacement_value"
                        ],
                        "frozen": false,
                        "icon": "table",
                        "key": "DataFrameOperationsComponent",
                        "legacy": false,
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "DataFrame",
                            "hidden": false,
                            "method": "perform_operation",
                            "name": "output",
                            "options": null,
                            "required_inputs": null,
                            "selected": "DataFrame",
                            "tool_mode": true,
                            "types": [
                              "DataFrame"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.007568328950209746,
                        "template": {
                          "_type": "Component",
                          "ascending": {
                            "_input_type": "BoolInput",
                            "advanced": false,
                            "display_name": "Sort Ascending",
                            "dynamic": true,
                            "info": "Whether to sort in ascending order.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "ascending",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "code": {
                            "advanced": true,
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
                          },
                          "column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Column Name",
                            "dynamic": true,
                            "info": "The column name to use for the operation.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "columns_to_select": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Columns to Select",
                            "dynamic": true,
                            "info": "",
                            "list": true,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "columns_to_select",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "df": {
                            "_input_type": "DataFrameInput",
                            "advanced": false,
                            "display_name": "DataFrame",
                            "dynamic": false,
                            "info": "The input DataFrame to operate on.",
                            "input_types": [
                              "DataFrame"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "df",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "filter_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Filter Value",
                            "dynamic": true,
                            "info": "The value to filter rows by.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "filter_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "new_column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "New Column Name",
                            "dynamic": true,
                            "info": "The new column name when renaming or adding a column.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "new_column_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "New Column Value",
                            "dynamic": true,
                            "info": "The value to populate the new column with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "num_rows": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Number of Rows",
                            "dynamic": true,
                            "info": "Number of rows to return (for head/tail).",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "num_rows",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "operation": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Operation",
                            "dynamic": false,
                            "info": "Select the DataFrame operation to perform.",
                            "name": "operation",
                            "options": [
                              "Add Column",
                              "Drop Column",
                              "Filter",
                              "Head",
                              "Rename Column",
                              "Replace Value",
                              "Select Columns",
                              "Sort",
                              "Tail"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Tail"
                          },
                          "replace_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Value to Replace",
                            "dynamic": true,
                            "info": "The value to replace in the column.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replace_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "replacement_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Replacement Value",
                            "dynamic": true,
                            "info": "The value to replace with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replacement_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "DataFrameOperationsComponent"
                    },
                    "dragging": false,
                    "id": "DataFrameOperationsComponent-tKi19",
                    "measured": {
                      "height": 356,
                      "width": 320
                    },
                    "position": {
                      "x": 3066.178645484783,
                      "y": 2430.647414226707
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "ParserComponent-wxrA0",
                      "node": {
                        "base_classes": [
                          "Message"
                        ],
                        "beta": false,
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Format a DataFrame or Data object into text using a template. Enable 'Stringify' to convert input into a readable string instead.",
                        "display_name": "Parser",
                        "documentation": "",
                        "edited": true,
                        "field_order": [
                          "mode",
                          "pattern",
                          "input_data",
                          "sep"
                        ],
                        "frozen": false,
                        "icon": "braces",
                        "legacy": false,
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Text4",
                            "hidden": null,
                            "method": "parse_combined_text",
                            "name": "parsed_text",
                            "options": null,
                            "required_inputs": null,
                            "selected": "Message",
                            "tool_mode": true,
                            "types": [
                              "Message"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Text4\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
                          },
                          "input_data": {
                            "_input_type": "HandleInput",
                            "advanced": false,
                            "display_name": "Data or DataFrame",
                            "dynamic": false,
                            "info": "Accepts either a DataFrame or a Data object.",
                            "input_types": [
                              "DataFrame",
                              "Data"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "input_data",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "mode": {
                            "_input_type": "TabInput",
                            "advanced": false,
                            "display_name": "Mode",
                            "dynamic": false,
                            "info": "Convert into raw string instead of using a template.",
                            "name": "mode",
                            "options": [
                              "Parser",
                              "Stringify"
                            ],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "tab",
                            "value": "Parser"
                          },
                          "pattern": {
                            "_input_type": "MultilineInput",
                            "advanced": false,
                            "copy_field": false,
                            "display_name": "Template",
                            "dynamic": true,
                            "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "multiline": true,
                            "name": "pattern",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "{model_response}"
                          },
                          "sep": {
                            "_input_type": "MessageTextInput",
                            "advanced": true,
                            "display_name": "Separator",
                            "dynamic": false,
                            "info": "String used to separate rows/items.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "sep",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "\n"
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "ParserComponent"
                    },
                    "dragging": false,
                    "id": "ParserComponent-wxrA0",
                    "measured": {
                      "height": 394,
                      "width": 320
                    },
                    "position": {
                      "x": 3526.4643506153243,
                      "y": 2451.103417092635
                    },
                    "selected": true,
                    "type": "genericNode"
                  }
                ],
                "viewport": {
                  "x": 0,
                  "y": 0,
                  "zoom": 1
                }
              },
              "description": "",
              "id": "eiSk7",
              "is_component": false,
              "name": "Agitated Shirley"
            },
            "lf_version": "1.3.4",
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Text4",
                "hidden": false,
                "method": "parse_combined_text",
                "name": "ParserComponent-lEXku_parsed_text",
                "options": null,
                "proxy": {
                  "id": "ParserComponent-wxrA0",
                  "name": "parsed_text",
                  "nodeDisplayName": "Parser"
                },
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "template": {
              "ascending_DataFrameOperationsComponent-kXK4V": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "proxy": {
                  "field": "ascending",
                  "id": "DataFrameOperationsComponent-tKi19"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code_DataFrameOperationsComponent-kXK4V": {
                "advanced": true,
                "display_name": "Code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "DataFrameOperationsComponent-tKi19"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "code_ParserComponent-lEXku": {
                "advanced": true,
                "display_name": "Code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "ParserComponent-wxrA0"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Text4\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "column_name_DataFrameOperationsComponent-kXK4V": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "proxy": {
                  "field": "column_name",
                  "id": "DataFrameOperationsComponent-tKi19"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select_DataFrameOperationsComponent-kXK4V": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "proxy": {
                  "field": "columns_to_select",
                  "id": "DataFrameOperationsComponent-tKi19"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df_DataFrameOperationsComponent-kXK4V": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "proxy": {
                  "field": "df",
                  "id": "DataFrameOperationsComponent-tKi19"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value_DataFrameOperationsComponent-kXK4V": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "proxy": {
                  "field": "filter_value",
                  "id": "DataFrameOperationsComponent-tKi19"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "mode_ParserComponent-lEXku": {
                "_input_type": "TabInput",
                "advanced": true,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "proxy": {
                  "field": "mode",
                  "id": "ParserComponent-wxrA0"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "new_column_name_DataFrameOperationsComponent-kXK4V": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_name",
                  "id": "DataFrameOperationsComponent-tKi19"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value_DataFrameOperationsComponent-kXK4V": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_value",
                  "id": "DataFrameOperationsComponent-tKi19"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows_DataFrameOperationsComponent-kXK4V": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "proxy": {
                  "field": "num_rows",
                  "id": "DataFrameOperationsComponent-tKi19"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "operation_DataFrameOperationsComponent-kXK4V": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "operation",
                  "id": "DataFrameOperationsComponent-tKi19"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Tail"
              },
              "pattern_ParserComponent-lEXku": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "proxy": {
                  "field": "pattern",
                  "id": "ParserComponent-wxrA0"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{model_response}"
              },
              "replace_value_DataFrameOperationsComponent-kXK4V": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "proxy": {
                  "field": "replace_value",
                  "id": "DataFrameOperationsComponent-tKi19"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value_DataFrameOperationsComponent-kXK4V": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "proxy": {
                  "field": "replacement_value",
                  "id": "DataFrameOperationsComponent-tKi19"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sep_ParserComponent-lEXku": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "proxy": {
                  "field": "sep",
                  "id": "ParserComponent-wxrA0"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            }
          },
          "type": "GroupNode"
        },
        "id": "GroupNode-d6vys",
        "measured": {
          "height": 159,
          "width": 320
        },
        "position": {
          "x": 3707.729861510865,
          "y": 2117.184819566174
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GroupNode-k8FUm",
          "node": {
            "description": "",
            "display_name": "3",
            "documentation": "",
            "flow": {
              "data": {
                "edges": [
                  {
                    "animated": false,
                    "data": {
                      "sourceHandle": {
                        "dataType": "DataFrameOperationsComponent",
                        "id": "DataFrameOperationsComponent-5DYFO",
                        "name": "output",
                        "output_types": [
                          "DataFrame"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "input_data",
                        "id": "ParserComponent-x5vpL",
                        "inputTypes": [
                          "DataFrame",
                          "Data"
                        ],
                        "type": "other"
                      }
                    },
                    "id": "reactflow__edge-DataFrameOperationsComponent-5DYFO{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-5DYFOœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-x5vpL{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-x5vpLœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
                    "selected": false,
                    "source": "DataFrameOperationsComponent-5DYFO",
                    "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-5DYFOœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
                    "target": "ParserComponent-x5vpL",
                    "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-x5vpLœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
                  }
                ],
                "nodes": [
                  {
                    "data": {
                      "id": "DataFrameOperationsComponent-5DYFO",
                      "node": {
                        "base_classes": [
                          "DataFrame"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Perform various operations on a DataFrame.",
                        "display_name": "DataFrame Operations",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "df",
                          "operation",
                          "column_name",
                          "filter_value",
                          "ascending",
                          "new_column_name",
                          "new_column_value",
                          "columns_to_select",
                          "num_rows",
                          "replace_value",
                          "replacement_value"
                        ],
                        "frozen": false,
                        "icon": "table",
                        "key": "DataFrameOperationsComponent",
                        "legacy": false,
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "DataFrame",
                            "hidden": false,
                            "method": "perform_operation",
                            "name": "output",
                            "options": null,
                            "required_inputs": null,
                            "selected": "DataFrame",
                            "tool_mode": true,
                            "types": [
                              "DataFrame"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.007568328950209746,
                        "template": {
                          "_type": "Component",
                          "ascending": {
                            "_input_type": "BoolInput",
                            "advanced": false,
                            "display_name": "Sort Ascending",
                            "dynamic": true,
                            "info": "Whether to sort in ascending order.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "ascending",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "code": {
                            "advanced": true,
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
                          },
                          "column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Column Name",
                            "dynamic": true,
                            "info": "The column name to use for the operation.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "columns_to_select": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Columns to Select",
                            "dynamic": true,
                            "info": "",
                            "list": true,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "columns_to_select",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "df": {
                            "_input_type": "DataFrameInput",
                            "advanced": false,
                            "display_name": "DataFrame",
                            "dynamic": false,
                            "info": "The input DataFrame to operate on.",
                            "input_types": [
                              "DataFrame"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "df",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "filter_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Filter Value",
                            "dynamic": true,
                            "info": "The value to filter rows by.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "filter_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "new_column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "New Column Name",
                            "dynamic": true,
                            "info": "The new column name when renaming or adding a column.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "new_column_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "New Column Value",
                            "dynamic": true,
                            "info": "The value to populate the new column with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "num_rows": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Number of Rows",
                            "dynamic": true,
                            "info": "Number of rows to return (for head/tail).",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "num_rows",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "operation": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Operation",
                            "dynamic": false,
                            "info": "Select the DataFrame operation to perform.",
                            "name": "operation",
                            "options": [
                              "Add Column",
                              "Drop Column",
                              "Filter",
                              "Head",
                              "Rename Column",
                              "Replace Value",
                              "Select Columns",
                              "Sort",
                              "Tail"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Head"
                          },
                          "replace_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Value to Replace",
                            "dynamic": true,
                            "info": "The value to replace in the column.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replace_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "replacement_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Replacement Value",
                            "dynamic": true,
                            "info": "The value to replace with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replacement_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "DataFrameOperationsComponent"
                    },
                    "dragging": false,
                    "id": "DataFrameOperationsComponent-5DYFO",
                    "measured": {
                      "height": 356,
                      "width": 320
                    },
                    "position": {
                      "x": 3052.288885496562,
                      "y": 1904.8207861011706
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "ParserComponent-x5vpL",
                      "node": {
                        "base_classes": [
                          "Message"
                        ],
                        "beta": false,
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Format a DataFrame or Data object into text using a template. Enable 'Stringify' to convert input into a readable string instead.",
                        "display_name": "Parser",
                        "documentation": "",
                        "edited": true,
                        "field_order": [
                          "mode",
                          "pattern",
                          "input_data",
                          "sep"
                        ],
                        "frozen": false,
                        "icon": "braces",
                        "legacy": false,
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Text3",
                            "hidden": null,
                            "method": "parse_combined_text",
                            "name": "parsed_text",
                            "options": null,
                            "required_inputs": null,
                            "selected": "Message",
                            "tool_mode": true,
                            "types": [
                              "Message"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Text3\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
                          },
                          "input_data": {
                            "_input_type": "HandleInput",
                            "advanced": false,
                            "display_name": "Data or DataFrame",
                            "dynamic": false,
                            "info": "Accepts either a DataFrame or a Data object.",
                            "input_types": [
                              "DataFrame",
                              "Data"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "input_data",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "mode": {
                            "_input_type": "TabInput",
                            "advanced": false,
                            "display_name": "Mode",
                            "dynamic": false,
                            "info": "Convert into raw string instead of using a template.",
                            "name": "mode",
                            "options": [
                              "Parser",
                              "Stringify"
                            ],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "tab",
                            "value": "Parser"
                          },
                          "pattern": {
                            "_input_type": "MultilineInput",
                            "advanced": false,
                            "copy_field": false,
                            "display_name": "Template",
                            "dynamic": true,
                            "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "multiline": true,
                            "name": "pattern",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "{model_response}"
                          },
                          "sep": {
                            "_input_type": "MessageTextInput",
                            "advanced": true,
                            "display_name": "Separator",
                            "dynamic": false,
                            "info": "String used to separate rows/items.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "sep",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "\n"
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "ParserComponent"
                    },
                    "dragging": false,
                    "id": "ParserComponent-x5vpL",
                    "measured": {
                      "height": 394,
                      "width": 320
                    },
                    "position": {
                      "x": 3526.4643506153247,
                      "y": 1818.1272119151024
                    },
                    "selected": true,
                    "type": "genericNode"
                  }
                ],
                "viewport": {
                  "x": 0,
                  "y": 0,
                  "zoom": 1
                }
              },
              "description": "",
              "id": "nyg1v",
              "is_component": false,
              "name": "Delighted Dubinsky"
            },
            "lf_version": "1.3.4",
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Text3",
                "hidden": false,
                "method": "parse_combined_text",
                "name": "ParserComponent-rFJn1_parsed_text",
                "options": null,
                "proxy": {
                  "id": "ParserComponent-x5vpL",
                  "name": "parsed_text",
                  "nodeDisplayName": "Parser"
                },
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "template": {
              "ascending_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "proxy": {
                  "field": "ascending",
                  "id": "DataFrameOperationsComponent-5DYFO"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code_DataFrameOperationsComponent-rvJsS": {
                "advanced": true,
                "display_name": "Code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "DataFrameOperationsComponent-5DYFO"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "code_ParserComponent-rFJn1": {
                "advanced": true,
                "display_name": "Code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "ParserComponent-x5vpL"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Text3\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "column_name_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "proxy": {
                  "field": "column_name",
                  "id": "DataFrameOperationsComponent-5DYFO"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "proxy": {
                  "field": "columns_to_select",
                  "id": "DataFrameOperationsComponent-5DYFO"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "proxy": {
                  "field": "df",
                  "id": "DataFrameOperationsComponent-5DYFO"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "proxy": {
                  "field": "filter_value",
                  "id": "DataFrameOperationsComponent-5DYFO"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "mode_ParserComponent-rFJn1": {
                "_input_type": "TabInput",
                "advanced": true,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "proxy": {
                  "field": "mode",
                  "id": "ParserComponent-x5vpL"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "new_column_name_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_name",
                  "id": "DataFrameOperationsComponent-5DYFO"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_value",
                  "id": "DataFrameOperationsComponent-5DYFO"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "proxy": {
                  "field": "num_rows",
                  "id": "DataFrameOperationsComponent-5DYFO"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "operation_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "operation",
                  "id": "DataFrameOperationsComponent-5DYFO"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Head"
              },
              "pattern_ParserComponent-rFJn1": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "proxy": {
                  "field": "pattern",
                  "id": "ParserComponent-x5vpL"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{model_response}"
              },
              "replace_value_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "proxy": {
                  "field": "replace_value",
                  "id": "DataFrameOperationsComponent-5DYFO"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "proxy": {
                  "field": "replacement_value",
                  "id": "DataFrameOperationsComponent-5DYFO"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sep_ParserComponent-rFJn1": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "proxy": {
                  "field": "sep",
                  "id": "ParserComponent-x5vpL"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            }
          },
          "type": "GroupNode"
        },
        "id": "GroupNode-k8FUm",
        "measured": {
          "height": 159,
          "width": 320
        },
        "position": {
          "x": 3955.352541000816,
          "y": 1754.1407184614425
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GroupNode-6LXK0",
          "node": {
            "description": "",
            "display_name": "2",
            "documentation": "",
            "flow": {
              "data": {
                "edges": [
                  {
                    "animated": false,
                    "data": {
                      "sourceHandle": {
                        "dataType": "DataFrameOperationsComponent",
                        "id": "DataFrameOperationsComponent-fnitl",
                        "name": "output",
                        "output_types": [
                          "DataFrame"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "input_data",
                        "id": "ParserComponent-4LsRX",
                        "inputTypes": [
                          "DataFrame",
                          "Data"
                        ],
                        "type": "other"
                      }
                    },
                    "id": "reactflow__edge-DataFrameOperationsComponent-fnitl{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-fnitlœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-4LsRX{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-4LsRXœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
                    "selected": false,
                    "source": "DataFrameOperationsComponent-fnitl",
                    "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-fnitlœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
                    "target": "ParserComponent-4LsRX",
                    "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-4LsRXœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
                  }
                ],
                "nodes": [
                  {
                    "data": {
                      "id": "DataFrameOperationsComponent-fnitl",
                      "node": {
                        "base_classes": [
                          "DataFrame"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Perform various operations on a DataFrame.",
                        "display_name": "DataFrame Operations",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "df",
                          "operation",
                          "column_name",
                          "filter_value",
                          "ascending",
                          "new_column_name",
                          "new_column_value",
                          "columns_to_select",
                          "num_rows",
                          "replace_value",
                          "replacement_value"
                        ],
                        "frozen": false,
                        "icon": "table",
                        "key": "DataFrameOperationsComponent",
                        "legacy": false,
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "DataFrame",
                            "hidden": false,
                            "method": "perform_operation",
                            "name": "output",
                            "options": null,
                            "required_inputs": null,
                            "selected": "DataFrame",
                            "tool_mode": true,
                            "types": [
                              "DataFrame"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.007568328950209746,
                        "template": {
                          "_type": "Component",
                          "ascending": {
                            "_input_type": "BoolInput",
                            "advanced": false,
                            "display_name": "Sort Ascending",
                            "dynamic": true,
                            "info": "Whether to sort in ascending order.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "ascending",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "code": {
                            "advanced": true,
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
                          },
                          "column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Column Name",
                            "dynamic": true,
                            "info": "The column name to use for the operation.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "columns_to_select": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Columns to Select",
                            "dynamic": true,
                            "info": "",
                            "list": true,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "columns_to_select",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "df": {
                            "_input_type": "DataFrameInput",
                            "advanced": false,
                            "display_name": "DataFrame",
                            "dynamic": false,
                            "info": "The input DataFrame to operate on.",
                            "input_types": [
                              "DataFrame"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "df",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "filter_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Filter Value",
                            "dynamic": true,
                            "info": "The value to filter rows by.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "filter_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "new_column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "New Column Name",
                            "dynamic": true,
                            "info": "The new column name when renaming or adding a column.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "new_column_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "New Column Value",
                            "dynamic": true,
                            "info": "The value to populate the new column with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "num_rows": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Number of Rows",
                            "dynamic": true,
                            "info": "Number of rows to return (for head/tail).",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "num_rows",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "operation": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Operation",
                            "dynamic": false,
                            "info": "Select the DataFrame operation to perform.",
                            "name": "operation",
                            "options": [
                              "Add Column",
                              "Drop Column",
                              "Filter",
                              "Head",
                              "Rename Column",
                              "Replace Value",
                              "Select Columns",
                              "Sort",
                              "Tail"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Head"
                          },
                          "replace_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Value to Replace",
                            "dynamic": true,
                            "info": "The value to replace in the column.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replace_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "replacement_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Replacement Value",
                            "dynamic": true,
                            "info": "The value to replace with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replacement_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "DataFrameOperationsComponent"
                    },
                    "dragging": false,
                    "id": "DataFrameOperationsComponent-fnitl",
                    "measured": {
                      "height": 356,
                      "width": 320
                    },
                    "position": {
                      "x": 3052.288885496562,
                      "y": 1904.8207861011706
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "ParserComponent-4LsRX",
                      "node": {
                        "base_classes": [
                          "Message"
                        ],
                        "beta": false,
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Format a DataFrame or Data object into text using a template. Enable 'Stringify' to convert input into a readable string instead.",
                        "display_name": "Parser",
                        "documentation": "",
                        "edited": true,
                        "field_order": [
                          "mode",
                          "pattern",
                          "input_data",
                          "sep"
                        ],
                        "frozen": false,
                        "icon": "braces",
                        "legacy": false,
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Text3",
                            "hidden": null,
                            "method": "parse_combined_text",
                            "name": "parsed_text",
                            "options": null,
                            "required_inputs": null,
                            "selected": "Message",
                            "tool_mode": true,
                            "types": [
                              "Message"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Text3\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
                          },
                          "input_data": {
                            "_input_type": "HandleInput",
                            "advanced": false,
                            "display_name": "Data or DataFrame",
                            "dynamic": false,
                            "info": "Accepts either a DataFrame or a Data object.",
                            "input_types": [
                              "DataFrame",
                              "Data"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "input_data",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "mode": {
                            "_input_type": "TabInput",
                            "advanced": false,
                            "display_name": "Mode",
                            "dynamic": false,
                            "info": "Convert into raw string instead of using a template.",
                            "name": "mode",
                            "options": [
                              "Parser",
                              "Stringify"
                            ],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "tab",
                            "value": "Parser"
                          },
                          "pattern": {
                            "_input_type": "MultilineInput",
                            "advanced": false,
                            "copy_field": false,
                            "display_name": "Template",
                            "dynamic": true,
                            "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "multiline": true,
                            "name": "pattern",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "{model_response}"
                          },
                          "sep": {
                            "_input_type": "MessageTextInput",
                            "advanced": true,
                            "display_name": "Separator",
                            "dynamic": false,
                            "info": "String used to separate rows/items.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "sep",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "\n"
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "ParserComponent"
                    },
                    "dragging": false,
                    "id": "ParserComponent-4LsRX",
                    "measured": {
                      "height": 394,
                      "width": 320
                    },
                    "position": {
                      "x": 3526.4643506153247,
                      "y": 1818.1272119151024
                    },
                    "selected": true,
                    "type": "genericNode"
                  }
                ],
                "viewport": {
                  "x": 0,
                  "y": 0,
                  "zoom": 1
                }
              },
              "description": "",
              "id": "nyg1v",
              "is_component": false,
              "name": "Delighted Dubinsky"
            },
            "lf_version": "1.3.4",
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Text3",
                "hidden": false,
                "method": "parse_combined_text",
                "name": "ParserComponent-rFJn1_parsed_text",
                "options": null,
                "proxy": {
                  "id": "ParserComponent-4LsRX",
                  "name": "parsed_text",
                  "nodeDisplayName": "Parser"
                },
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "template": {
              "ascending_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "proxy": {
                  "field": "ascending",
                  "id": "DataFrameOperationsComponent-fnitl"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code_DataFrameOperationsComponent-rvJsS": {
                "advanced": true,
                "display_name": "Code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "DataFrameOperationsComponent-fnitl"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "code_ParserComponent-rFJn1": {
                "advanced": true,
                "display_name": "Code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "ParserComponent-4LsRX"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Text3\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "column_name_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "proxy": {
                  "field": "column_name",
                  "id": "DataFrameOperationsComponent-fnitl"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "proxy": {
                  "field": "columns_to_select",
                  "id": "DataFrameOperationsComponent-fnitl"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "proxy": {
                  "field": "df",
                  "id": "DataFrameOperationsComponent-fnitl"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "proxy": {
                  "field": "filter_value",
                  "id": "DataFrameOperationsComponent-fnitl"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "mode_ParserComponent-rFJn1": {
                "_input_type": "TabInput",
                "advanced": true,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "proxy": {
                  "field": "mode",
                  "id": "ParserComponent-4LsRX"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "new_column_name_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_name",
                  "id": "DataFrameOperationsComponent-fnitl"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_value",
                  "id": "DataFrameOperationsComponent-fnitl"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "proxy": {
                  "field": "num_rows",
                  "id": "DataFrameOperationsComponent-fnitl"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "operation_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "operation",
                  "id": "DataFrameOperationsComponent-fnitl"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Head"
              },
              "pattern_ParserComponent-rFJn1": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "proxy": {
                  "field": "pattern",
                  "id": "ParserComponent-4LsRX"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{model_response}"
              },
              "replace_value_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "proxy": {
                  "field": "replace_value",
                  "id": "DataFrameOperationsComponent-fnitl"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "proxy": {
                  "field": "replacement_value",
                  "id": "DataFrameOperationsComponent-fnitl"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sep_ParserComponent-rFJn1": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "proxy": {
                  "field": "sep",
                  "id": "ParserComponent-4LsRX"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            }
          },
          "type": "GroupNode"
        },
        "id": "GroupNode-6LXK0",
        "measured": {
          "height": 159,
          "width": 320
        },
        "position": {
          "x": 3519.382551806185,
          "y": 1157.7761488726403
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GroupNode-mCw5i",
          "node": {
            "description": "",
            "display_name": "1",
            "documentation": "",
            "flow": {
              "data": {
                "edges": [
                  {
                    "animated": false,
                    "data": {
                      "sourceHandle": {
                        "dataType": "DataFrameOperationsComponent",
                        "id": "DataFrameOperationsComponent-2Jqrw",
                        "name": "output",
                        "output_types": [
                          "DataFrame"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "input_data",
                        "id": "ParserComponent-tvNzY",
                        "inputTypes": [
                          "DataFrame",
                          "Data"
                        ],
                        "type": "other"
                      }
                    },
                    "id": "reactflow__edge-DataFrameOperationsComponent-2Jqrw{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-2Jqrwœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-tvNzY{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-tvNzYœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
                    "selected": false,
                    "source": "DataFrameOperationsComponent-2Jqrw",
                    "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-2Jqrwœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
                    "target": "ParserComponent-tvNzY",
                    "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-tvNzYœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
                  }
                ],
                "nodes": [
                  {
                    "data": {
                      "id": "DataFrameOperationsComponent-2Jqrw",
                      "node": {
                        "base_classes": [
                          "DataFrame"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Perform various operations on a DataFrame.",
                        "display_name": "DataFrame Operations",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "df",
                          "operation",
                          "column_name",
                          "filter_value",
                          "ascending",
                          "new_column_name",
                          "new_column_value",
                          "columns_to_select",
                          "num_rows",
                          "replace_value",
                          "replacement_value"
                        ],
                        "frozen": false,
                        "icon": "table",
                        "key": "DataFrameOperationsComponent",
                        "legacy": false,
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "DataFrame",
                            "hidden": false,
                            "method": "perform_operation",
                            "name": "output",
                            "options": null,
                            "required_inputs": null,
                            "selected": "DataFrame",
                            "tool_mode": true,
                            "types": [
                              "DataFrame"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.007568328950209746,
                        "template": {
                          "_type": "Component",
                          "ascending": {
                            "_input_type": "BoolInput",
                            "advanced": false,
                            "display_name": "Sort Ascending",
                            "dynamic": true,
                            "info": "Whether to sort in ascending order.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "ascending",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "code": {
                            "advanced": true,
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
                          },
                          "column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Column Name",
                            "dynamic": true,
                            "info": "The column name to use for the operation.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "columns_to_select": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Columns to Select",
                            "dynamic": true,
                            "info": "",
                            "list": true,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "columns_to_select",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "df": {
                            "_input_type": "DataFrameInput",
                            "advanced": false,
                            "display_name": "DataFrame",
                            "dynamic": false,
                            "info": "The input DataFrame to operate on.",
                            "input_types": [
                              "DataFrame"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "df",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "filter_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Filter Value",
                            "dynamic": true,
                            "info": "The value to filter rows by.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "filter_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "new_column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "New Column Name",
                            "dynamic": true,
                            "info": "The new column name when renaming or adding a column.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "new_column_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "New Column Value",
                            "dynamic": true,
                            "info": "The value to populate the new column with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "num_rows": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Number of Rows",
                            "dynamic": true,
                            "info": "Number of rows to return (for head/tail).",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "num_rows",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "operation": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Operation",
                            "dynamic": false,
                            "info": "Select the DataFrame operation to perform.",
                            "name": "operation",
                            "options": [
                              "Add Column",
                              "Drop Column",
                              "Filter",
                              "Head",
                              "Rename Column",
                              "Replace Value",
                              "Select Columns",
                              "Sort",
                              "Tail"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Head"
                          },
                          "replace_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Value to Replace",
                            "dynamic": true,
                            "info": "The value to replace in the column.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replace_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "replacement_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Replacement Value",
                            "dynamic": true,
                            "info": "The value to replace with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replacement_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "DataFrameOperationsComponent"
                    },
                    "dragging": false,
                    "id": "DataFrameOperationsComponent-2Jqrw",
                    "measured": {
                      "height": 356,
                      "width": 320
                    },
                    "position": {
                      "x": 3052.288885496562,
                      "y": 1904.8207861011706
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "ParserComponent-tvNzY",
                      "node": {
                        "base_classes": [
                          "Message"
                        ],
                        "beta": false,
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Format a DataFrame or Data object into text using a template. Enable 'Stringify' to convert input into a readable string instead.",
                        "display_name": "Parser",
                        "documentation": "",
                        "edited": true,
                        "field_order": [
                          "mode",
                          "pattern",
                          "input_data",
                          "sep"
                        ],
                        "frozen": false,
                        "icon": "braces",
                        "legacy": false,
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Text3",
                            "hidden": null,
                            "method": "parse_combined_text",
                            "name": "parsed_text",
                            "options": null,
                            "required_inputs": null,
                            "selected": "Message",
                            "tool_mode": true,
                            "types": [
                              "Message"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Text3\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
                          },
                          "input_data": {
                            "_input_type": "HandleInput",
                            "advanced": false,
                            "display_name": "Data or DataFrame",
                            "dynamic": false,
                            "info": "Accepts either a DataFrame or a Data object.",
                            "input_types": [
                              "DataFrame",
                              "Data"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "input_data",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "mode": {
                            "_input_type": "TabInput",
                            "advanced": false,
                            "display_name": "Mode",
                            "dynamic": false,
                            "info": "Convert into raw string instead of using a template.",
                            "name": "mode",
                            "options": [
                              "Parser",
                              "Stringify"
                            ],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "tab",
                            "value": "Parser"
                          },
                          "pattern": {
                            "_input_type": "MultilineInput",
                            "advanced": false,
                            "copy_field": false,
                            "display_name": "Template",
                            "dynamic": true,
                            "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "multiline": true,
                            "name": "pattern",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "{model_response}"
                          },
                          "sep": {
                            "_input_type": "MessageTextInput",
                            "advanced": true,
                            "display_name": "Separator",
                            "dynamic": false,
                            "info": "String used to separate rows/items.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "sep",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "\n"
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "ParserComponent"
                    },
                    "dragging": false,
                    "id": "ParserComponent-tvNzY",
                    "measured": {
                      "height": 394,
                      "width": 320
                    },
                    "position": {
                      "x": 3526.4643506153247,
                      "y": 1818.1272119151024
                    },
                    "selected": true,
                    "type": "genericNode"
                  }
                ],
                "viewport": {
                  "x": 0,
                  "y": 0,
                  "zoom": 1
                }
              },
              "description": "",
              "id": "nyg1v",
              "is_component": false,
              "name": "Delighted Dubinsky"
            },
            "frozen": false,
            "lf_version": "1.3.4",
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Text3",
                "hidden": false,
                "method": "parse_combined_text",
                "name": "ParserComponent-rFJn1_parsed_text",
                "options": null,
                "proxy": {
                  "id": "ParserComponent-tvNzY",
                  "name": "parsed_text",
                  "nodeDisplayName": "Parser"
                },
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "template": {
              "ascending_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "proxy": {
                  "field": "ascending",
                  "id": "DataFrameOperationsComponent-2Jqrw"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code_DataFrameOperationsComponent-rvJsS": {
                "advanced": true,
                "display_name": "Code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "DataFrameOperationsComponent-2Jqrw"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "code_ParserComponent-rFJn1": {
                "advanced": true,
                "display_name": "Code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "ParserComponent-tvNzY"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Text3\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "column_name_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "proxy": {
                  "field": "column_name",
                  "id": "DataFrameOperationsComponent-2Jqrw"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "proxy": {
                  "field": "columns_to_select",
                  "id": "DataFrameOperationsComponent-2Jqrw"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "proxy": {
                  "field": "df",
                  "id": "DataFrameOperationsComponent-2Jqrw"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "proxy": {
                  "field": "filter_value",
                  "id": "DataFrameOperationsComponent-2Jqrw"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "mode_ParserComponent-rFJn1": {
                "_input_type": "TabInput",
                "advanced": true,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "proxy": {
                  "field": "mode",
                  "id": "ParserComponent-tvNzY"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "new_column_name_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_name",
                  "id": "DataFrameOperationsComponent-2Jqrw"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_value",
                  "id": "DataFrameOperationsComponent-2Jqrw"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "proxy": {
                  "field": "num_rows",
                  "id": "DataFrameOperationsComponent-2Jqrw"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "operation_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "operation",
                  "id": "DataFrameOperationsComponent-2Jqrw"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Head"
              },
              "pattern_ParserComponent-rFJn1": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "proxy": {
                  "field": "pattern",
                  "id": "ParserComponent-tvNzY"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{model_response}"
              },
              "replace_value_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "proxy": {
                  "field": "replace_value",
                  "id": "DataFrameOperationsComponent-2Jqrw"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value_DataFrameOperationsComponent-rvJsS": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "proxy": {
                  "field": "replacement_value",
                  "id": "DataFrameOperationsComponent-2Jqrw"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sep_ParserComponent-rFJn1": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "proxy": {
                  "field": "sep",
                  "id": "ParserComponent-tvNzY"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            }
          },
          "type": "GroupNode"
        },
        "id": "GroupNode-mCw5i",
        "measured": {
          "height": 159,
          "width": 320
        },
        "position": {
          "x": 3040.1818661827137,
          "y": 909.4307801290931
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "JSONtoData-DrZKW",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Convert a JSON string to a Data object",
            "display_name": "Load JSON",
            "documentation": "",
            "edited": true,
            "field_order": [
              "json_string"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": true,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": false,
                "method": "convert_json_to_data",
                "name": "data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\r\nfrom json_repair import repair_json\r\nfrom langflow.custom import Component\r\nfrom langflow.io import MultilineInput, Output\r\nfrom langflow.schema import Data\r\n\r\nclass JSONToDataComponent(Component):\r\n    display_name = \"Load JSON\"\r\n    description = \"Convert a JSON string to a Data object\"\r\n    icon = \"braces\"\r\n    name = \"JSONtoData\"\r\n    legacy = True\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"json_string\",\r\n            display_name=\"JSON String\",\r\n            info=\"Enter a valid JSON string to convert to a Data object\",\r\n        ),\r\n    ]\r\n    outputs = [\r\n        Output(name=\"data\", display_name=\"Data\", method=\"convert_json_to_data\"),\r\n    ]\r\n\r\n    def convert_json_to_data(self) -> Data:\r\n        if not self.json_string:\r\n            msg = \"Please provide a JSON string.\"\r\n            self.status = msg\r\n            raise ValueError(msg)\r\n        \r\n        try:\r\n            # Try to parse the JSON string\r\n            try:\r\n                parsed_data = json.loads(self.json_string)\r\n            except json.JSONDecodeError:\r\n                # If JSON parsing fails, try to repair the JSON string\r\n                repaired_json_string = repair_json(self.json_string)\r\n                parsed_data = json.loads(repaired_json_string)\r\n            \r\n            # Convert the parsed data to a Data object\r\n            # If it's a list, we'll use the first item or merge them, depending on use case\r\n            if isinstance(parsed_data, list):\r\n                # Option 1: Use first item in the list\r\n                # result = Data(data=parsed_data[0])\r\n                \r\n                # Option 2: Keep the entire list as the data\r\n                result = Data(data=parsed_data)\r\n            else:\r\n                result = Data(data=parsed_data)\r\n            \r\n            self.status = result\r\n            return result\r\n            \r\n        except (json.JSONDecodeError, SyntaxError, ValueError) as e:\r\n            error_message = f\"Invalid JSON: {e}\"\r\n            self.status = error_message\r\n            raise ValueError(error_message) from e\r\n        except Exception as e:\r\n            error_message = f\"An error occurred: {e}\"\r\n            self.status = error_message\r\n            raise ValueError(error_message) from e"
              },
              "json_string": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "JSON String",
                "dynamic": false,
                "info": "Enter a valid JSON string to convert to a Data object",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "json_string",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "JSONtoData"
        },
        "id": "JSONtoData-DrZKW",
        "measured": {
          "height": 228,
          "width": 320
        },
        "position": {
          "x": 3559.2571485176586,
          "y": 735.9487473474815
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "MultiTemplateParserComponent-72YMA",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Format a DataFrame or Data object into text using multiple templates. Outputs parsed results for each template separately.",
            "display_name": "Multi-Template Parser",
            "documentation": "",
            "edited": true,
            "field_order": [
              "mode",
              "template_1",
              "template_2",
              "template_3",
              "input_data",
              "sep"
            ],
            "frozen": false,
            "icon": "brackets",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "official": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Result 1",
                "hidden": false,
                "method": "get_result_1",
                "name": "result_1",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Result 2",
                "hidden": false,
                "method": "get_result_2",
                "name": "result_2",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Result 3",
                "hidden": false,
                "method": "get_result_3",
                "name": "result_3",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\r\nfrom typing import Any, List, Optional\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    BoolInput,\r\n    HandleInput,\r\n    MessageTextInput,\r\n    MultilineInput,\r\n    Output,\r\n    TabInput,\r\n)\r\nfrom langflow.schema import Data, DataFrame\r\nfrom langflow.schema.message import Message\r\n\r\n\r\nclass MultiTemplateParserComponent(Component):\r\n    display_name = \"Multi-Template Parser\"\r\n    description = (\r\n        \"Format a DataFrame or Data object into text using multiple templates. \"\r\n        \"Outputs parsed results for each template separately.\"\r\n    )\r\n    icon = \"brackets\"\r\n\r\n    inputs = [\r\n        TabInput(\r\n            name=\"mode\",\r\n            display_name=\"Mode\",\r\n            options=[\"Parser\", \"Stringify\"],\r\n            value=\"Parser\",\r\n            info=\"Convert into raw string instead of using templates.\",\r\n            real_time_refresh=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template_1\",\r\n            display_name=\"Template 1\",\r\n            info=(\r\n                \"Use variables within curly brackets to extract column values for DataFrames \"\r\n                \"or key values for Data.\"\r\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\r\n            ),\r\n            value=\"Text: {text}\",  # Example default\r\n            dynamic=True,\r\n            show=True,\r\n            required=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template_2\",\r\n            display_name=\"Template 2\",\r\n            info=(\r\n                \"Second template pattern for extraction. \"\r\n                \"For example: `{Name} is {Age} years old and from {Country}`\"\r\n            ),\r\n            value=\"Summary: {summary}\",  # Example default\r\n            dynamic=True,\r\n            show=True,\r\n            required=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template_3\",\r\n            display_name=\"Template 3\",\r\n            info=(\r\n                \"Third template pattern for extraction. \"\r\n                \"For example: `{Country}: {Name} ({Age})`\"\r\n            ),\r\n            value=\"ID: {id}\",  # Example default\r\n            dynamic=True,\r\n            show=True,\r\n            required=True,\r\n        ),\r\n        HandleInput(\r\n            name=\"input_data\",\r\n            display_name=\"Data or DataFrame\",\r\n            input_types=[\"DataFrame\", \"Data\"],\r\n            info=\"Accepts either a DataFrame or a Data object.\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"sep\",\r\n            display_name=\"Separator\",\r\n            advanced=True,\r\n            value=\"\\n\",\r\n            info=\"String used to separate rows/items.\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            display_name=\"Result 1\",\r\n            name=\"result_1\",\r\n            info=\"Formatted text output using Template 1.\",\r\n            method=\"get_result_1\",\r\n        ),\r\n        Output(\r\n            display_name=\"Result 2\",\r\n            name=\"result_2\",\r\n            info=\"Formatted text output using Template 2.\",\r\n            method=\"get_result_2\",\r\n        ),\r\n        Output(\r\n            display_name=\"Result 3\",\r\n            name=\"result_3\",\r\n            info=\"Formatted text output using Template 3.\",\r\n            method=\"get_result_3\",\r\n        ),\r\n    ]\r\n\r\n    def update_build_config(self, build_config, field_value, field_name=None):\r\n        \"\"\"Dynamically hide/show templates and enforce requirements based on mode.\"\"\"\r\n        if field_name == \"mode\":\r\n            # Show/hide templates based on mode\r\n            show_templates = self.mode == \"Parser\"\r\n            for i in range(1, 4):\r\n                template_key = f\"template_{i}\"\r\n                if template_key in build_config:\r\n                    build_config[template_key][\"show\"] = show_templates\r\n                    build_config[template_key][\"required\"] = show_templates\r\n            \r\n            # Add clean_data option for stringify mode\r\n            if field_value and self.mode == \"Stringify\":\r\n                clean_data = BoolInput(\r\n                    name=\"clean_data\",\r\n                    display_name=\"Clean Data\",\r\n                    info=(\r\n                        \"Enable to clean the data by removing empty rows and lines \"\r\n                        \"in each cell of the DataFrame/ Data object.\"\r\n                    ),\r\n                    value=True,\r\n                    advanced=True,\r\n                    required=False,\r\n                )\r\n                build_config[\"clean_data\"] = clean_data.to_dict()\r\n            else:\r\n                build_config.pop(\"clean_data\", None)\r\n\r\n        return build_config\r\n\r\n    def _clean_args(self):\r\n        \"\"\"Prepare arguments based on input type.\"\"\"\r\n        input_data = self.input_data\r\n\r\n        match input_data:\r\n            case list() if all(isinstance(item, Data) for item in input_data):\r\n                msg = \"List of Data objects is not supported.\"\r\n                raise ValueError(msg)\r\n            case DataFrame():\r\n                return input_data, None\r\n            case Data():\r\n                return None, input_data\r\n            case dict() if \"data\" in input_data:\r\n                try:\r\n                    if \"columns\" in input_data:  # Likely a DataFrame\r\n                        return DataFrame.from_dict(input_data), None\r\n                    # Likely a Data object\r\n                    return None, Data(**input_data)\r\n                except (TypeError, ValueError, KeyError) as e:\r\n                    msg = f\"Invalid structured input provided: {e!s}\"\r\n                    raise ValueError(msg) from e\r\n            case _:\r\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\r\n                raise ValueError(msg)\r\n\r\n    def _parse_with_template(self, template: str) -> str:\r\n        \"\"\"Parse all rows/items using the specified template.\"\"\"\r\n        # Early return for stringify option\r\n        if self.mode == \"Stringify\":\r\n            return self._convert_to_string()\r\n\r\n        df, data = self._clean_args()\r\n\r\n        lines = []\r\n        try:\r\n            if df is not None:\r\n                for _, row in df.iterrows():\r\n                    try:\r\n                        formatted_text = template.format(**row.to_dict())\r\n                        lines.append(formatted_text)\r\n                    except KeyError as key_error:\r\n                        self.log(f\"Warning: Key {key_error} not found in DataFrame row.\")\r\n                        # Skip this row or add placeholder\r\n                        continue\r\n            elif data is not None:\r\n                try:\r\n                    formatted_text = template.format(**data.data)\r\n                    lines.append(formatted_text)\r\n                except KeyError as key_error:\r\n                    self.log(f\"Warning: Key {key_error} not found in Data object.\")\r\n                    # Return empty or placeholder\r\n                    return f\"Missing key(s) in data: {key_error}\"\r\n        except Exception as e:\r\n            self.log(f\"Error during template parsing: {e}\")\r\n            return f\"Error: {str(e)}\"\r\n\r\n        return self.sep.join(lines)\r\n\r\n    def _safe_convert(self, data: Any) -> str:\r\n        \"\"\"Safely convert input data to string.\"\"\"\r\n        try:\r\n            if isinstance(data, str):\r\n                return data\r\n            if isinstance(data, Message):\r\n                return data.get_text()\r\n            if isinstance(data, Data):\r\n                return json.dumps(data.data)\r\n            if isinstance(data, DataFrame):\r\n                if hasattr(self, \"clean_data\") and self.clean_data:\r\n                    # Remove empty rows\r\n                    data = data.dropna(how=\"all\")\r\n                    # Remove empty lines in each cell\r\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\r\n                    # Replace multiple newlines with a single newline\r\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\r\n                return data.to_markdown(index=False)\r\n            return str(data)\r\n        except (ValueError, TypeError, AttributeError) as e:\r\n            msg = f\"Error converting data: {e!s}\"\r\n            raise ValueError(msg) from e\r\n\r\n    def _convert_to_string(self) -> str:\r\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\r\n        if isinstance(self.input_data, list):\r\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\r\n        else:\r\n            result = self._safe_convert(self.input_data)\r\n        self.log(f\"Converted to string with length: {len(result)}\")\r\n        return result\r\n\r\n    def get_result_1(self) -> Message:\r\n        \"\"\"Return the result parsed using template 1.\"\"\"\r\n        if self.mode == \"Parser\":\r\n            result = self._parse_with_template(self.template_1)\r\n        else:  # Stringify mode\r\n            result = self._convert_to_string()\r\n        \r\n        self.status = f\"Template 1 processed with {len(result)} characters\"\r\n        return Message(text=result)\r\n\r\n    def get_result_2(self) -> Message:\r\n        \"\"\"Return the result parsed using template 2.\"\"\"\r\n        if self.mode == \"Parser\":\r\n            result = self._parse_with_template(self.template_2)\r\n        else:  # Stringify mode\r\n            result = self._convert_to_string()\r\n        \r\n        self.status = f\"Template 2 processed with {len(result)} characters\"\r\n        return Message(text=result)\r\n\r\n    def get_result_3(self) -> Message:\r\n        \"\"\"Return the result parsed using template 3.\"\"\"\r\n        if self.mode == \"Parser\":\r\n            result = self._parse_with_template(self.template_3)\r\n        else:  # Stringify mode\r\n            result = self._convert_to_string()\r\n        \r\n        self.status = f\"Template 3 processed with {len(result)} characters\"\r\n        return Message(text=result)"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using templates.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              },
              "template_1": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template 1",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template_1",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{search_queries[0]}"
              },
              "template_2": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template 2",
                "dynamic": true,
                "info": "Second template pattern for extraction. For example: `{Name} is {Age} years old and from {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template_2",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{search_queries[1]}"
              },
              "template_3": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template 3",
                "dynamic": true,
                "info": "Third template pattern for extraction. For example: `{Country}: {Name} ({Age})`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template_3",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{search_queries[2]}"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "MultiTemplateParserComponent"
        },
        "id": "MultiTemplateParserComponent-72YMA",
        "measured": {
          "height": 407,
          "width": 320
        },
        "position": {
          "x": 4037.523590246531,
          "y": 667.5884403335078
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "AstraDB-R9DHR",
          "node": {
            "base_classes": [
              "Data",
              "DataFrame",
              "VectorStore"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Ingest and search documents in Astra DB with 3 Search Queries",
            "display_name": "Astra DB * 3",
            "documentation": "https://docs.datastax.com/en/langflow/astra-components.html",
            "edited": true,
            "field_order": [
              "search_query_2",
              "search_query_3",
              "deduplicate_results",
              "token",
              "environment",
              "database_name",
              "api_endpoint",
              "keyspace",
              "collection_name",
              "embedding_model",
              "ingest_data",
              "search_query",
              "should_cache_vector_store",
              "search_method",
              "reranker",
              "lexical_terms",
              "number_of_results",
              "search_type",
              "search_score_threshold",
              "advanced_search_filter",
              "autodetect_collection",
              "content_field",
              "deletion_field",
              "ignore_invalid_documents",
              "astradb_vectorstore_kwargs"
            ],
            "frozen": false,
            "icon": "AstraDB",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "official": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Search Results",
                "hidden": false,
                "method": "search_documents",
                "name": "search_results",
                "options": null,
                "required_inputs": [
                  "collection_name",
                  "database_name",
                  "embedding_model",
                  "token"
                ],
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": null,
                "method": "as_dataframe",
                "name": "dataframe",
                "options": null,
                "required_inputs": [],
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Vector Store Connection",
                "hidden": true,
                "method": "as_vector_store",
                "name": "vectorstoreconnection",
                "options": null,
                "required_inputs": null,
                "selected": "VectorStore",
                "tool_mode": true,
                "types": [
                  "VectorStore"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "advanced_search_filter": {
                "_input_type": "NestedDictInput",
                "advanced": true,
                "display_name": "Search Metadata Filter",
                "dynamic": false,
                "info": "Optional dictionary of filters to apply to the search query.",
                "list": false,
                "list_add_label": "Add More",
                "name": "advanced_search_filter",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "NestedDict",
                "value": {}
              },
              "api_endpoint": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Astra DB API Endpoint",
                "dynamic": false,
                "info": "The API Endpoint for the Astra DB instance. Supercedes database selection.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "api_endpoint",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "https://6feab22e-d3d5-4e4a-b788-cd5f2bbd2b7a-us-east-2.apps.astra.datastax.com"
              },
              "astradb_vectorstore_kwargs": {
                "_input_type": "NestedDictInput",
                "advanced": true,
                "display_name": "AstraDBVectorStore Parameters",
                "dynamic": false,
                "info": "Optional dictionary of additional parameters for the AstraDBVectorStore.",
                "list": false,
                "list_add_label": "Add More",
                "name": "astradb_vectorstore_kwargs",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "NestedDict",
                "value": {}
              },
              "autodetect_collection": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Autodetect Collection",
                "dynamic": false,
                "info": "Boolean flag to determine whether to autodetect the collection.",
                "list": false,
                "list_add_label": "Add More",
                "name": "autodetect_collection",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import re\r\nfrom collections import defaultdict\r\nfrom dataclasses import asdict, dataclass, field\r\n\r\nfrom astrapy import DataAPIClient, Database\r\nfrom astrapy.data.info.reranking import RerankServiceOptions\r\nfrom astrapy.info import CollectionDescriptor, CollectionLexicalOptions, CollectionRerankOptions\r\nfrom langchain_astradb import AstraDBVectorStore, VectorServiceOptions\r\nfrom langchain_astradb.utils.astradb import HybridSearchMode, _AstraDBCollectionEnvironment\r\n\r\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\r\nfrom langflow.base.vectorstores.vector_store_connection_decorator import vector_store_connection\r\nfrom langflow.helpers import docs_to_data\r\nfrom langflow.inputs import FloatInput, NestedDictInput\r\nfrom langflow.io import (\r\n    BoolInput,\r\n    DropdownInput,\r\n    HandleInput,\r\n    IntInput,\r\n    QueryInput,\r\n    SecretStrInput,\r\n    StrInput,\r\n    MultilineInput,\r\n)\r\nfrom langflow.schema import Data\r\nfrom langflow.utils.version import get_version_info\r\nfrom itertools import chain\r\nfrom typing import List, Optional, Union\r\n\r\n\r\n@vector_store_connection\r\nclass AstraDBVectorStoreComponent(LCVectorStoreComponent):\r\n    display_name: str = \"Astra DB\"\r\n    description: str = \"Ingest and search documents in Astra DB\"\r\n    documentation: str = \"https://docs.datastax.com/en/langflow/astra-components.html\"\r\n    name = \"AstraDB\"\r\n    icon: str = \"AstraDB\"\r\n\r\n    _cached_vector_store: AstraDBVectorStore | None = None\r\n\r\n    @dataclass\r\n    class NewDatabaseInput:\r\n        functionality: str = \"create\"\r\n        fields: dict[str, dict] = field(\r\n            default_factory=lambda: {\r\n                \"data\": {\r\n                    \"node\": {\r\n                        \"name\": \"create_database\",\r\n                        \"description\": \"Please allow several minutes for creation to complete.\",\r\n                        \"display_name\": \"Create new database\",\r\n                        \"field_order\": [\"01_new_database_name\", \"02_cloud_provider\", \"03_region\"],\r\n                        \"template\": {\r\n                            \"01_new_database_name\": StrInput(\r\n                                name=\"new_database_name\",\r\n                                display_name=\"Name\",\r\n                                info=\"Name of the new database to create in Astra DB.\",\r\n                                required=True,\r\n                            ),\r\n                            \"02_cloud_provider\": DropdownInput(\r\n                                name=\"cloud_provider\",\r\n                                display_name=\"Cloud provider\",\r\n                                info=\"Cloud provider for the new database.\",\r\n                                options=[],\r\n                                required=True,\r\n                                real_time_refresh=True,\r\n                            ),\r\n                            \"03_region\": DropdownInput(\r\n                                name=\"region\",\r\n                                display_name=\"Region\",\r\n                                info=\"Region for the new database.\",\r\n                                options=[],\r\n                                required=True,\r\n                            ),\r\n                        },\r\n                    },\r\n                }\r\n            }\r\n        )\r\n\r\n    @dataclass\r\n    class NewCollectionInput:\r\n        functionality: str = \"create\"\r\n        fields: dict[str, dict] = field(\r\n            default_factory=lambda: {\r\n                \"data\": {\r\n                    \"node\": {\r\n                        \"name\": \"create_collection\",\r\n                        \"description\": \"Please allow several seconds for creation to complete.\",\r\n                        \"display_name\": \"Create new collection\",\r\n                        \"field_order\": [\r\n                            \"01_new_collection_name\",\r\n                            \"02_embedding_generation_provider\",\r\n                            \"03_embedding_generation_model\",\r\n                            \"04_dimension\",\r\n                        ],\r\n                        \"template\": {\r\n                            \"01_new_collection_name\": StrInput(\r\n                                name=\"new_collection_name\",\r\n                                display_name=\"Name\",\r\n                                info=\"Name of the new collection to create in Astra DB.\",\r\n                                required=True,\r\n                            ),\r\n                            \"02_embedding_generation_provider\": DropdownInput(\r\n                                name=\"embedding_generation_provider\",\r\n                                display_name=\"Embedding generation method\",\r\n                                info=\"Provider to use for generating embeddings.\",\r\n                                helper_text=(\r\n                                    \"To create collections with more embedding provider options, go to \"\r\n                                    '<a class=\"underline\" href=\"https://astra.datastax.com/\" target=\" _blank\" '\r\n                                    'rel=\"noopener noreferrer\">your database in Astra DB</a>'\r\n                                ),\r\n                                real_time_refresh=True,\r\n                                required=True,\r\n                                options=[],\r\n                            ),\r\n                            \"03_embedding_generation_model\": DropdownInput(\r\n                                name=\"embedding_generation_model\",\r\n                                display_name=\"Embedding model\",\r\n                                info=\"Model to use for generating embeddings.\",\r\n                                real_time_refresh=True,\r\n                                options=[],\r\n                            ),\r\n                            \"04_dimension\": IntInput(\r\n                                name=\"dimension\",\r\n                                display_name=\"Dimensions\",\r\n                                info=\"Dimensions of the embeddings to generate.\",\r\n                                value=None,\r\n                            ),\r\n                        },\r\n                    },\r\n                }\r\n            }\r\n        )\r\n\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"search_query_2\",\r\n            display_name=\"Second Search Query\",\r\n            info=\"Second query to search for in the vector database.\",\r\n            advanced=False,\r\n        ),\r\n        MultilineInput(\r\n            name=\"search_query_3\",\r\n            display_name=\"Third Search Query\",\r\n            info=\"Third query to search for in the vector database.\",\r\n            advanced=False,\r\n        ),\r\n        BoolInput(\r\n            name=\"deduplicate_results\",\r\n            display_name=\"Deduplicate Results\",\r\n            info=\"Remove duplicate documents from the combined search results.\",\r\n            advanced=True,\r\n            value=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"token\",\r\n            display_name=\"Astra DB Application Token\",\r\n            info=\"Authentication token for accessing Astra DB.\",\r\n            value=\"ASTRA_DB_APPLICATION_TOKEN\",\r\n            required=True,\r\n            real_time_refresh=True,\r\n            input_types=[],\r\n        ),\r\n        DropdownInput(\r\n            name=\"environment\",\r\n            display_name=\"Environment\",\r\n            info=\"The environment for the Astra DB API Endpoint.\",\r\n            options=[\"prod\", \"test\", \"dev\"],\r\n            value=\"prod\",\r\n            advanced=True,\r\n            real_time_refresh=True,\r\n            combobox=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"database_name\",\r\n            display_name=\"Database\",\r\n            info=\"The Database name for the Astra DB instance.\",\r\n            required=True,\r\n            refresh_button=True,\r\n            real_time_refresh=True,\r\n            dialog_inputs=asdict(NewDatabaseInput()),\r\n            combobox=True,\r\n        ),\r\n        StrInput(\r\n            name=\"api_endpoint\",\r\n            display_name=\"Astra DB API Endpoint\",\r\n            info=\"The API Endpoint for the Astra DB instance. Supercedes database selection.\",\r\n            show=False,\r\n        ),\r\n        DropdownInput(\r\n            name=\"keyspace\",\r\n            display_name=\"Keyspace\",\r\n            info=\"Optional keyspace within Astra DB to use for the collection.\",\r\n            advanced=True,\r\n            options=[],\r\n            real_time_refresh=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"collection_name\",\r\n            display_name=\"Collection\",\r\n            info=\"The name of the collection within Astra DB where the vectors will be stored.\",\r\n            required=True,\r\n            refresh_button=True,\r\n            real_time_refresh=True,\r\n            dialog_inputs=asdict(NewCollectionInput()),\r\n            combobox=True,\r\n            show=True,\r\n        ),\r\n        HandleInput(\r\n            name=\"embedding_model\",\r\n            display_name=\"Embedding Model\",\r\n            input_types=[\"Embeddings\"],\r\n            info=\"Specify the Embedding Model. Not required for Astra Vectorize collections.\",\r\n            required=True,\r\n            show=True,\r\n        ),\r\n        *LCVectorStoreComponent.inputs,\r\n        DropdownInput(\r\n            name=\"search_method\",\r\n            display_name=\"Search Method\",\r\n            info=(\r\n                \"Determine how your content is matched: Vector finds semantic similarity, \"\r\n                \"and Hybrid Search (suggested) combines both approaches \"\r\n                \"with a reranker.\"\r\n            ),\r\n            options=[\"Hybrid Search\", \"Vector Search\"],  # TODO: Restore Lexical Search?\r\n            options_metadata=[{\"icon\": \"SearchHybrid\"}, {\"icon\": \"SearchVector\"}],\r\n            value=\"Vector Search\",\r\n            advanced=True,\r\n            real_time_refresh=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"reranker\",\r\n            display_name=\"Reranker\",\r\n            info=\"Post-retrieval model that re-scores results for optimal relevance ranking.\",\r\n            show=False,\r\n            toggle=True,\r\n        ),\r\n        QueryInput(\r\n            name=\"lexical_terms\",\r\n            display_name=\"Lexical Terms\",\r\n            info=\"Add additional terms/keywords to augment search precision.\",\r\n            placeholder=\"Enter terms to search...\",\r\n            separator=\" \",\r\n            show=False,\r\n            value=\"\",\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"number_of_results\",\r\n            display_name=\"Number of Search Results\",\r\n            info=\"Number of search results to return.\",\r\n            advanced=True,\r\n            value=4,\r\n        ),\r\n        DropdownInput(\r\n            name=\"search_type\",\r\n            display_name=\"Search Type\",\r\n            info=\"Search type to use\",\r\n            options=[\"Similarity\", \"Similarity with score threshold\", \"MMR (Max Marginal Relevance)\"],\r\n            value=\"Similarity\",\r\n            advanced=True,\r\n        ),\r\n        FloatInput(\r\n            name=\"search_score_threshold\",\r\n            display_name=\"Search Score Threshold\",\r\n            info=\"Minimum similarity score threshold for search results. \"\r\n            \"(when using 'Similarity with score threshold')\",\r\n            value=0,\r\n            advanced=True,\r\n        ),\r\n        NestedDictInput(\r\n            name=\"advanced_search_filter\",\r\n            display_name=\"Search Metadata Filter\",\r\n            info=\"Optional dictionary of filters to apply to the search query.\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"autodetect_collection\",\r\n            display_name=\"Autodetect Collection\",\r\n            info=\"Boolean flag to determine whether to autodetect the collection.\",\r\n            advanced=True,\r\n            value=True,\r\n        ),\r\n        StrInput(\r\n            name=\"content_field\",\r\n            display_name=\"Content Field\",\r\n            info=\"Field to use as the text content field for the vector store.\",\r\n            advanced=True,\r\n        ),\r\n        StrInput(\r\n            name=\"deletion_field\",\r\n            display_name=\"Deletion Based On Field\",\r\n            info=\"When this parameter is provided, documents in the target collection with \"\r\n            \"metadata field values matching the input metadata field value will be deleted \"\r\n            \"before new data is loaded.\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"ignore_invalid_documents\",\r\n            display_name=\"Ignore Invalid Documents\",\r\n            info=\"Boolean flag to determine whether to ignore invalid documents at runtime.\",\r\n            advanced=True,\r\n        ),\r\n        NestedDictInput(\r\n            name=\"astradb_vectorstore_kwargs\",\r\n            display_name=\"AstraDBVectorStore Parameters\",\r\n            info=\"Optional dictionary of additional parameters for the AstraDBVectorStore.\",\r\n            advanced=True,\r\n        ),\r\n    ]\r\n\r\n    @classmethod\r\n    def map_cloud_providers(cls):\r\n        # TODO: Programmatically fetch the regions for each cloud provider\r\n        return {\r\n            \"dev\": {\r\n                \"Amazon Web Services\": {\r\n                    \"id\": \"aws\",\r\n                    \"regions\": [\"us-west-2\"],\r\n                },\r\n                \"Google Cloud Platform\": {\r\n                    \"id\": \"gcp\",\r\n                    \"regions\": [\"us-central1\", \"europe-west4\"],\r\n                },\r\n            },\r\n            \"test\": {\r\n                \"Google Cloud Platform\": {\r\n                    \"id\": \"gcp\",\r\n                    \"regions\": [\"us-central1\"],\r\n                },\r\n            },\r\n            \"prod\": {\r\n                \"Amazon Web Services\": {\r\n                    \"id\": \"aws\",\r\n                    \"regions\": [\"us-east-2\", \"ap-south-1\", \"eu-west-1\"],\r\n                },\r\n                \"Google Cloud Platform\": {\r\n                    \"id\": \"gcp\",\r\n                    \"regions\": [\"us-east1\"],\r\n                },\r\n                \"Microsoft Azure\": {\r\n                    \"id\": \"azure\",\r\n                    \"regions\": [\"westus3\"],\r\n                },\r\n            },\r\n        }\r\n\r\n    @classmethod\r\n    def get_vectorize_providers(cls, token: str, environment: str | None = None, api_endpoint: str | None = None):\r\n        try:\r\n            # Get the admin object\r\n            client = DataAPIClient(environment=environment)\r\n            admin_client = client.get_admin()\r\n            db_admin = admin_client.get_database_admin(api_endpoint, token=token)\r\n\r\n            # Get the list of embedding providers\r\n            embedding_providers = db_admin.find_embedding_providers()\r\n\r\n            vectorize_providers_mapping = {}\r\n            # Map the provider display name to the provider key and models\r\n            for provider_key, provider_data in embedding_providers.embedding_providers.items():\r\n                # Get the provider display name and models\r\n                display_name = provider_data.display_name\r\n                models = [model.name for model in provider_data.models]\r\n\r\n                # Build our mapping\r\n                vectorize_providers_mapping[display_name] = [provider_key, models]\r\n\r\n            # Sort the resulting dictionary\r\n            return defaultdict(list, dict(sorted(vectorize_providers_mapping.items())))\r\n        except Exception as _:  # noqa: BLE001\r\n            return {}\r\n\r\n    @classmethod\r\n    async def create_database_api(\r\n        cls,\r\n        new_database_name: str,\r\n        cloud_provider: str,\r\n        region: str,\r\n        token: str,\r\n        environment: str | None = None,\r\n        keyspace: str | None = None,\r\n    ):\r\n        client = DataAPIClient(environment=environment)\r\n\r\n        # Get the admin object\r\n        admin_client = client.get_admin(token=token)\r\n\r\n        # Get the environment, set to prod if null like\r\n        my_env = environment or \"prod\"\r\n\r\n        # Raise a value error if name isn't provided\r\n        if not new_database_name:\r\n            msg = \"Database name is required to create a new database.\"\r\n            raise ValueError(msg)\r\n\r\n        # Call the create database function\r\n        return await admin_client.async_create_database(\r\n            name=new_database_name,\r\n            cloud_provider=cls.map_cloud_providers()[my_env][cloud_provider][\"id\"],\r\n            region=region,\r\n            keyspace=keyspace,\r\n            wait_until_active=False,\r\n        )\r\n\r\n    @classmethod\r\n    async def create_collection_api(\r\n        cls,\r\n        new_collection_name: str,\r\n        token: str,\r\n        api_endpoint: str,\r\n        environment: str | None = None,\r\n        keyspace: str | None = None,\r\n        dimension: int | None = None,\r\n        embedding_generation_provider: str | None = None,\r\n        embedding_generation_model: str | None = None,\r\n        reranker: str | None = None,\r\n    ):\r\n        # Build vectorize options, if needed\r\n        vectorize_options = None\r\n        if not dimension:\r\n            providers = cls.get_vectorize_providers(token=token, environment=environment, api_endpoint=api_endpoint)\r\n            vectorize_options = VectorServiceOptions(\r\n                provider=providers.get(embedding_generation_provider, [None, []])[0],\r\n                model_name=embedding_generation_model,\r\n            )\r\n\r\n        # Raise a value error if name isn't provided\r\n        if not new_collection_name:\r\n            msg = \"Collection name is required to create a new collection.\"\r\n            raise ValueError(msg)\r\n\r\n        # Define the base arguments being passed to the create collection function\r\n        base_args = {\r\n            \"collection_name\": new_collection_name,\r\n            \"token\": token,\r\n            \"api_endpoint\": api_endpoint,\r\n            \"keyspace\": keyspace,\r\n            \"environment\": environment,\r\n            \"embedding_dimension\": dimension,\r\n            \"collection_vector_service_options\": vectorize_options,\r\n        }\r\n\r\n        # Add optional arguments only if environment is \"dev\"\r\n        if environment == \"dev\" and reranker:  # TODO: Remove conditional check soon\r\n            # Split the reranker field into a provider a model name\r\n            provider, _ = reranker.split(\"/\")\r\n            base_args[\"collection_rerank\"] = CollectionRerankOptions(\r\n                service=RerankServiceOptions(provider=provider, model_name=reranker),\r\n            )\r\n            base_args[\"collection_lexical\"] = CollectionLexicalOptions(analyzer=\"STANDARD\")\r\n\r\n        _AstraDBCollectionEnvironment(**base_args)\r\n\r\n    @classmethod\r\n    def get_database_list_static(cls, token: str, environment: str | None = None):\r\n        client = DataAPIClient(environment=environment)\r\n\r\n        # Get the admin object\r\n        admin_client = client.get_admin(token=token)\r\n\r\n        # Get the list of databases\r\n        db_list = admin_client.list_databases()\r\n\r\n        # Generate the api endpoint for each database\r\n        db_info_dict = {}\r\n        for db in db_list:\r\n            try:\r\n                # Get the API endpoint for the database\r\n                api_endpoint = db.regions[0].api_endpoint\r\n\r\n                # Get the number of collections\r\n                try:\r\n                    # Get the number of collections in the database\r\n                    num_collections = len(\r\n                        client.get_database(\r\n                            api_endpoint,\r\n                            token=token,\r\n                        ).list_collection_names()\r\n                    )\r\n                except Exception:  # noqa: BLE001\r\n                    if db.status != \"PENDING\":\r\n                        continue\r\n                    num_collections = 0\r\n\r\n                # Add the database to the dictionary\r\n                db_info_dict[db.name] = {\r\n                    \"api_endpoint\": api_endpoint,\r\n                    \"keyspaces\": db.keyspaces,\r\n                    \"collections\": num_collections,\r\n                    \"status\": db.status if db.status != \"ACTIVE\" else None,\r\n                    \"org_id\": db.org_id if db.org_id else None,\r\n                }\r\n            except Exception:  # noqa: BLE001, S110\r\n                pass\r\n\r\n        return db_info_dict\r\n\r\n    def get_database_list(self):\r\n        return self.get_database_list_static(\r\n            token=self.token,\r\n            environment=self.environment,\r\n        )\r\n\r\n    @classmethod\r\n    def get_api_endpoint_static(\r\n        cls,\r\n        token: str,\r\n        environment: str | None = None,\r\n        api_endpoint: str | None = None,\r\n        database_name: str | None = None,\r\n    ):\r\n        # If the api_endpoint is set, return it\r\n        if api_endpoint:\r\n            return api_endpoint\r\n\r\n        # Check if the database_name is like a url\r\n        if database_name and database_name.startswith(\"https://\"):\r\n            return database_name\r\n\r\n        # If the database is not set, nothing we can do.\r\n        if not database_name:\r\n            return None\r\n\r\n        # Grab the database object\r\n        db = cls.get_database_list_static(token=token, environment=environment).get(database_name)\r\n        if not db:\r\n            return None\r\n\r\n        # Otherwise, get the URL from the database list\r\n        return db.get(\"api_endpoint\")\r\n\r\n    def get_api_endpoint(self):\r\n        return self.get_api_endpoint_static(\r\n            token=self.token,\r\n            environment=self.environment,\r\n            api_endpoint=self.api_endpoint,\r\n            database_name=self.database_name,\r\n        )\r\n\r\n    @classmethod\r\n    def get_database_id_static(cls, api_endpoint: str) -> str | None:\r\n        # Pattern matches standard UUID format: 8-4-4-4-12 hexadecimal characters\r\n        uuid_pattern = r\"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\r\n        match = re.search(uuid_pattern, api_endpoint)\r\n\r\n        return match.group(0) if match else None\r\n\r\n    def get_database_id(self):\r\n        return self.get_database_id_static(api_endpoint=self.get_api_endpoint())\r\n\r\n    def get_keyspace(self):\r\n        keyspace = self.keyspace\r\n\r\n        if keyspace:\r\n            return keyspace.strip()\r\n\r\n        return \"default_keyspace\"\r\n\r\n    def get_database_object(self, api_endpoint: str | None = None):\r\n        try:\r\n            client = DataAPIClient(environment=self.environment)\r\n\r\n            return client.get_database(\r\n                api_endpoint or self.get_api_endpoint(),\r\n                token=self.token,\r\n                keyspace=self.get_keyspace(),\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error fetching database object: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n    def collection_data(self, collection_name: str, database: Database | None = None):\r\n        try:\r\n            if not database:\r\n                client = DataAPIClient(environment=self.environment)\r\n\r\n                database = client.get_database(\r\n                    self.get_api_endpoint(),\r\n                    token=self.token,\r\n                    keyspace=self.get_keyspace(),\r\n                )\r\n\r\n            collection = database.get_collection(collection_name)\r\n\r\n            return collection.estimated_document_count()\r\n        except Exception as e:  # noqa: BLE001\r\n            self.log(f\"Error checking collection data: {e}\")\r\n\r\n            return None\r\n\r\n    def _initialize_database_options(self):\r\n        try:\r\n            return [\r\n                {\r\n                    \"name\": name,\r\n                    \"status\": info[\"status\"],\r\n                    \"collections\": info[\"collections\"],\r\n                    \"api_endpoint\": info[\"api_endpoint\"],\r\n                    \"keyspaces\": info[\"keyspaces\"],\r\n                    \"org_id\": info[\"org_id\"],\r\n                }\r\n                for name, info in self.get_database_list().items()\r\n            ]\r\n        except Exception as e:\r\n            msg = f\"Error fetching database options: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n    @classmethod\r\n    def get_provider_icon(cls, collection: CollectionDescriptor | None = None, provider_name: str | None = None) -> str:\r\n        # Get the provider name from the collection\r\n        provider_name = provider_name or (\r\n            collection.definition.vector.service.provider\r\n            if (\r\n                collection\r\n                and collection.definition\r\n                and collection.definition.vector\r\n                and collection.definition.vector.service\r\n            )\r\n            else None\r\n        )\r\n\r\n        # If there is no provider, use the vector store icon\r\n        if not provider_name or provider_name.lower() == \"bring your own\":\r\n            return \"vectorstores\"\r\n\r\n        # Map provider casings\r\n        case_map = {\r\n            \"nvidia\": \"NVIDIA\",\r\n            \"openai\": \"OpenAI\",\r\n            \"amazon bedrock\": \"AmazonBedrockEmbeddings\",\r\n            \"azure openai\": \"AzureOpenAiEmbeddings\",\r\n            \"cohere\": \"Cohere\",\r\n            \"jina ai\": \"JinaAI\",\r\n            \"mistral ai\": \"MistralAI\",\r\n            \"upstage\": \"Upstage\",\r\n            \"voyage ai\": \"VoyageAI\",\r\n        }\r\n\r\n        # Adjust the casing on some like nvidia\r\n        return case_map[provider_name.lower()] if provider_name.lower() in case_map else provider_name.title()\r\n\r\n    def _initialize_collection_options(self, api_endpoint: str | None = None):\r\n        # Nothing to generate if we don't have an API endpoint yet\r\n        api_endpoint = api_endpoint or self.get_api_endpoint()\r\n        if not api_endpoint:\r\n            return []\r\n\r\n        # Retrieve the database object\r\n        database = self.get_database_object(api_endpoint=api_endpoint)\r\n\r\n        # Get the list of collections\r\n        collection_list = database.list_collections(keyspace=self.get_keyspace())\r\n\r\n        # Return the list of collections and metadata associated\r\n        return [\r\n            {\r\n                \"name\": col.name,\r\n                \"records\": self.collection_data(collection_name=col.name, database=database),\r\n                \"provider\": (\r\n                    col.definition.vector.service.provider\r\n                    if col.definition.vector and col.definition.vector.service\r\n                    else None\r\n                ),\r\n                \"icon\": self.get_provider_icon(collection=col),\r\n                \"model\": (\r\n                    col.definition.vector.service.model_name\r\n                    if col.definition.vector and col.definition.vector.service\r\n                    else None\r\n                ),\r\n            }\r\n            for col in collection_list\r\n        ]\r\n\r\n    def reset_provider_options(self, build_config: dict) -> dict:\r\n        \"\"\"Reset provider options and related configurations in the build_config dictionary.\"\"\"\r\n        # Extract template path for cleaner access\r\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n\r\n        # Get vectorize providers\r\n        vectorize_providers_api = self.get_vectorize_providers(\r\n            token=self.token,\r\n            environment=self.environment,\r\n            api_endpoint=build_config[\"api_endpoint\"][\"value\"],\r\n        )\r\n\r\n        # Create a new dictionary with \"Bring your own\" first\r\n        vectorize_providers: dict[str, list[list[str]]] = {\"Bring your own\": [[], []]}\r\n\r\n        # Add the remaining items (only Nvidia) from the original dictionary\r\n        vectorize_providers.update(\r\n            {\r\n                k: v\r\n                for k, v in vectorize_providers_api.items()\r\n                if k.lower() in [\"nvidia\"]  # TODO: Eventually support more\r\n            }\r\n        )\r\n\r\n        # Set provider options\r\n        provider_field = \"02_embedding_generation_provider\"\r\n        template[provider_field][\"options\"] = list(vectorize_providers.keys())\r\n\r\n        # Add metadata for each provider option\r\n        template[provider_field][\"options_metadata\"] = [\r\n            {\"icon\": self.get_provider_icon(provider_name=provider)} for provider in template[provider_field][\"options\"]\r\n        ]\r\n\r\n        # Get selected embedding provider\r\n        embedding_provider = template[provider_field][\"value\"]\r\n        is_bring_your_own = embedding_provider and embedding_provider == \"Bring your own\"\r\n\r\n        # Configure embedding model field\r\n        model_field = \"03_embedding_generation_model\"\r\n        template[model_field].update(\r\n            {\r\n                \"options\": vectorize_providers.get(embedding_provider, [[], []])[1],\r\n                \"placeholder\": \"Bring your own\" if is_bring_your_own else None,\r\n                \"readonly\": is_bring_your_own,\r\n                \"required\": not is_bring_your_own,\r\n                \"value\": None,\r\n            }\r\n        )\r\n\r\n        # If this is a bring your own, set dimensions to 0\r\n        return self.reset_dimension_field(build_config)\r\n\r\n    def reset_dimension_field(self, build_config: dict) -> dict:\r\n        \"\"\"Reset dimension field options based on provided configuration.\"\"\"\r\n        # Extract template path for cleaner access\r\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n\r\n        # Get selected embedding model\r\n        provider_field = \"02_embedding_generation_provider\"\r\n        embedding_provider = template[provider_field][\"value\"]\r\n        is_bring_your_own = embedding_provider and embedding_provider == \"Bring your own\"\r\n\r\n        # Configure dimension field\r\n        dimension_field = \"04_dimension\"\r\n        dimension_value = 1024 if not is_bring_your_own else None  # TODO: Dynamically figure this out\r\n        template[dimension_field].update(\r\n            {\r\n                \"placeholder\": dimension_value,\r\n                \"value\": dimension_value,\r\n                \"readonly\": not is_bring_your_own,\r\n                \"required\": is_bring_your_own,\r\n            }\r\n        )\r\n\r\n        return build_config\r\n\r\n    def reset_collection_list(self, build_config: dict) -> dict:\r\n        \"\"\"Reset collection list options based on provided configuration.\"\"\"\r\n        # Get collection options\r\n        collection_options = self._initialize_collection_options(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\r\n        # Update collection configuration\r\n        collection_config = build_config[\"collection_name\"]\r\n        collection_config.update(\r\n            {\r\n                \"options\": [col[\"name\"] for col in collection_options],\r\n                \"options_metadata\": [{k: v for k, v in col.items() if k != \"name\"} for col in collection_options],\r\n            }\r\n        )\r\n\r\n        # Reset selected collection if not in options\r\n        if collection_config[\"value\"] not in collection_config[\"options\"]:\r\n            collection_config[\"value\"] = \"\"\r\n\r\n        # Set advanced status based on database selection\r\n        collection_config[\"show\"] = bool(build_config[\"database_name\"][\"value\"])\r\n\r\n        return build_config\r\n\r\n    def reset_database_list(self, build_config: dict) -> dict:\r\n        \"\"\"Reset database list options and related configurations.\"\"\"\r\n        # Get database options\r\n        database_options = self._initialize_database_options()\r\n\r\n        # Update cloud provider options\r\n        env = self.environment\r\n        template = build_config[\"database_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n        template[\"02_cloud_provider\"][\"options\"] = list(self.map_cloud_providers()[env].keys())\r\n\r\n        # Update database configuration\r\n        database_config = build_config[\"database_name\"]\r\n        database_config.update(\r\n            {\r\n                \"options\": [db[\"name\"] for db in database_options],\r\n                \"options_metadata\": [{k: v for k, v in db.items() if k != \"name\"} for db in database_options],\r\n            }\r\n        )\r\n\r\n        # Reset selections if value not in options\r\n        if database_config[\"value\"] not in database_config[\"options\"]:\r\n            database_config[\"value\"] = \"\"\r\n            build_config[\"api_endpoint\"][\"value\"] = \"\"\r\n            build_config[\"collection_name\"][\"show\"] = False\r\n\r\n        # Set advanced status based on token presence\r\n        database_config[\"show\"] = bool(build_config[\"token\"][\"value\"])\r\n\r\n        return build_config\r\n\r\n    def reset_build_config(self, build_config: dict) -> dict:\r\n        \"\"\"Reset all build configuration options to default empty state.\"\"\"\r\n        # Reset database configuration\r\n        database_config = build_config[\"database_name\"]\r\n        database_config.update({\"options\": [], \"options_metadata\": [], \"value\": \"\", \"show\": False})\r\n        build_config[\"api_endpoint\"][\"value\"] = \"\"\r\n\r\n        # Reset collection configuration\r\n        collection_config = build_config[\"collection_name\"]\r\n        collection_config.update({\"options\": [], \"options_metadata\": [], \"value\": \"\", \"show\": False})\r\n\r\n        return build_config\r\n\r\n    def _handle_hybrid_search_options(self, build_config: dict) -> dict:\r\n        \"\"\"Set hybrid search options in the build configuration.\"\"\"\r\n        # Detect what hybrid options are available\r\n        # Get the admin object\r\n        client = DataAPIClient(environment=self.environment)\r\n        admin_client = client.get_admin()\r\n        db_admin = admin_client.get_database_admin(self.get_api_endpoint(), token=self.token)\r\n\r\n        # We will try to get the reranking providers to see if its hybrid emabled\r\n        try:\r\n            providers = db_admin.find_reranking_providers()\r\n            build_config[\"reranker\"][\"options\"] = [\r\n                model.name for provider_data in providers.reranking_providers.values() for model in provider_data.models\r\n            ]\r\n            build_config[\"reranker\"][\"options_metadata\"] = [\r\n                {\"icon\": self.get_provider_icon(provider_name=model.name.split(\"/\")[0])}\r\n                for provider in providers.reranking_providers.values()\r\n                for model in provider.models\r\n            ]\r\n            build_config[\"reranker\"][\"value\"] = build_config[\"reranker\"][\"options\"][0]\r\n\r\n            # Set the default search field to hybrid search\r\n            build_config[\"search_method\"][\"show\"] = True\r\n            build_config[\"search_method\"][\"options\"] = [\"Hybrid Search\", \"Vector Search\"]\r\n            build_config[\"search_method\"][\"value\"] = \"Hybrid Search\"\r\n        except Exception as _:  # noqa: BLE001\r\n            build_config[\"reranker\"][\"options\"] = []\r\n            build_config[\"reranker\"][\"options_metadata\"] = []\r\n\r\n            # Set the default search field to vector search\r\n            build_config[\"search_method\"][\"show\"] = False\r\n            build_config[\"search_method\"][\"options\"] = [\"Vector Search\"]\r\n            build_config[\"search_method\"][\"value\"] = \"Vector Search\"\r\n\r\n        # Set reranker and lexical terms options based on search method\r\n        build_config[\"reranker\"][\"toggle_value\"] = True\r\n        build_config[\"reranker\"][\"show\"] = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\r\n        build_config[\"reranker\"][\"toggle_disable\"] = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\r\n        if build_config[\"reranker\"][\"show\"]:\r\n            build_config[\"search_type\"][\"value\"] = \"Similarity\"\r\n\r\n        return build_config\r\n\r\n    async def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\r\n        \"\"\"Update build configuration based on field name and value.\"\"\"\r\n        # Early return if no token provided\r\n        if not self.token:\r\n            return self.reset_build_config(build_config)\r\n\r\n        # Database creation callback\r\n        if field_name == \"database_name\" and isinstance(field_value, dict):\r\n            if \"01_new_database_name\" in field_value:\r\n                await self._create_new_database(build_config, field_value)\r\n                return self.reset_collection_list(build_config)\r\n            return self._update_cloud_regions(build_config, field_value)\r\n\r\n        # Collection creation callback\r\n        if field_name == \"collection_name\" and isinstance(field_value, dict):\r\n            # Case 1: New collection creation\r\n            if \"01_new_collection_name\" in field_value:\r\n                await self._create_new_collection(build_config, field_value)\r\n                return build_config\r\n\r\n            # Case 2: Update embedding provider options\r\n            if \"02_embedding_generation_provider\" in field_value:\r\n                return self.reset_provider_options(build_config)\r\n\r\n            # Case 3: Update dimension field\r\n            if \"03_embedding_generation_model\" in field_value:\r\n                return self.reset_dimension_field(build_config)\r\n\r\n        # Initial execution or token/environment change\r\n        first_run = field_name == \"collection_name\" and not field_value and not build_config[\"database_name\"][\"options\"]\r\n        if first_run or field_name in {\"token\", \"environment\"}:\r\n            return self.reset_database_list(build_config)\r\n\r\n        # Database selection change\r\n        if field_name == \"database_name\" and not isinstance(field_value, dict):\r\n            return self._handle_database_selection(build_config, field_value)\r\n\r\n        # Keyspace selection change\r\n        if field_name == \"keyspace\":\r\n            return self.reset_collection_list(build_config)\r\n\r\n        # Collection selection change\r\n        if field_name == \"collection_name\" and not isinstance(field_value, dict):\r\n            return self._handle_collection_selection(build_config, field_value)\r\n\r\n        # Search method selection change\r\n        if field_name == \"search_method\":\r\n            is_vector_search = field_value == \"Vector Search\"\r\n            is_autodetect = build_config[\"autodetect_collection\"][\"value\"]\r\n\r\n            # Configure lexical terms (same for both cases)\r\n            build_config[\"lexical_terms\"][\"show\"] = not is_vector_search\r\n            build_config[\"lexical_terms\"][\"value\"] = \"\" if is_vector_search else build_config[\"lexical_terms\"][\"value\"]\r\n\r\n            # Disable reranker disabling if hybrid search is selected\r\n            build_config[\"reranker\"][\"toggle_disable\"] = not is_vector_search\r\n            build_config[\"reranker\"][\"toggle_value\"] = True\r\n            build_config[\"reranker\"][\"value\"] = build_config[\"reranker\"][\"options\"][0]\r\n\r\n            # Toggle search type and score threshold based on search method\r\n            build_config[\"search_type\"][\"show\"] = is_vector_search\r\n            build_config[\"search_score_threshold\"][\"show\"] = is_vector_search\r\n\r\n            # Make sure the search_type is set to \"Similarity\"\r\n            if not is_vector_search or is_autodetect:\r\n                build_config[\"search_type\"][\"value\"] = \"Similarity\"\r\n\r\n        return build_config\r\n\r\n    async def _create_new_database(self, build_config: dict, field_value: dict) -> None:\r\n        \"\"\"Create a new database and update build config options.\"\"\"\r\n        try:\r\n            await self.create_database_api(\r\n                new_database_name=field_value[\"01_new_database_name\"],\r\n                token=self.token,\r\n                keyspace=self.get_keyspace(),\r\n                environment=self.environment,\r\n                cloud_provider=field_value[\"02_cloud_provider\"],\r\n                region=field_value[\"03_region\"],\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error creating database: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n        build_config[\"database_name\"][\"options\"].append(field_value[\"01_new_database_name\"])\r\n        build_config[\"database_name\"][\"options_metadata\"].append(\r\n            {\r\n                \"status\": \"PENDING\",\r\n                \"collections\": 0,\r\n                \"api_endpoint\": None,\r\n                \"keyspaces\": [self.get_keyspace()],\r\n                \"org_id\": None,\r\n            }\r\n        )\r\n\r\n    def _update_cloud_regions(self, build_config: dict, field_value: dict) -> dict:\r\n        \"\"\"Update cloud provider regions in build config.\"\"\"\r\n        env = self.environment\r\n        cloud_provider = field_value[\"02_cloud_provider\"]\r\n\r\n        # Update the region options based on the selected cloud provider\r\n        template = build_config[\"database_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n        template[\"03_region\"][\"options\"] = self.map_cloud_providers()[env][cloud_provider][\"regions\"]\r\n\r\n        # Reset the the 03_region value if it's not in the new options\r\n        if template[\"03_region\"][\"value\"] not in template[\"03_region\"][\"options\"]:\r\n            template[\"03_region\"][\"value\"] = None\r\n\r\n        return build_config\r\n\r\n    async def _create_new_collection(self, build_config: dict, field_value: dict) -> None:\r\n        \"\"\"Create a new collection and update build config options.\"\"\"\r\n        embedding_provider = field_value.get(\"02_embedding_generation_provider\")\r\n        try:\r\n            await self.create_collection_api(\r\n                new_collection_name=field_value[\"01_new_collection_name\"],\r\n                token=self.token,\r\n                api_endpoint=build_config[\"api_endpoint\"][\"value\"],\r\n                environment=self.environment,\r\n                keyspace=self.get_keyspace(),\r\n                dimension=field_value.get(\"04_dimension\") if embedding_provider == \"Bring your own\" else None,\r\n                embedding_generation_provider=embedding_provider,\r\n                embedding_generation_model=field_value.get(\"03_embedding_generation_model\"),\r\n                reranker=self.reranker,\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error creating collection: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n        provider = embedding_provider.lower() if embedding_provider and embedding_provider != \"Bring your own\" else None\r\n        build_config[\"collection_name\"].update(\r\n            {\r\n                \"value\": field_value[\"01_new_collection_name\"],\r\n                \"options\": build_config[\"collection_name\"][\"options\"] + [field_value[\"01_new_collection_name\"]],\r\n            }\r\n        )\r\n        build_config[\"embedding_model\"][\"show\"] = not bool(provider)\r\n        build_config[\"embedding_model\"][\"required\"] = not bool(provider)\r\n        build_config[\"collection_name\"][\"options_metadata\"].append(\r\n            {\r\n                \"records\": 0,\r\n                \"provider\": provider,\r\n                \"icon\": self.get_provider_icon(provider_name=provider),\r\n                \"model\": field_value.get(\"03_embedding_generation_model\"),\r\n            }\r\n        )\r\n\r\n        # Make sure we always show the reranker options if the collection is hybrid enabled\r\n        # And right now they always are\r\n        build_config[\"lexical_terms\"][\"show\"] = True\r\n\r\n    def _handle_database_selection(self, build_config: dict, field_value: str) -> dict:\r\n        \"\"\"Handle database selection and update related configurations.\"\"\"\r\n        build_config = self.reset_database_list(build_config)\r\n\r\n        # Reset collection list if database selection changes\r\n        if field_value not in build_config[\"database_name\"][\"options\"]:\r\n            build_config[\"database_name\"][\"value\"] = \"\"\r\n            return build_config\r\n\r\n        # Get the api endpoint for the selected database\r\n        index = build_config[\"database_name\"][\"options\"].index(field_value)\r\n        build_config[\"api_endpoint\"][\"value\"] = build_config[\"database_name\"][\"options_metadata\"][index][\"api_endpoint\"]\r\n\r\n        # Get the org_id for the selected database\r\n        org_id = build_config[\"database_name\"][\"options_metadata\"][index][\"org_id\"]\r\n        if not org_id:\r\n            return build_config\r\n\r\n        # Update the list of keyspaces based on the db info\r\n        build_config[\"keyspace\"][\"options\"] = build_config[\"database_name\"][\"options_metadata\"][index][\"keyspaces\"]\r\n        build_config[\"keyspace\"][\"value\"] = (\r\n            build_config[\"keyspace\"][\"options\"] and build_config[\"keyspace\"][\"options\"][0]\r\n            if build_config[\"keyspace\"][\"value\"] not in build_config[\"keyspace\"][\"options\"]\r\n            else build_config[\"keyspace\"][\"value\"]\r\n        )\r\n\r\n        # Get the database id for the selected database\r\n        db_id = self.get_database_id_static(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\r\n        keyspace = self.get_keyspace()\r\n\r\n        # Update the helper text for the embedding provider field\r\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n        template[\"02_embedding_generation_provider\"][\"helper_text\"] = (\r\n            \"To create collections with more embedding provider options, go to \"\r\n            f'<a class=\"underline\" target=\"_blank\" rel=\"noopener noreferrer\" '\r\n            f'href=\"https://astra.datastax.com/org/{org_id}/database/{db_id}/data-explorer?createCollection=1&namespace={keyspace}\">'\r\n            \"your database in Astra DB</a>.\"\r\n        )\r\n\r\n        # Reset provider options\r\n        build_config = self.reset_provider_options(build_config)\r\n\r\n        # Handle hybrid search options\r\n        build_config = self._handle_hybrid_search_options(build_config)\r\n\r\n        return self.reset_collection_list(build_config)\r\n\r\n    def _handle_collection_selection(self, build_config: dict, field_value: str) -> dict:\r\n        \"\"\"Handle collection selection and update embedding options.\"\"\"\r\n        build_config[\"autodetect_collection\"][\"value\"] = True\r\n        build_config = self.reset_collection_list(build_config)\r\n\r\n        # Reset embedding model if collection selection changes\r\n        if field_value and field_value not in build_config[\"collection_name\"][\"options\"]:\r\n            build_config[\"collection_name\"][\"options\"].append(field_value)\r\n            build_config[\"collection_name\"][\"options_metadata\"].append(\r\n                {\r\n                    \"records\": 0,\r\n                    \"provider\": None,\r\n                    \"icon\": \"vectorstores\",\r\n                    \"model\": None,\r\n                }\r\n            )\r\n            build_config[\"autodetect_collection\"][\"value\"] = False\r\n\r\n        if not field_value:\r\n            return build_config\r\n\r\n        # Get the selected collection index\r\n        index = build_config[\"collection_name\"][\"options\"].index(field_value)\r\n\r\n        # Set the provider of the selected collection\r\n        provider = build_config[\"collection_name\"][\"options_metadata\"][index][\"provider\"]\r\n        build_config[\"embedding_model\"][\"show\"] = not bool(provider)\r\n        build_config[\"embedding_model\"][\"required\"] = not bool(provider)\r\n\r\n        # Grab the collection object\r\n        database = self.get_database_object(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\r\n        collection = database.get_collection(\r\n            name=field_value,\r\n            keyspace=build_config[\"keyspace\"][\"value\"],\r\n        )\r\n\r\n        # Check if hybrid and lexical are enabled\r\n        col_options = collection.options()\r\n        hyb_enabled = col_options.rerank and col_options.rerank.enabled\r\n        lex_enabled = col_options.lexical and col_options.lexical.enabled\r\n        user_hyb_enabled = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\r\n\r\n        # Show lexical terms if the collection is hybrid enabled\r\n        build_config[\"lexical_terms\"][\"show\"] = hyb_enabled and lex_enabled and user_hyb_enabled\r\n\r\n        return build_config\r\n\r\n    @check_cached_vector_store\r\n    def build_vector_store(self):\r\n        try:\r\n            from langchain_astradb import AstraDBVectorStore\r\n        except ImportError as e:\r\n            msg = (\r\n                \"Could not import langchain Astra DB integration package. \"\r\n                \"Please install it with `pip install langchain-astradb`.\"\r\n            )\r\n            raise ImportError(msg) from e\r\n\r\n        # Get the embedding model and additional params\r\n        embedding_params = {\"embedding\": self.embedding_model} if self.embedding_model else {}\r\n\r\n        # Get the additional parameters\r\n        additional_params = self.astradb_vectorstore_kwargs or {}\r\n\r\n        # Get Langflow version and platform information\r\n        __version__ = get_version_info()[\"version\"]\r\n        langflow_prefix = \"\"\r\n        # if os.getenv(\"AWS_EXECUTION_ENV\") == \"AWS_ECS_FARGATE\":  # TODO: More precise way of detecting\r\n        #     langflow_prefix = \"ds-\"\r\n\r\n        # Get the database object\r\n        database = self.get_database_object()\r\n        autodetect = self.collection_name in database.list_collection_names() and self.autodetect_collection\r\n\r\n        # Bundle up the auto-detect parameters\r\n        autodetect_params = {\r\n            \"autodetect_collection\": autodetect,\r\n            \"content_field\": (\r\n                self.content_field\r\n                if self.content_field and embedding_params\r\n                else (\r\n                    \"page_content\"\r\n                    if embedding_params\r\n                    and self.collection_data(collection_name=self.collection_name, database=database) == 0\r\n                    else None\r\n                )\r\n            ),\r\n            \"ignore_invalid_documents\": self.ignore_invalid_documents,\r\n        }\r\n\r\n        # Choose HybridSearchMode based on the selected param\r\n        hybrid_search_mode = HybridSearchMode.DEFAULT if self.search_method == \"Hybrid Search\" else HybridSearchMode.OFF\r\n\r\n        # Attempt to build the Vector Store object\r\n        try:\r\n            vector_store = AstraDBVectorStore(\r\n                # Astra DB Authentication Parameters\r\n                token=self.token,\r\n                api_endpoint=database.api_endpoint,\r\n                namespace=database.keyspace,\r\n                collection_name=self.collection_name,\r\n                environment=self.environment,\r\n                # Hybrid Search Parameters\r\n                hybrid_search=hybrid_search_mode,\r\n                # Astra DB Usage Tracking Parameters\r\n                ext_callers=[(f\"{langflow_prefix}langflow\", __version__)],\r\n                # Astra DB Vector Store Parameters\r\n                **autodetect_params,\r\n                **embedding_params,\r\n                **additional_params,\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error initializing AstraDBVectorStore: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n        # Add documents to the vector store\r\n        self._add_documents_to_vector_store(vector_store)\r\n\r\n        return vector_store\r\n\r\n    def _add_documents_to_vector_store(self, vector_store) -> None:\r\n        self.ingest_data = self._prepare_ingest_data()\r\n\r\n        documents = []\r\n        for _input in self.ingest_data or []:\r\n            if isinstance(_input, Data):\r\n                documents.append(_input.to_lc_document())\r\n            else:\r\n                msg = \"Vector Store Inputs must be Data objects.\"\r\n                raise TypeError(msg)\r\n\r\n        if documents and self.deletion_field:\r\n            self.log(f\"Deleting documents where {self.deletion_field}\")\r\n            try:\r\n                database = self.get_database_object()\r\n                collection = database.get_collection(self.collection_name, keyspace=database.keyspace)\r\n                delete_values = list({doc.metadata[self.deletion_field] for doc in documents})\r\n                self.log(f\"Deleting documents where {self.deletion_field} matches {delete_values}.\")\r\n                collection.delete_many({f\"metadata.{self.deletion_field}\": {\"$in\": delete_values}})\r\n            except Exception as e:\r\n                msg = f\"Error deleting documents from AstraDBVectorStore based on '{self.deletion_field}': {e}\"\r\n                raise ValueError(msg) from e\r\n\r\n        if documents:\r\n            self.log(f\"Adding {len(documents)} documents to the Vector Store.\")\r\n            try:\r\n                vector_store.add_documents(documents)\r\n            except Exception as e:\r\n                msg = f\"Error adding documents to AstraDBVectorStore: {e}\"\r\n                raise ValueError(msg) from e\r\n        else:\r\n            self.log(\"No documents to add to the Vector Store.\")\r\n\r\n    def _map_search_type(self) -> str:\r\n        search_type_mapping = {\r\n            \"Similarity with score threshold\": \"similarity_score_threshold\",\r\n            \"MMR (Max Marginal Relevance)\": \"mmr\",\r\n        }\r\n\r\n        return search_type_mapping.get(self.search_type, \"similarity\")\r\n\r\n    def _build_search_args(self):\r\n        # Clean up the search query\r\n        query = self.search_query if isinstance(self.search_query, str) and self.search_query.strip() else None\r\n        lexical_terms = self.lexical_terms or None\r\n\r\n        # Check if we have a search query, and if so set the args\r\n        if query:\r\n            args = {\r\n                \"query\": query,\r\n                \"search_type\": self._map_search_type(),\r\n                \"k\": self.number_of_results,\r\n                \"score_threshold\": self.search_score_threshold,\r\n                \"lexical_query\": lexical_terms,\r\n            }\r\n        elif self.advanced_search_filter:\r\n            args = {\r\n                \"n\": self.number_of_results,\r\n            }\r\n        else:\r\n            return {}\r\n\r\n        filter_arg = self.advanced_search_filter or {}\r\n        if filter_arg:\r\n            args[\"filter\"] = filter_arg\r\n\r\n        return args\r\n\r\n    def search_documents(self, vector_store=None) -> list[Data]:\r\n        vector_store = vector_store or self.build_vector_store()\r\n        \r\n        # Create a list of queries to process\r\n        queries = [self.search_query]\r\n        if hasattr(self, 'search_query_2') and self.search_query_2 and isinstance(self.search_query_2, str) and self.search_query_2.strip():\r\n            queries.append(self.search_query_2)\r\n        if hasattr(self, 'search_query_3') and self.search_query_3 and isinstance(self.search_query_3, str) and self.search_query_3.strip():\r\n            queries.append(self.search_query_3)\r\n        \r\n        self.log(f\"Processing {len(queries)} search queries\")\r\n        \r\n        # Store all retrieved documents\r\n        all_docs = []\r\n        \r\n        # Process each query\r\n        for idx, query in enumerate(queries, 1):\r\n            if not query:\r\n                continue\r\n                \r\n            self.log(f\"Search input #{idx}: {query}\")\r\n            self.log(f\"Search type: {self.search_type}\")\r\n            self.log(f\"Number of results: {self.number_of_results}\")\r\n            self.log(f\"store.hybrid_search: {vector_store.hybrid_search}\")\r\n            self.log(f\"Lexical terms: {self.lexical_terms}\")\r\n            self.log(f\"Reranker: {self.reranker}\")\r\n            \r\n            # Store the original search query\r\n            original_query = self.search_query\r\n            # Set the current query as search_query\r\n            self.search_query = query\r\n            \r\n            try:\r\n                search_args = self._build_search_args()\r\n            except Exception as e:\r\n                self.search_query = original_query  # Restore original query\r\n                msg = f\"Error in AstraDBVectorStore._build_search_args for query #{idx}: {e}\"\r\n                raise ValueError(msg) from e\r\n                \r\n            if not search_args:\r\n                self.log(f\"No search input or filters provided for query #{idx}. Skipping.\")\r\n                continue\r\n                \r\n            docs = []\r\n            search_method = \"search\" if \"query\" in search_args else \"metadata_search\"\r\n            \r\n            try:\r\n                self.log(f\"Calling vector_store.{search_method} with args: {search_args}\")\r\n                docs = getattr(vector_store, search_method)(**search_args)\r\n                self.log(f\"Retrieved {len(docs)} documents for query #{idx}\")\r\n                all_docs.extend(docs)\r\n            except Exception as e:\r\n                self.search_query = original_query  # Restore original query\r\n                msg = f\"Error performing {search_method} in AstraDBVectorStore for query #{idx}: {e}\"\r\n                raise ValueError(msg) from e\r\n            \r\n            # Restore the original search query\r\n            self.search_query = original_query\r\n        \r\n        # Deduplicate results if requested\r\n        if hasattr(self, 'deduplicate_results') and self.deduplicate_results:\r\n            # Create a set to track unique document content\r\n            seen_content = set()\r\n            unique_docs = []\r\n            \r\n            for doc in all_docs:\r\n                # Use page_content as a key for deduplication\r\n                content_hash = hash(doc.page_content)\r\n                if content_hash not in seen_content:\r\n                    seen_content.add(content_hash)\r\n                    unique_docs.append(doc)\r\n            \r\n            self.log(f\"Deduplicated from {len(all_docs)} to {len(unique_docs)} documents\")\r\n            all_docs = unique_docs\r\n        \r\n        self.log(f\"Total retrieved documents: {len(all_docs)}\")\r\n        \r\n        data = docs_to_data(all_docs)\r\n        self.log(f\"Converted documents to data: {len(data)}\")\r\n        self.status = data\r\n        \r\n        return data\r\n\r\n    def get_retriever_kwargs(self):\r\n        # For retrievers, we'll just use the primary search query\r\n        # This keeps compatibility with existing retriever interfaces\r\n        search_args = self._build_search_args()\r\n        \r\n        return {\r\n            \"search_type\": self._map_search_type(),\r\n            \"search_kwargs\": search_args,\r\n        }"
              },
              "collection_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {
                  "fields": {
                    "data": {
                      "node": {
                        "description": "Please allow several seconds for creation to complete.",
                        "display_name": "Create new collection",
                        "field_order": [
                          "01_new_collection_name",
                          "02_embedding_generation_provider",
                          "03_embedding_generation_model",
                          "04_dimension"
                        ],
                        "name": "create_collection",
                        "template": {
                          "01_new_collection_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Name",
                            "dynamic": false,
                            "info": "Name of the new collection to create in Astra DB.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_collection_name",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "02_embedding_generation_provider": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Embedding generation method",
                            "dynamic": false,
                            "helper_text": "To create collections with more embedding provider options, go to <a class=\"underline\" target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://astra.datastax.com/org/72c50b26-728b-4a86-8ee5-9dc701bc5adf/database/6feab22e-d3d5-4e4a-b788-cd5f2bbd2b7a/data-explorer?createCollection=1&namespace=default_keyspace\">your database in Astra DB</a>.",
                            "info": "Provider to use for generating embeddings.",
                            "name": "embedding_generation_provider",
                            "options": [
                              "Bring your own",
                              "Nvidia"
                            ],
                            "options_metadata": [
                              {
                                "icon": "vectorstores"
                              },
                              {
                                "icon": "NVIDIA"
                              }
                            ],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "03_embedding_generation_model": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Embedding model",
                            "dynamic": false,
                            "info": "Model to use for generating embeddings.",
                            "name": "embedding_generation_model",
                            "options": [],
                            "options_metadata": [],
                            "placeholder": null,
                            "readonly": "",
                            "real_time_refresh": true,
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": null
                          },
                          "04_dimension": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Dimensions",
                            "dynamic": false,
                            "info": "Dimensions of the embeddings to generate.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "dimension",
                            "placeholder": 1024,
                            "readonly": true,
                            "required": "",
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1024
                          }
                        }
                      }
                    }
                  },
                  "functionality": "create"
                },
                "display_name": "Collection",
                "dynamic": false,
                "info": "The name of the collection within Astra DB where the vectors will be stored.",
                "load_from_db": false,
                "name": "collection_name",
                "options": [
                  "textbook"
                ],
                "options_metadata": [
                  {
                    "icon": "vectorstores",
                    "model": null,
                    "provider": null,
                    "records": 154
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": true,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "textbook"
              },
              "content_field": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Content Field",
                "dynamic": false,
                "info": "Field to use as the text content field for the vector store.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "content_field",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "database_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {
                  "fields": {
                    "data": {
                      "node": {
                        "description": "Please allow several minutes for creation to complete.",
                        "display_name": "Create new database",
                        "field_order": [
                          "01_new_database_name",
                          "02_cloud_provider",
                          "03_region"
                        ],
                        "name": "create_database",
                        "template": {
                          "01_new_database_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Name",
                            "dynamic": false,
                            "info": "Name of the new database to create in Astra DB.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_database_name",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "02_cloud_provider": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Cloud provider",
                            "dynamic": false,
                            "info": "Cloud provider for the new database.",
                            "name": "cloud_provider",
                            "options": [
                              "Amazon Web Services",
                              "Google Cloud Platform",
                              "Microsoft Azure"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "03_region": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Region",
                            "dynamic": false,
                            "info": "Region for the new database.",
                            "name": "region",
                            "options": [],
                            "options_metadata": [],
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          }
                        }
                      }
                    }
                  },
                  "functionality": "create"
                },
                "display_name": "Database",
                "dynamic": false,
                "info": "The Database name for the Astra DB instance.",
                "load_from_db": false,
                "name": "database_name",
                "options": [
                  "G11 - History Text Book"
                ],
                "options_metadata": [
                  {
                    "api_endpoint": "https://6feab22e-d3d5-4e4a-b788-cd5f2bbd2b7a-us-east-2.apps.astra.datastax.com",
                    "collections": 1,
                    "keyspaces": [
                      "default_keyspace"
                    ],
                    "org_id": "72c50b26-728b-4a86-8ee5-9dc701bc5adf",
                    "status": null
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": true,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "G11 - History Text Book"
              },
              "deduplicate_results": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Deduplicate Results",
                "dynamic": false,
                "info": "Remove duplicate documents from the combined search results.",
                "list": false,
                "list_add_label": "Add More",
                "name": "deduplicate_results",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "deletion_field": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Deletion Based On Field",
                "dynamic": false,
                "info": "When this parameter is provided, documents in the target collection with metadata field values matching the input metadata field value will be deleted before new data is loaded.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "deletion_field",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "embedding_model": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Embedding Model",
                "dynamic": false,
                "info": "Specify the Embedding Model. Not required for Astra Vectorize collections.",
                "input_types": [
                  "Embeddings"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "embedding_model",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "environment": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Environment",
                "dynamic": false,
                "info": "The environment for the Astra DB API Endpoint.",
                "name": "environment",
                "options": [
                  "prod",
                  "test",
                  "dev"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "prod"
              },
              "ignore_invalid_documents": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Ignore Invalid Documents",
                "dynamic": false,
                "info": "Boolean flag to determine whether to ignore invalid documents at runtime.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ignore_invalid_documents",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "ingest_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Ingest Data",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Data",
                  "DataFrame"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "ingest_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "keyspace": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Keyspace",
                "dynamic": false,
                "info": "Optional keyspace within Astra DB to use for the collection.",
                "load_from_db": false,
                "name": "keyspace",
                "options": [
                  "default_keyspace"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "default_keyspace"
              },
              "lexical_terms": {
                "_input_type": "QueryInput",
                "advanced": true,
                "display_name": "Lexical Terms",
                "dynamic": false,
                "info": "Add additional terms/keywords to augment search precision.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "lexical_terms",
                "placeholder": "Enter terms to search...",
                "required": false,
                "separator": " ",
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "query",
                "value": ""
              },
              "number_of_results": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Search Results",
                "dynamic": false,
                "info": "Number of search results to return.",
                "list": false,
                "list_add_label": "Add More",
                "name": "number_of_results",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 4
              },
              "reranker": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Reranker",
                "dynamic": false,
                "info": "Post-retrieval model that re-scores results for optimal relevance ranking.",
                "load_from_db": false,
                "name": "reranker",
                "options": [
                  "nvidia/llama-3.2-nv-rerankqa-1b-v2"
                ],
                "options_metadata": [
                  {
                    "icon": "NVIDIA"
                  }
                ],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": true,
                "toggle_disable": true,
                "toggle_value": true,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "nvidia/llama-3.2-nv-rerankqa-1b-v2"
              },
              "search_method": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Search Method",
                "dynamic": false,
                "info": "Determine how your content is matched: Vector finds semantic similarity, and Hybrid Search (suggested) combines both approaches with a reranker.",
                "name": "search_method",
                "options": [
                  "Hybrid Search",
                  "Vector Search"
                ],
                "options_metadata": [
                  {
                    "icon": "SearchHybrid"
                  },
                  {
                    "icon": "SearchVector"
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Hybrid Search"
              },
              "search_query": {
                "_input_type": "QueryInput",
                "advanced": false,
                "display_name": "Search Query",
                "dynamic": false,
                "info": "Enter a query to run a similarity search.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "search_query",
                "placeholder": "Enter a query...",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "query",
                "value": ""
              },
              "search_query_2": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Second Search Query",
                "dynamic": false,
                "info": "Second query to search for in the vector database.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "search_query_2",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "search_query_3": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Third Search Query",
                "dynamic": false,
                "info": "Third query to search for in the vector database.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "search_query_3",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "search_score_threshold": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Search Score Threshold",
                "dynamic": false,
                "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
                "list": false,
                "list_add_label": "Add More",
                "name": "search_score_threshold",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": 0
              },
              "search_type": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Search Type",
                "dynamic": false,
                "info": "Search type to use",
                "name": "search_type",
                "options": [
                  "Similarity",
                  "Similarity with score threshold",
                  "MMR (Max Marginal Relevance)"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Similarity"
              },
              "should_cache_vector_store": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Cache Vector Store",
                "dynamic": false,
                "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_cache_vector_store",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "token": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Astra DB Application Token",
                "dynamic": false,
                "info": "Authentication token for accessing Astra DB.",
                "input_types": [],
                "load_from_db": true,
                "name": "token",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "AstraDB"
        },
        "id": "AstraDB-R9DHR",
        "measured": {
          "height": 858,
          "width": 320
        },
        "position": {
          "x": 4613.569091945792,
          "y": 204.57240588493727
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "JSONtoData-GtnYW",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Convert a JSON string to a Data object",
            "display_name": "Load JSON",
            "documentation": "",
            "edited": true,
            "field_order": [
              "json_string"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": true,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": false,
                "method": "convert_json_to_data",
                "name": "data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\r\nfrom json_repair import repair_json\r\nfrom langflow.custom import Component\r\nfrom langflow.io import MultilineInput, Output\r\nfrom langflow.schema import Data\r\n\r\nclass JSONToDataComponent(Component):\r\n    display_name = \"Load JSON\"\r\n    description = \"Convert a JSON string to a Data object\"\r\n    icon = \"braces\"\r\n    name = \"JSONtoData\"\r\n    legacy = True\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"json_string\",\r\n            display_name=\"JSON String\",\r\n            info=\"Enter a valid JSON string to convert to a Data object\",\r\n        ),\r\n    ]\r\n    outputs = [\r\n        Output(name=\"data\", display_name=\"Data\", method=\"convert_json_to_data\"),\r\n    ]\r\n\r\n    def convert_json_to_data(self) -> Data:\r\n        if not self.json_string:\r\n            msg = \"Please provide a JSON string.\"\r\n            self.status = msg\r\n            raise ValueError(msg)\r\n        \r\n        try:\r\n            # Try to parse the JSON string\r\n            try:\r\n                parsed_data = json.loads(self.json_string)\r\n            except json.JSONDecodeError:\r\n                # If JSON parsing fails, try to repair the JSON string\r\n                repaired_json_string = repair_json(self.json_string)\r\n                parsed_data = json.loads(repaired_json_string)\r\n            \r\n            # Convert the parsed data to a Data object\r\n            # If it's a list, we'll use the first item or merge them, depending on use case\r\n            if isinstance(parsed_data, list):\r\n                # Option 1: Use first item in the list\r\n                # result = Data(data=parsed_data[0])\r\n                \r\n                # Option 2: Keep the entire list as the data\r\n                result = Data(data=parsed_data)\r\n            else:\r\n                result = Data(data=parsed_data)\r\n            \r\n            self.status = result\r\n            return result\r\n            \r\n        except (json.JSONDecodeError, SyntaxError, ValueError) as e:\r\n            error_message = f\"Invalid JSON: {e}\"\r\n            self.status = error_message\r\n            raise ValueError(error_message) from e\r\n        except Exception as e:\r\n            error_message = f\"An error occurred: {e}\"\r\n            self.status = error_message\r\n            raise ValueError(error_message) from e"
              },
              "json_string": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "JSON String",
                "dynamic": false,
                "info": "Enter a valid JSON string to convert to a Data object",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "json_string",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "JSONtoData"
        },
        "id": "JSONtoData-GtnYW",
        "measured": {
          "height": 228,
          "width": 320
        },
        "position": {
          "x": 4007.6214517010303,
          "y": 1306.369056855855
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "MultiTemplateParserComponent-qqkk5",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Format a DataFrame or Data object into text using multiple templates. Outputs parsed results for each template separately.",
            "display_name": "Multi-Template Parser",
            "documentation": "",
            "edited": true,
            "field_order": [
              "mode",
              "template_1",
              "template_2",
              "template_3",
              "input_data",
              "sep"
            ],
            "frozen": false,
            "icon": "brackets",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "official": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Result 1",
                "hidden": false,
                "method": "get_result_1",
                "name": "result_1",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Result 2",
                "hidden": false,
                "method": "get_result_2",
                "name": "result_2",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Result 3",
                "hidden": false,
                "method": "get_result_3",
                "name": "result_3",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\r\nfrom typing import Any, List, Optional\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    BoolInput,\r\n    HandleInput,\r\n    MessageTextInput,\r\n    MultilineInput,\r\n    Output,\r\n    TabInput,\r\n)\r\nfrom langflow.schema import Data, DataFrame\r\nfrom langflow.schema.message import Message\r\n\r\n\r\nclass MultiTemplateParserComponent(Component):\r\n    display_name = \"Multi-Template Parser\"\r\n    description = (\r\n        \"Format a DataFrame or Data object into text using multiple templates. \"\r\n        \"Outputs parsed results for each template separately.\"\r\n    )\r\n    icon = \"brackets\"\r\n\r\n    inputs = [\r\n        TabInput(\r\n            name=\"mode\",\r\n            display_name=\"Mode\",\r\n            options=[\"Parser\", \"Stringify\"],\r\n            value=\"Parser\",\r\n            info=\"Convert into raw string instead of using templates.\",\r\n            real_time_refresh=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template_1\",\r\n            display_name=\"Template 1\",\r\n            info=(\r\n                \"Use variables within curly brackets to extract column values for DataFrames \"\r\n                \"or key values for Data.\"\r\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\r\n            ),\r\n            value=\"Text: {text}\",  # Example default\r\n            dynamic=True,\r\n            show=True,\r\n            required=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template_2\",\r\n            display_name=\"Template 2\",\r\n            info=(\r\n                \"Second template pattern for extraction. \"\r\n                \"For example: `{Name} is {Age} years old and from {Country}`\"\r\n            ),\r\n            value=\"Summary: {summary}\",  # Example default\r\n            dynamic=True,\r\n            show=True,\r\n            required=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template_3\",\r\n            display_name=\"Template 3\",\r\n            info=(\r\n                \"Third template pattern for extraction. \"\r\n                \"For example: `{Country}: {Name} ({Age})`\"\r\n            ),\r\n            value=\"ID: {id}\",  # Example default\r\n            dynamic=True,\r\n            show=True,\r\n            required=True,\r\n        ),\r\n        HandleInput(\r\n            name=\"input_data\",\r\n            display_name=\"Data or DataFrame\",\r\n            input_types=[\"DataFrame\", \"Data\"],\r\n            info=\"Accepts either a DataFrame or a Data object.\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"sep\",\r\n            display_name=\"Separator\",\r\n            advanced=True,\r\n            value=\"\\n\",\r\n            info=\"String used to separate rows/items.\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            display_name=\"Result 1\",\r\n            name=\"result_1\",\r\n            info=\"Formatted text output using Template 1.\",\r\n            method=\"get_result_1\",\r\n        ),\r\n        Output(\r\n            display_name=\"Result 2\",\r\n            name=\"result_2\",\r\n            info=\"Formatted text output using Template 2.\",\r\n            method=\"get_result_2\",\r\n        ),\r\n        Output(\r\n            display_name=\"Result 3\",\r\n            name=\"result_3\",\r\n            info=\"Formatted text output using Template 3.\",\r\n            method=\"get_result_3\",\r\n        ),\r\n    ]\r\n\r\n    def update_build_config(self, build_config, field_value, field_name=None):\r\n        \"\"\"Dynamically hide/show templates and enforce requirements based on mode.\"\"\"\r\n        if field_name == \"mode\":\r\n            # Show/hide templates based on mode\r\n            show_templates = self.mode == \"Parser\"\r\n            for i in range(1, 4):\r\n                template_key = f\"template_{i}\"\r\n                if template_key in build_config:\r\n                    build_config[template_key][\"show\"] = show_templates\r\n                    build_config[template_key][\"required\"] = show_templates\r\n            \r\n            # Add clean_data option for stringify mode\r\n            if field_value and self.mode == \"Stringify\":\r\n                clean_data = BoolInput(\r\n                    name=\"clean_data\",\r\n                    display_name=\"Clean Data\",\r\n                    info=(\r\n                        \"Enable to clean the data by removing empty rows and lines \"\r\n                        \"in each cell of the DataFrame/ Data object.\"\r\n                    ),\r\n                    value=True,\r\n                    advanced=True,\r\n                    required=False,\r\n                )\r\n                build_config[\"clean_data\"] = clean_data.to_dict()\r\n            else:\r\n                build_config.pop(\"clean_data\", None)\r\n\r\n        return build_config\r\n\r\n    def _clean_args(self):\r\n        \"\"\"Prepare arguments based on input type.\"\"\"\r\n        input_data = self.input_data\r\n\r\n        match input_data:\r\n            case list() if all(isinstance(item, Data) for item in input_data):\r\n                msg = \"List of Data objects is not supported.\"\r\n                raise ValueError(msg)\r\n            case DataFrame():\r\n                return input_data, None\r\n            case Data():\r\n                return None, input_data\r\n            case dict() if \"data\" in input_data:\r\n                try:\r\n                    if \"columns\" in input_data:  # Likely a DataFrame\r\n                        return DataFrame.from_dict(input_data), None\r\n                    # Likely a Data object\r\n                    return None, Data(**input_data)\r\n                except (TypeError, ValueError, KeyError) as e:\r\n                    msg = f\"Invalid structured input provided: {e!s}\"\r\n                    raise ValueError(msg) from e\r\n            case _:\r\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\r\n                raise ValueError(msg)\r\n\r\n    def _parse_with_template(self, template: str) -> str:\r\n        \"\"\"Parse all rows/items using the specified template.\"\"\"\r\n        # Early return for stringify option\r\n        if self.mode == \"Stringify\":\r\n            return self._convert_to_string()\r\n\r\n        df, data = self._clean_args()\r\n\r\n        lines = []\r\n        try:\r\n            if df is not None:\r\n                for _, row in df.iterrows():\r\n                    try:\r\n                        formatted_text = template.format(**row.to_dict())\r\n                        lines.append(formatted_text)\r\n                    except KeyError as key_error:\r\n                        self.log(f\"Warning: Key {key_error} not found in DataFrame row.\")\r\n                        # Skip this row or add placeholder\r\n                        continue\r\n            elif data is not None:\r\n                try:\r\n                    formatted_text = template.format(**data.data)\r\n                    lines.append(formatted_text)\r\n                except KeyError as key_error:\r\n                    self.log(f\"Warning: Key {key_error} not found in Data object.\")\r\n                    # Return empty or placeholder\r\n                    return f\"Missing key(s) in data: {key_error}\"\r\n        except Exception as e:\r\n            self.log(f\"Error during template parsing: {e}\")\r\n            return f\"Error: {str(e)}\"\r\n\r\n        return self.sep.join(lines)\r\n\r\n    def _safe_convert(self, data: Any) -> str:\r\n        \"\"\"Safely convert input data to string.\"\"\"\r\n        try:\r\n            if isinstance(data, str):\r\n                return data\r\n            if isinstance(data, Message):\r\n                return data.get_text()\r\n            if isinstance(data, Data):\r\n                return json.dumps(data.data)\r\n            if isinstance(data, DataFrame):\r\n                if hasattr(self, \"clean_data\") and self.clean_data:\r\n                    # Remove empty rows\r\n                    data = data.dropna(how=\"all\")\r\n                    # Remove empty lines in each cell\r\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\r\n                    # Replace multiple newlines with a single newline\r\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\r\n                return data.to_markdown(index=False)\r\n            return str(data)\r\n        except (ValueError, TypeError, AttributeError) as e:\r\n            msg = f\"Error converting data: {e!s}\"\r\n            raise ValueError(msg) from e\r\n\r\n    def _convert_to_string(self) -> str:\r\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\r\n        if isinstance(self.input_data, list):\r\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\r\n        else:\r\n            result = self._safe_convert(self.input_data)\r\n        self.log(f\"Converted to string with length: {len(result)}\")\r\n        return result\r\n\r\n    def get_result_1(self) -> Message:\r\n        \"\"\"Return the result parsed using template 1.\"\"\"\r\n        if self.mode == \"Parser\":\r\n            result = self._parse_with_template(self.template_1)\r\n        else:  # Stringify mode\r\n            result = self._convert_to_string()\r\n        \r\n        self.status = f\"Template 1 processed with {len(result)} characters\"\r\n        return Message(text=result)\r\n\r\n    def get_result_2(self) -> Message:\r\n        \"\"\"Return the result parsed using template 2.\"\"\"\r\n        if self.mode == \"Parser\":\r\n            result = self._parse_with_template(self.template_2)\r\n        else:  # Stringify mode\r\n            result = self._convert_to_string()\r\n        \r\n        self.status = f\"Template 2 processed with {len(result)} characters\"\r\n        return Message(text=result)\r\n\r\n    def get_result_3(self) -> Message:\r\n        \"\"\"Return the result parsed using template 3.\"\"\"\r\n        if self.mode == \"Parser\":\r\n            result = self._parse_with_template(self.template_3)\r\n        else:  # Stringify mode\r\n            result = self._convert_to_string()\r\n        \r\n        self.status = f\"Template 3 processed with {len(result)} characters\"\r\n        return Message(text=result)"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using templates.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              },
              "template_1": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template 1",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template_1",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{search_queries[0]}"
              },
              "template_2": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template 2",
                "dynamic": true,
                "info": "Second template pattern for extraction. For example: `{Name} is {Age} years old and from {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template_2",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{search_queries[1]}"
              },
              "template_3": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template 3",
                "dynamic": true,
                "info": "Third template pattern for extraction. For example: `{Country}: {Name} ({Age})`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template_3",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{search_queries[2]}"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "MultiTemplateParserComponent"
        },
        "id": "MultiTemplateParserComponent-qqkk5",
        "measured": {
          "height": 407,
          "width": 320
        },
        "position": {
          "x": 4485.887893429903,
          "y": 1238.0087498418816
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "AstraDB-jLVbY",
          "node": {
            "base_classes": [
              "Data",
              "DataFrame",
              "VectorStore"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Ingest and search documents in Astra DB with 3 Search Queries",
            "display_name": "Astra DB * 3",
            "documentation": "https://docs.datastax.com/en/langflow/astra-components.html",
            "edited": true,
            "field_order": [
              "search_query_2",
              "search_query_3",
              "deduplicate_results",
              "token",
              "environment",
              "database_name",
              "api_endpoint",
              "keyspace",
              "collection_name",
              "embedding_model",
              "ingest_data",
              "search_query",
              "should_cache_vector_store",
              "search_method",
              "reranker",
              "lexical_terms",
              "number_of_results",
              "search_type",
              "search_score_threshold",
              "advanced_search_filter",
              "autodetect_collection",
              "content_field",
              "deletion_field",
              "ignore_invalid_documents",
              "astradb_vectorstore_kwargs"
            ],
            "frozen": false,
            "icon": "AstraDB",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "official": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Search Results",
                "hidden": false,
                "method": "search_documents",
                "name": "search_results",
                "options": null,
                "required_inputs": [
                  "collection_name",
                  "database_name",
                  "embedding_model",
                  "token"
                ],
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": null,
                "method": "as_dataframe",
                "name": "dataframe",
                "options": null,
                "required_inputs": [],
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Vector Store Connection",
                "hidden": true,
                "method": "as_vector_store",
                "name": "vectorstoreconnection",
                "options": null,
                "required_inputs": null,
                "selected": "VectorStore",
                "tool_mode": true,
                "types": [
                  "VectorStore"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "advanced_search_filter": {
                "_input_type": "NestedDictInput",
                "advanced": true,
                "display_name": "Search Metadata Filter",
                "dynamic": false,
                "info": "Optional dictionary of filters to apply to the search query.",
                "list": false,
                "list_add_label": "Add More",
                "name": "advanced_search_filter",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "NestedDict",
                "value": {}
              },
              "api_endpoint": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Astra DB API Endpoint",
                "dynamic": false,
                "info": "The API Endpoint for the Astra DB instance. Supercedes database selection.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "api_endpoint",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "https://6feab22e-d3d5-4e4a-b788-cd5f2bbd2b7a-us-east-2.apps.astra.datastax.com"
              },
              "astradb_vectorstore_kwargs": {
                "_input_type": "NestedDictInput",
                "advanced": true,
                "display_name": "AstraDBVectorStore Parameters",
                "dynamic": false,
                "info": "Optional dictionary of additional parameters for the AstraDBVectorStore.",
                "list": false,
                "list_add_label": "Add More",
                "name": "astradb_vectorstore_kwargs",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "NestedDict",
                "value": {}
              },
              "autodetect_collection": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Autodetect Collection",
                "dynamic": false,
                "info": "Boolean flag to determine whether to autodetect the collection.",
                "list": false,
                "list_add_label": "Add More",
                "name": "autodetect_collection",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import re\r\nfrom collections import defaultdict\r\nfrom dataclasses import asdict, dataclass, field\r\n\r\nfrom astrapy import DataAPIClient, Database\r\nfrom astrapy.data.info.reranking import RerankServiceOptions\r\nfrom astrapy.info import CollectionDescriptor, CollectionLexicalOptions, CollectionRerankOptions\r\nfrom langchain_astradb import AstraDBVectorStore, VectorServiceOptions\r\nfrom langchain_astradb.utils.astradb import HybridSearchMode, _AstraDBCollectionEnvironment\r\n\r\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\r\nfrom langflow.base.vectorstores.vector_store_connection_decorator import vector_store_connection\r\nfrom langflow.helpers import docs_to_data\r\nfrom langflow.inputs import FloatInput, NestedDictInput\r\nfrom langflow.io import (\r\n    BoolInput,\r\n    DropdownInput,\r\n    HandleInput,\r\n    IntInput,\r\n    QueryInput,\r\n    SecretStrInput,\r\n    StrInput,\r\n    MultilineInput,\r\n)\r\nfrom langflow.schema import Data\r\nfrom langflow.utils.version import get_version_info\r\nfrom itertools import chain\r\nfrom typing import List, Optional, Union\r\n\r\n\r\n@vector_store_connection\r\nclass AstraDBVectorStoreComponent(LCVectorStoreComponent):\r\n    display_name: str = \"Astra DB\"\r\n    description: str = \"Ingest and search documents in Astra DB\"\r\n    documentation: str = \"https://docs.datastax.com/en/langflow/astra-components.html\"\r\n    name = \"AstraDB\"\r\n    icon: str = \"AstraDB\"\r\n\r\n    _cached_vector_store: AstraDBVectorStore | None = None\r\n\r\n    @dataclass\r\n    class NewDatabaseInput:\r\n        functionality: str = \"create\"\r\n        fields: dict[str, dict] = field(\r\n            default_factory=lambda: {\r\n                \"data\": {\r\n                    \"node\": {\r\n                        \"name\": \"create_database\",\r\n                        \"description\": \"Please allow several minutes for creation to complete.\",\r\n                        \"display_name\": \"Create new database\",\r\n                        \"field_order\": [\"01_new_database_name\", \"02_cloud_provider\", \"03_region\"],\r\n                        \"template\": {\r\n                            \"01_new_database_name\": StrInput(\r\n                                name=\"new_database_name\",\r\n                                display_name=\"Name\",\r\n                                info=\"Name of the new database to create in Astra DB.\",\r\n                                required=True,\r\n                            ),\r\n                            \"02_cloud_provider\": DropdownInput(\r\n                                name=\"cloud_provider\",\r\n                                display_name=\"Cloud provider\",\r\n                                info=\"Cloud provider for the new database.\",\r\n                                options=[],\r\n                                required=True,\r\n                                real_time_refresh=True,\r\n                            ),\r\n                            \"03_region\": DropdownInput(\r\n                                name=\"region\",\r\n                                display_name=\"Region\",\r\n                                info=\"Region for the new database.\",\r\n                                options=[],\r\n                                required=True,\r\n                            ),\r\n                        },\r\n                    },\r\n                }\r\n            }\r\n        )\r\n\r\n    @dataclass\r\n    class NewCollectionInput:\r\n        functionality: str = \"create\"\r\n        fields: dict[str, dict] = field(\r\n            default_factory=lambda: {\r\n                \"data\": {\r\n                    \"node\": {\r\n                        \"name\": \"create_collection\",\r\n                        \"description\": \"Please allow several seconds for creation to complete.\",\r\n                        \"display_name\": \"Create new collection\",\r\n                        \"field_order\": [\r\n                            \"01_new_collection_name\",\r\n                            \"02_embedding_generation_provider\",\r\n                            \"03_embedding_generation_model\",\r\n                            \"04_dimension\",\r\n                        ],\r\n                        \"template\": {\r\n                            \"01_new_collection_name\": StrInput(\r\n                                name=\"new_collection_name\",\r\n                                display_name=\"Name\",\r\n                                info=\"Name of the new collection to create in Astra DB.\",\r\n                                required=True,\r\n                            ),\r\n                            \"02_embedding_generation_provider\": DropdownInput(\r\n                                name=\"embedding_generation_provider\",\r\n                                display_name=\"Embedding generation method\",\r\n                                info=\"Provider to use for generating embeddings.\",\r\n                                helper_text=(\r\n                                    \"To create collections with more embedding provider options, go to \"\r\n                                    '<a class=\"underline\" href=\"https://astra.datastax.com/\" target=\" _blank\" '\r\n                                    'rel=\"noopener noreferrer\">your database in Astra DB</a>'\r\n                                ),\r\n                                real_time_refresh=True,\r\n                                required=True,\r\n                                options=[],\r\n                            ),\r\n                            \"03_embedding_generation_model\": DropdownInput(\r\n                                name=\"embedding_generation_model\",\r\n                                display_name=\"Embedding model\",\r\n                                info=\"Model to use for generating embeddings.\",\r\n                                real_time_refresh=True,\r\n                                options=[],\r\n                            ),\r\n                            \"04_dimension\": IntInput(\r\n                                name=\"dimension\",\r\n                                display_name=\"Dimensions\",\r\n                                info=\"Dimensions of the embeddings to generate.\",\r\n                                value=None,\r\n                            ),\r\n                        },\r\n                    },\r\n                }\r\n            }\r\n        )\r\n\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"search_query_2\",\r\n            display_name=\"Second Search Query\",\r\n            info=\"Second query to search for in the vector database.\",\r\n            advanced=False,\r\n        ),\r\n        MultilineInput(\r\n            name=\"search_query_3\",\r\n            display_name=\"Third Search Query\",\r\n            info=\"Third query to search for in the vector database.\",\r\n            advanced=False,\r\n        ),\r\n        BoolInput(\r\n            name=\"deduplicate_results\",\r\n            display_name=\"Deduplicate Results\",\r\n            info=\"Remove duplicate documents from the combined search results.\",\r\n            advanced=True,\r\n            value=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"token\",\r\n            display_name=\"Astra DB Application Token\",\r\n            info=\"Authentication token for accessing Astra DB.\",\r\n            value=\"ASTRA_DB_APPLICATION_TOKEN\",\r\n            required=True,\r\n            real_time_refresh=True,\r\n            input_types=[],\r\n        ),\r\n        DropdownInput(\r\n            name=\"environment\",\r\n            display_name=\"Environment\",\r\n            info=\"The environment for the Astra DB API Endpoint.\",\r\n            options=[\"prod\", \"test\", \"dev\"],\r\n            value=\"prod\",\r\n            advanced=True,\r\n            real_time_refresh=True,\r\n            combobox=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"database_name\",\r\n            display_name=\"Database\",\r\n            info=\"The Database name for the Astra DB instance.\",\r\n            required=True,\r\n            refresh_button=True,\r\n            real_time_refresh=True,\r\n            dialog_inputs=asdict(NewDatabaseInput()),\r\n            combobox=True,\r\n        ),\r\n        StrInput(\r\n            name=\"api_endpoint\",\r\n            display_name=\"Astra DB API Endpoint\",\r\n            info=\"The API Endpoint for the Astra DB instance. Supercedes database selection.\",\r\n            show=False,\r\n        ),\r\n        DropdownInput(\r\n            name=\"keyspace\",\r\n            display_name=\"Keyspace\",\r\n            info=\"Optional keyspace within Astra DB to use for the collection.\",\r\n            advanced=True,\r\n            options=[],\r\n            real_time_refresh=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"collection_name\",\r\n            display_name=\"Collection\",\r\n            info=\"The name of the collection within Astra DB where the vectors will be stored.\",\r\n            required=True,\r\n            refresh_button=True,\r\n            real_time_refresh=True,\r\n            dialog_inputs=asdict(NewCollectionInput()),\r\n            combobox=True,\r\n            show=True,\r\n        ),\r\n        HandleInput(\r\n            name=\"embedding_model\",\r\n            display_name=\"Embedding Model\",\r\n            input_types=[\"Embeddings\"],\r\n            info=\"Specify the Embedding Model. Not required for Astra Vectorize collections.\",\r\n            required=True,\r\n            show=True,\r\n        ),\r\n        *LCVectorStoreComponent.inputs,\r\n        DropdownInput(\r\n            name=\"search_method\",\r\n            display_name=\"Search Method\",\r\n            info=(\r\n                \"Determine how your content is matched: Vector finds semantic similarity, \"\r\n                \"and Hybrid Search (suggested) combines both approaches \"\r\n                \"with a reranker.\"\r\n            ),\r\n            options=[\"Hybrid Search\", \"Vector Search\"],  # TODO: Restore Lexical Search?\r\n            options_metadata=[{\"icon\": \"SearchHybrid\"}, {\"icon\": \"SearchVector\"}],\r\n            value=\"Vector Search\",\r\n            advanced=True,\r\n            real_time_refresh=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"reranker\",\r\n            display_name=\"Reranker\",\r\n            info=\"Post-retrieval model that re-scores results for optimal relevance ranking.\",\r\n            show=False,\r\n            toggle=True,\r\n        ),\r\n        QueryInput(\r\n            name=\"lexical_terms\",\r\n            display_name=\"Lexical Terms\",\r\n            info=\"Add additional terms/keywords to augment search precision.\",\r\n            placeholder=\"Enter terms to search...\",\r\n            separator=\" \",\r\n            show=False,\r\n            value=\"\",\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"number_of_results\",\r\n            display_name=\"Number of Search Results\",\r\n            info=\"Number of search results to return.\",\r\n            advanced=True,\r\n            value=4,\r\n        ),\r\n        DropdownInput(\r\n            name=\"search_type\",\r\n            display_name=\"Search Type\",\r\n            info=\"Search type to use\",\r\n            options=[\"Similarity\", \"Similarity with score threshold\", \"MMR (Max Marginal Relevance)\"],\r\n            value=\"Similarity\",\r\n            advanced=True,\r\n        ),\r\n        FloatInput(\r\n            name=\"search_score_threshold\",\r\n            display_name=\"Search Score Threshold\",\r\n            info=\"Minimum similarity score threshold for search results. \"\r\n            \"(when using 'Similarity with score threshold')\",\r\n            value=0,\r\n            advanced=True,\r\n        ),\r\n        NestedDictInput(\r\n            name=\"advanced_search_filter\",\r\n            display_name=\"Search Metadata Filter\",\r\n            info=\"Optional dictionary of filters to apply to the search query.\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"autodetect_collection\",\r\n            display_name=\"Autodetect Collection\",\r\n            info=\"Boolean flag to determine whether to autodetect the collection.\",\r\n            advanced=True,\r\n            value=True,\r\n        ),\r\n        StrInput(\r\n            name=\"content_field\",\r\n            display_name=\"Content Field\",\r\n            info=\"Field to use as the text content field for the vector store.\",\r\n            advanced=True,\r\n        ),\r\n        StrInput(\r\n            name=\"deletion_field\",\r\n            display_name=\"Deletion Based On Field\",\r\n            info=\"When this parameter is provided, documents in the target collection with \"\r\n            \"metadata field values matching the input metadata field value will be deleted \"\r\n            \"before new data is loaded.\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"ignore_invalid_documents\",\r\n            display_name=\"Ignore Invalid Documents\",\r\n            info=\"Boolean flag to determine whether to ignore invalid documents at runtime.\",\r\n            advanced=True,\r\n        ),\r\n        NestedDictInput(\r\n            name=\"astradb_vectorstore_kwargs\",\r\n            display_name=\"AstraDBVectorStore Parameters\",\r\n            info=\"Optional dictionary of additional parameters for the AstraDBVectorStore.\",\r\n            advanced=True,\r\n        ),\r\n    ]\r\n\r\n    @classmethod\r\n    def map_cloud_providers(cls):\r\n        # TODO: Programmatically fetch the regions for each cloud provider\r\n        return {\r\n            \"dev\": {\r\n                \"Amazon Web Services\": {\r\n                    \"id\": \"aws\",\r\n                    \"regions\": [\"us-west-2\"],\r\n                },\r\n                \"Google Cloud Platform\": {\r\n                    \"id\": \"gcp\",\r\n                    \"regions\": [\"us-central1\", \"europe-west4\"],\r\n                },\r\n            },\r\n            \"test\": {\r\n                \"Google Cloud Platform\": {\r\n                    \"id\": \"gcp\",\r\n                    \"regions\": [\"us-central1\"],\r\n                },\r\n            },\r\n            \"prod\": {\r\n                \"Amazon Web Services\": {\r\n                    \"id\": \"aws\",\r\n                    \"regions\": [\"us-east-2\", \"ap-south-1\", \"eu-west-1\"],\r\n                },\r\n                \"Google Cloud Platform\": {\r\n                    \"id\": \"gcp\",\r\n                    \"regions\": [\"us-east1\"],\r\n                },\r\n                \"Microsoft Azure\": {\r\n                    \"id\": \"azure\",\r\n                    \"regions\": [\"westus3\"],\r\n                },\r\n            },\r\n        }\r\n\r\n    @classmethod\r\n    def get_vectorize_providers(cls, token: str, environment: str | None = None, api_endpoint: str | None = None):\r\n        try:\r\n            # Get the admin object\r\n            client = DataAPIClient(environment=environment)\r\n            admin_client = client.get_admin()\r\n            db_admin = admin_client.get_database_admin(api_endpoint, token=token)\r\n\r\n            # Get the list of embedding providers\r\n            embedding_providers = db_admin.find_embedding_providers()\r\n\r\n            vectorize_providers_mapping = {}\r\n            # Map the provider display name to the provider key and models\r\n            for provider_key, provider_data in embedding_providers.embedding_providers.items():\r\n                # Get the provider display name and models\r\n                display_name = provider_data.display_name\r\n                models = [model.name for model in provider_data.models]\r\n\r\n                # Build our mapping\r\n                vectorize_providers_mapping[display_name] = [provider_key, models]\r\n\r\n            # Sort the resulting dictionary\r\n            return defaultdict(list, dict(sorted(vectorize_providers_mapping.items())))\r\n        except Exception as _:  # noqa: BLE001\r\n            return {}\r\n\r\n    @classmethod\r\n    async def create_database_api(\r\n        cls,\r\n        new_database_name: str,\r\n        cloud_provider: str,\r\n        region: str,\r\n        token: str,\r\n        environment: str | None = None,\r\n        keyspace: str | None = None,\r\n    ):\r\n        client = DataAPIClient(environment=environment)\r\n\r\n        # Get the admin object\r\n        admin_client = client.get_admin(token=token)\r\n\r\n        # Get the environment, set to prod if null like\r\n        my_env = environment or \"prod\"\r\n\r\n        # Raise a value error if name isn't provided\r\n        if not new_database_name:\r\n            msg = \"Database name is required to create a new database.\"\r\n            raise ValueError(msg)\r\n\r\n        # Call the create database function\r\n        return await admin_client.async_create_database(\r\n            name=new_database_name,\r\n            cloud_provider=cls.map_cloud_providers()[my_env][cloud_provider][\"id\"],\r\n            region=region,\r\n            keyspace=keyspace,\r\n            wait_until_active=False,\r\n        )\r\n\r\n    @classmethod\r\n    async def create_collection_api(\r\n        cls,\r\n        new_collection_name: str,\r\n        token: str,\r\n        api_endpoint: str,\r\n        environment: str | None = None,\r\n        keyspace: str | None = None,\r\n        dimension: int | None = None,\r\n        embedding_generation_provider: str | None = None,\r\n        embedding_generation_model: str | None = None,\r\n        reranker: str | None = None,\r\n    ):\r\n        # Build vectorize options, if needed\r\n        vectorize_options = None\r\n        if not dimension:\r\n            providers = cls.get_vectorize_providers(token=token, environment=environment, api_endpoint=api_endpoint)\r\n            vectorize_options = VectorServiceOptions(\r\n                provider=providers.get(embedding_generation_provider, [None, []])[0],\r\n                model_name=embedding_generation_model,\r\n            )\r\n\r\n        # Raise a value error if name isn't provided\r\n        if not new_collection_name:\r\n            msg = \"Collection name is required to create a new collection.\"\r\n            raise ValueError(msg)\r\n\r\n        # Define the base arguments being passed to the create collection function\r\n        base_args = {\r\n            \"collection_name\": new_collection_name,\r\n            \"token\": token,\r\n            \"api_endpoint\": api_endpoint,\r\n            \"keyspace\": keyspace,\r\n            \"environment\": environment,\r\n            \"embedding_dimension\": dimension,\r\n            \"collection_vector_service_options\": vectorize_options,\r\n        }\r\n\r\n        # Add optional arguments only if environment is \"dev\"\r\n        if environment == \"dev\" and reranker:  # TODO: Remove conditional check soon\r\n            # Split the reranker field into a provider a model name\r\n            provider, _ = reranker.split(\"/\")\r\n            base_args[\"collection_rerank\"] = CollectionRerankOptions(\r\n                service=RerankServiceOptions(provider=provider, model_name=reranker),\r\n            )\r\n            base_args[\"collection_lexical\"] = CollectionLexicalOptions(analyzer=\"STANDARD\")\r\n\r\n        _AstraDBCollectionEnvironment(**base_args)\r\n\r\n    @classmethod\r\n    def get_database_list_static(cls, token: str, environment: str | None = None):\r\n        client = DataAPIClient(environment=environment)\r\n\r\n        # Get the admin object\r\n        admin_client = client.get_admin(token=token)\r\n\r\n        # Get the list of databases\r\n        db_list = admin_client.list_databases()\r\n\r\n        # Generate the api endpoint for each database\r\n        db_info_dict = {}\r\n        for db in db_list:\r\n            try:\r\n                # Get the API endpoint for the database\r\n                api_endpoint = db.regions[0].api_endpoint\r\n\r\n                # Get the number of collections\r\n                try:\r\n                    # Get the number of collections in the database\r\n                    num_collections = len(\r\n                        client.get_database(\r\n                            api_endpoint,\r\n                            token=token,\r\n                        ).list_collection_names()\r\n                    )\r\n                except Exception:  # noqa: BLE001\r\n                    if db.status != \"PENDING\":\r\n                        continue\r\n                    num_collections = 0\r\n\r\n                # Add the database to the dictionary\r\n                db_info_dict[db.name] = {\r\n                    \"api_endpoint\": api_endpoint,\r\n                    \"keyspaces\": db.keyspaces,\r\n                    \"collections\": num_collections,\r\n                    \"status\": db.status if db.status != \"ACTIVE\" else None,\r\n                    \"org_id\": db.org_id if db.org_id else None,\r\n                }\r\n            except Exception:  # noqa: BLE001, S110\r\n                pass\r\n\r\n        return db_info_dict\r\n\r\n    def get_database_list(self):\r\n        return self.get_database_list_static(\r\n            token=self.token,\r\n            environment=self.environment,\r\n        )\r\n\r\n    @classmethod\r\n    def get_api_endpoint_static(\r\n        cls,\r\n        token: str,\r\n        environment: str | None = None,\r\n        api_endpoint: str | None = None,\r\n        database_name: str | None = None,\r\n    ):\r\n        # If the api_endpoint is set, return it\r\n        if api_endpoint:\r\n            return api_endpoint\r\n\r\n        # Check if the database_name is like a url\r\n        if database_name and database_name.startswith(\"https://\"):\r\n            return database_name\r\n\r\n        # If the database is not set, nothing we can do.\r\n        if not database_name:\r\n            return None\r\n\r\n        # Grab the database object\r\n        db = cls.get_database_list_static(token=token, environment=environment).get(database_name)\r\n        if not db:\r\n            return None\r\n\r\n        # Otherwise, get the URL from the database list\r\n        return db.get(\"api_endpoint\")\r\n\r\n    def get_api_endpoint(self):\r\n        return self.get_api_endpoint_static(\r\n            token=self.token,\r\n            environment=self.environment,\r\n            api_endpoint=self.api_endpoint,\r\n            database_name=self.database_name,\r\n        )\r\n\r\n    @classmethod\r\n    def get_database_id_static(cls, api_endpoint: str) -> str | None:\r\n        # Pattern matches standard UUID format: 8-4-4-4-12 hexadecimal characters\r\n        uuid_pattern = r\"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\r\n        match = re.search(uuid_pattern, api_endpoint)\r\n\r\n        return match.group(0) if match else None\r\n\r\n    def get_database_id(self):\r\n        return self.get_database_id_static(api_endpoint=self.get_api_endpoint())\r\n\r\n    def get_keyspace(self):\r\n        keyspace = self.keyspace\r\n\r\n        if keyspace:\r\n            return keyspace.strip()\r\n\r\n        return \"default_keyspace\"\r\n\r\n    def get_database_object(self, api_endpoint: str | None = None):\r\n        try:\r\n            client = DataAPIClient(environment=self.environment)\r\n\r\n            return client.get_database(\r\n                api_endpoint or self.get_api_endpoint(),\r\n                token=self.token,\r\n                keyspace=self.get_keyspace(),\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error fetching database object: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n    def collection_data(self, collection_name: str, database: Database | None = None):\r\n        try:\r\n            if not database:\r\n                client = DataAPIClient(environment=self.environment)\r\n\r\n                database = client.get_database(\r\n                    self.get_api_endpoint(),\r\n                    token=self.token,\r\n                    keyspace=self.get_keyspace(),\r\n                )\r\n\r\n            collection = database.get_collection(collection_name)\r\n\r\n            return collection.estimated_document_count()\r\n        except Exception as e:  # noqa: BLE001\r\n            self.log(f\"Error checking collection data: {e}\")\r\n\r\n            return None\r\n\r\n    def _initialize_database_options(self):\r\n        try:\r\n            return [\r\n                {\r\n                    \"name\": name,\r\n                    \"status\": info[\"status\"],\r\n                    \"collections\": info[\"collections\"],\r\n                    \"api_endpoint\": info[\"api_endpoint\"],\r\n                    \"keyspaces\": info[\"keyspaces\"],\r\n                    \"org_id\": info[\"org_id\"],\r\n                }\r\n                for name, info in self.get_database_list().items()\r\n            ]\r\n        except Exception as e:\r\n            msg = f\"Error fetching database options: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n    @classmethod\r\n    def get_provider_icon(cls, collection: CollectionDescriptor | None = None, provider_name: str | None = None) -> str:\r\n        # Get the provider name from the collection\r\n        provider_name = provider_name or (\r\n            collection.definition.vector.service.provider\r\n            if (\r\n                collection\r\n                and collection.definition\r\n                and collection.definition.vector\r\n                and collection.definition.vector.service\r\n            )\r\n            else None\r\n        )\r\n\r\n        # If there is no provider, use the vector store icon\r\n        if not provider_name or provider_name.lower() == \"bring your own\":\r\n            return \"vectorstores\"\r\n\r\n        # Map provider casings\r\n        case_map = {\r\n            \"nvidia\": \"NVIDIA\",\r\n            \"openai\": \"OpenAI\",\r\n            \"amazon bedrock\": \"AmazonBedrockEmbeddings\",\r\n            \"azure openai\": \"AzureOpenAiEmbeddings\",\r\n            \"cohere\": \"Cohere\",\r\n            \"jina ai\": \"JinaAI\",\r\n            \"mistral ai\": \"MistralAI\",\r\n            \"upstage\": \"Upstage\",\r\n            \"voyage ai\": \"VoyageAI\",\r\n        }\r\n\r\n        # Adjust the casing on some like nvidia\r\n        return case_map[provider_name.lower()] if provider_name.lower() in case_map else provider_name.title()\r\n\r\n    def _initialize_collection_options(self, api_endpoint: str | None = None):\r\n        # Nothing to generate if we don't have an API endpoint yet\r\n        api_endpoint = api_endpoint or self.get_api_endpoint()\r\n        if not api_endpoint:\r\n            return []\r\n\r\n        # Retrieve the database object\r\n        database = self.get_database_object(api_endpoint=api_endpoint)\r\n\r\n        # Get the list of collections\r\n        collection_list = database.list_collections(keyspace=self.get_keyspace())\r\n\r\n        # Return the list of collections and metadata associated\r\n        return [\r\n            {\r\n                \"name\": col.name,\r\n                \"records\": self.collection_data(collection_name=col.name, database=database),\r\n                \"provider\": (\r\n                    col.definition.vector.service.provider\r\n                    if col.definition.vector and col.definition.vector.service\r\n                    else None\r\n                ),\r\n                \"icon\": self.get_provider_icon(collection=col),\r\n                \"model\": (\r\n                    col.definition.vector.service.model_name\r\n                    if col.definition.vector and col.definition.vector.service\r\n                    else None\r\n                ),\r\n            }\r\n            for col in collection_list\r\n        ]\r\n\r\n    def reset_provider_options(self, build_config: dict) -> dict:\r\n        \"\"\"Reset provider options and related configurations in the build_config dictionary.\"\"\"\r\n        # Extract template path for cleaner access\r\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n\r\n        # Get vectorize providers\r\n        vectorize_providers_api = self.get_vectorize_providers(\r\n            token=self.token,\r\n            environment=self.environment,\r\n            api_endpoint=build_config[\"api_endpoint\"][\"value\"],\r\n        )\r\n\r\n        # Create a new dictionary with \"Bring your own\" first\r\n        vectorize_providers: dict[str, list[list[str]]] = {\"Bring your own\": [[], []]}\r\n\r\n        # Add the remaining items (only Nvidia) from the original dictionary\r\n        vectorize_providers.update(\r\n            {\r\n                k: v\r\n                for k, v in vectorize_providers_api.items()\r\n                if k.lower() in [\"nvidia\"]  # TODO: Eventually support more\r\n            }\r\n        )\r\n\r\n        # Set provider options\r\n        provider_field = \"02_embedding_generation_provider\"\r\n        template[provider_field][\"options\"] = list(vectorize_providers.keys())\r\n\r\n        # Add metadata for each provider option\r\n        template[provider_field][\"options_metadata\"] = [\r\n            {\"icon\": self.get_provider_icon(provider_name=provider)} for provider in template[provider_field][\"options\"]\r\n        ]\r\n\r\n        # Get selected embedding provider\r\n        embedding_provider = template[provider_field][\"value\"]\r\n        is_bring_your_own = embedding_provider and embedding_provider == \"Bring your own\"\r\n\r\n        # Configure embedding model field\r\n        model_field = \"03_embedding_generation_model\"\r\n        template[model_field].update(\r\n            {\r\n                \"options\": vectorize_providers.get(embedding_provider, [[], []])[1],\r\n                \"placeholder\": \"Bring your own\" if is_bring_your_own else None,\r\n                \"readonly\": is_bring_your_own,\r\n                \"required\": not is_bring_your_own,\r\n                \"value\": None,\r\n            }\r\n        )\r\n\r\n        # If this is a bring your own, set dimensions to 0\r\n        return self.reset_dimension_field(build_config)\r\n\r\n    def reset_dimension_field(self, build_config: dict) -> dict:\r\n        \"\"\"Reset dimension field options based on provided configuration.\"\"\"\r\n        # Extract template path for cleaner access\r\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n\r\n        # Get selected embedding model\r\n        provider_field = \"02_embedding_generation_provider\"\r\n        embedding_provider = template[provider_field][\"value\"]\r\n        is_bring_your_own = embedding_provider and embedding_provider == \"Bring your own\"\r\n\r\n        # Configure dimension field\r\n        dimension_field = \"04_dimension\"\r\n        dimension_value = 1024 if not is_bring_your_own else None  # TODO: Dynamically figure this out\r\n        template[dimension_field].update(\r\n            {\r\n                \"placeholder\": dimension_value,\r\n                \"value\": dimension_value,\r\n                \"readonly\": not is_bring_your_own,\r\n                \"required\": is_bring_your_own,\r\n            }\r\n        )\r\n\r\n        return build_config\r\n\r\n    def reset_collection_list(self, build_config: dict) -> dict:\r\n        \"\"\"Reset collection list options based on provided configuration.\"\"\"\r\n        # Get collection options\r\n        collection_options = self._initialize_collection_options(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\r\n        # Update collection configuration\r\n        collection_config = build_config[\"collection_name\"]\r\n        collection_config.update(\r\n            {\r\n                \"options\": [col[\"name\"] for col in collection_options],\r\n                \"options_metadata\": [{k: v for k, v in col.items() if k != \"name\"} for col in collection_options],\r\n            }\r\n        )\r\n\r\n        # Reset selected collection if not in options\r\n        if collection_config[\"value\"] not in collection_config[\"options\"]:\r\n            collection_config[\"value\"] = \"\"\r\n\r\n        # Set advanced status based on database selection\r\n        collection_config[\"show\"] = bool(build_config[\"database_name\"][\"value\"])\r\n\r\n        return build_config\r\n\r\n    def reset_database_list(self, build_config: dict) -> dict:\r\n        \"\"\"Reset database list options and related configurations.\"\"\"\r\n        # Get database options\r\n        database_options = self._initialize_database_options()\r\n\r\n        # Update cloud provider options\r\n        env = self.environment\r\n        template = build_config[\"database_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n        template[\"02_cloud_provider\"][\"options\"] = list(self.map_cloud_providers()[env].keys())\r\n\r\n        # Update database configuration\r\n        database_config = build_config[\"database_name\"]\r\n        database_config.update(\r\n            {\r\n                \"options\": [db[\"name\"] for db in database_options],\r\n                \"options_metadata\": [{k: v for k, v in db.items() if k != \"name\"} for db in database_options],\r\n            }\r\n        )\r\n\r\n        # Reset selections if value not in options\r\n        if database_config[\"value\"] not in database_config[\"options\"]:\r\n            database_config[\"value\"] = \"\"\r\n            build_config[\"api_endpoint\"][\"value\"] = \"\"\r\n            build_config[\"collection_name\"][\"show\"] = False\r\n\r\n        # Set advanced status based on token presence\r\n        database_config[\"show\"] = bool(build_config[\"token\"][\"value\"])\r\n\r\n        return build_config\r\n\r\n    def reset_build_config(self, build_config: dict) -> dict:\r\n        \"\"\"Reset all build configuration options to default empty state.\"\"\"\r\n        # Reset database configuration\r\n        database_config = build_config[\"database_name\"]\r\n        database_config.update({\"options\": [], \"options_metadata\": [], \"value\": \"\", \"show\": False})\r\n        build_config[\"api_endpoint\"][\"value\"] = \"\"\r\n\r\n        # Reset collection configuration\r\n        collection_config = build_config[\"collection_name\"]\r\n        collection_config.update({\"options\": [], \"options_metadata\": [], \"value\": \"\", \"show\": False})\r\n\r\n        return build_config\r\n\r\n    def _handle_hybrid_search_options(self, build_config: dict) -> dict:\r\n        \"\"\"Set hybrid search options in the build configuration.\"\"\"\r\n        # Detect what hybrid options are available\r\n        # Get the admin object\r\n        client = DataAPIClient(environment=self.environment)\r\n        admin_client = client.get_admin()\r\n        db_admin = admin_client.get_database_admin(self.get_api_endpoint(), token=self.token)\r\n\r\n        # We will try to get the reranking providers to see if its hybrid emabled\r\n        try:\r\n            providers = db_admin.find_reranking_providers()\r\n            build_config[\"reranker\"][\"options\"] = [\r\n                model.name for provider_data in providers.reranking_providers.values() for model in provider_data.models\r\n            ]\r\n            build_config[\"reranker\"][\"options_metadata\"] = [\r\n                {\"icon\": self.get_provider_icon(provider_name=model.name.split(\"/\")[0])}\r\n                for provider in providers.reranking_providers.values()\r\n                for model in provider.models\r\n            ]\r\n            build_config[\"reranker\"][\"value\"] = build_config[\"reranker\"][\"options\"][0]\r\n\r\n            # Set the default search field to hybrid search\r\n            build_config[\"search_method\"][\"show\"] = True\r\n            build_config[\"search_method\"][\"options\"] = [\"Hybrid Search\", \"Vector Search\"]\r\n            build_config[\"search_method\"][\"value\"] = \"Hybrid Search\"\r\n        except Exception as _:  # noqa: BLE001\r\n            build_config[\"reranker\"][\"options\"] = []\r\n            build_config[\"reranker\"][\"options_metadata\"] = []\r\n\r\n            # Set the default search field to vector search\r\n            build_config[\"search_method\"][\"show\"] = False\r\n            build_config[\"search_method\"][\"options\"] = [\"Vector Search\"]\r\n            build_config[\"search_method\"][\"value\"] = \"Vector Search\"\r\n\r\n        # Set reranker and lexical terms options based on search method\r\n        build_config[\"reranker\"][\"toggle_value\"] = True\r\n        build_config[\"reranker\"][\"show\"] = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\r\n        build_config[\"reranker\"][\"toggle_disable\"] = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\r\n        if build_config[\"reranker\"][\"show\"]:\r\n            build_config[\"search_type\"][\"value\"] = \"Similarity\"\r\n\r\n        return build_config\r\n\r\n    async def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\r\n        \"\"\"Update build configuration based on field name and value.\"\"\"\r\n        # Early return if no token provided\r\n        if not self.token:\r\n            return self.reset_build_config(build_config)\r\n\r\n        # Database creation callback\r\n        if field_name == \"database_name\" and isinstance(field_value, dict):\r\n            if \"01_new_database_name\" in field_value:\r\n                await self._create_new_database(build_config, field_value)\r\n                return self.reset_collection_list(build_config)\r\n            return self._update_cloud_regions(build_config, field_value)\r\n\r\n        # Collection creation callback\r\n        if field_name == \"collection_name\" and isinstance(field_value, dict):\r\n            # Case 1: New collection creation\r\n            if \"01_new_collection_name\" in field_value:\r\n                await self._create_new_collection(build_config, field_value)\r\n                return build_config\r\n\r\n            # Case 2: Update embedding provider options\r\n            if \"02_embedding_generation_provider\" in field_value:\r\n                return self.reset_provider_options(build_config)\r\n\r\n            # Case 3: Update dimension field\r\n            if \"03_embedding_generation_model\" in field_value:\r\n                return self.reset_dimension_field(build_config)\r\n\r\n        # Initial execution or token/environment change\r\n        first_run = field_name == \"collection_name\" and not field_value and not build_config[\"database_name\"][\"options\"]\r\n        if first_run or field_name in {\"token\", \"environment\"}:\r\n            return self.reset_database_list(build_config)\r\n\r\n        # Database selection change\r\n        if field_name == \"database_name\" and not isinstance(field_value, dict):\r\n            return self._handle_database_selection(build_config, field_value)\r\n\r\n        # Keyspace selection change\r\n        if field_name == \"keyspace\":\r\n            return self.reset_collection_list(build_config)\r\n\r\n        # Collection selection change\r\n        if field_name == \"collection_name\" and not isinstance(field_value, dict):\r\n            return self._handle_collection_selection(build_config, field_value)\r\n\r\n        # Search method selection change\r\n        if field_name == \"search_method\":\r\n            is_vector_search = field_value == \"Vector Search\"\r\n            is_autodetect = build_config[\"autodetect_collection\"][\"value\"]\r\n\r\n            # Configure lexical terms (same for both cases)\r\n            build_config[\"lexical_terms\"][\"show\"] = not is_vector_search\r\n            build_config[\"lexical_terms\"][\"value\"] = \"\" if is_vector_search else build_config[\"lexical_terms\"][\"value\"]\r\n\r\n            # Disable reranker disabling if hybrid search is selected\r\n            build_config[\"reranker\"][\"toggle_disable\"] = not is_vector_search\r\n            build_config[\"reranker\"][\"toggle_value\"] = True\r\n            build_config[\"reranker\"][\"value\"] = build_config[\"reranker\"][\"options\"][0]\r\n\r\n            # Toggle search type and score threshold based on search method\r\n            build_config[\"search_type\"][\"show\"] = is_vector_search\r\n            build_config[\"search_score_threshold\"][\"show\"] = is_vector_search\r\n\r\n            # Make sure the search_type is set to \"Similarity\"\r\n            if not is_vector_search or is_autodetect:\r\n                build_config[\"search_type\"][\"value\"] = \"Similarity\"\r\n\r\n        return build_config\r\n\r\n    async def _create_new_database(self, build_config: dict, field_value: dict) -> None:\r\n        \"\"\"Create a new database and update build config options.\"\"\"\r\n        try:\r\n            await self.create_database_api(\r\n                new_database_name=field_value[\"01_new_database_name\"],\r\n                token=self.token,\r\n                keyspace=self.get_keyspace(),\r\n                environment=self.environment,\r\n                cloud_provider=field_value[\"02_cloud_provider\"],\r\n                region=field_value[\"03_region\"],\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error creating database: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n        build_config[\"database_name\"][\"options\"].append(field_value[\"01_new_database_name\"])\r\n        build_config[\"database_name\"][\"options_metadata\"].append(\r\n            {\r\n                \"status\": \"PENDING\",\r\n                \"collections\": 0,\r\n                \"api_endpoint\": None,\r\n                \"keyspaces\": [self.get_keyspace()],\r\n                \"org_id\": None,\r\n            }\r\n        )\r\n\r\n    def _update_cloud_regions(self, build_config: dict, field_value: dict) -> dict:\r\n        \"\"\"Update cloud provider regions in build config.\"\"\"\r\n        env = self.environment\r\n        cloud_provider = field_value[\"02_cloud_provider\"]\r\n\r\n        # Update the region options based on the selected cloud provider\r\n        template = build_config[\"database_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n        template[\"03_region\"][\"options\"] = self.map_cloud_providers()[env][cloud_provider][\"regions\"]\r\n\r\n        # Reset the the 03_region value if it's not in the new options\r\n        if template[\"03_region\"][\"value\"] not in template[\"03_region\"][\"options\"]:\r\n            template[\"03_region\"][\"value\"] = None\r\n\r\n        return build_config\r\n\r\n    async def _create_new_collection(self, build_config: dict, field_value: dict) -> None:\r\n        \"\"\"Create a new collection and update build config options.\"\"\"\r\n        embedding_provider = field_value.get(\"02_embedding_generation_provider\")\r\n        try:\r\n            await self.create_collection_api(\r\n                new_collection_name=field_value[\"01_new_collection_name\"],\r\n                token=self.token,\r\n                api_endpoint=build_config[\"api_endpoint\"][\"value\"],\r\n                environment=self.environment,\r\n                keyspace=self.get_keyspace(),\r\n                dimension=field_value.get(\"04_dimension\") if embedding_provider == \"Bring your own\" else None,\r\n                embedding_generation_provider=embedding_provider,\r\n                embedding_generation_model=field_value.get(\"03_embedding_generation_model\"),\r\n                reranker=self.reranker,\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error creating collection: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n        provider = embedding_provider.lower() if embedding_provider and embedding_provider != \"Bring your own\" else None\r\n        build_config[\"collection_name\"].update(\r\n            {\r\n                \"value\": field_value[\"01_new_collection_name\"],\r\n                \"options\": build_config[\"collection_name\"][\"options\"] + [field_value[\"01_new_collection_name\"]],\r\n            }\r\n        )\r\n        build_config[\"embedding_model\"][\"show\"] = not bool(provider)\r\n        build_config[\"embedding_model\"][\"required\"] = not bool(provider)\r\n        build_config[\"collection_name\"][\"options_metadata\"].append(\r\n            {\r\n                \"records\": 0,\r\n                \"provider\": provider,\r\n                \"icon\": self.get_provider_icon(provider_name=provider),\r\n                \"model\": field_value.get(\"03_embedding_generation_model\"),\r\n            }\r\n        )\r\n\r\n        # Make sure we always show the reranker options if the collection is hybrid enabled\r\n        # And right now they always are\r\n        build_config[\"lexical_terms\"][\"show\"] = True\r\n\r\n    def _handle_database_selection(self, build_config: dict, field_value: str) -> dict:\r\n        \"\"\"Handle database selection and update related configurations.\"\"\"\r\n        build_config = self.reset_database_list(build_config)\r\n\r\n        # Reset collection list if database selection changes\r\n        if field_value not in build_config[\"database_name\"][\"options\"]:\r\n            build_config[\"database_name\"][\"value\"] = \"\"\r\n            return build_config\r\n\r\n        # Get the api endpoint for the selected database\r\n        index = build_config[\"database_name\"][\"options\"].index(field_value)\r\n        build_config[\"api_endpoint\"][\"value\"] = build_config[\"database_name\"][\"options_metadata\"][index][\"api_endpoint\"]\r\n\r\n        # Get the org_id for the selected database\r\n        org_id = build_config[\"database_name\"][\"options_metadata\"][index][\"org_id\"]\r\n        if not org_id:\r\n            return build_config\r\n\r\n        # Update the list of keyspaces based on the db info\r\n        build_config[\"keyspace\"][\"options\"] = build_config[\"database_name\"][\"options_metadata\"][index][\"keyspaces\"]\r\n        build_config[\"keyspace\"][\"value\"] = (\r\n            build_config[\"keyspace\"][\"options\"] and build_config[\"keyspace\"][\"options\"][0]\r\n            if build_config[\"keyspace\"][\"value\"] not in build_config[\"keyspace\"][\"options\"]\r\n            else build_config[\"keyspace\"][\"value\"]\r\n        )\r\n\r\n        # Get the database id for the selected database\r\n        db_id = self.get_database_id_static(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\r\n        keyspace = self.get_keyspace()\r\n\r\n        # Update the helper text for the embedding provider field\r\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n        template[\"02_embedding_generation_provider\"][\"helper_text\"] = (\r\n            \"To create collections with more embedding provider options, go to \"\r\n            f'<a class=\"underline\" target=\"_blank\" rel=\"noopener noreferrer\" '\r\n            f'href=\"https://astra.datastax.com/org/{org_id}/database/{db_id}/data-explorer?createCollection=1&namespace={keyspace}\">'\r\n            \"your database in Astra DB</a>.\"\r\n        )\r\n\r\n        # Reset provider options\r\n        build_config = self.reset_provider_options(build_config)\r\n\r\n        # Handle hybrid search options\r\n        build_config = self._handle_hybrid_search_options(build_config)\r\n\r\n        return self.reset_collection_list(build_config)\r\n\r\n    def _handle_collection_selection(self, build_config: dict, field_value: str) -> dict:\r\n        \"\"\"Handle collection selection and update embedding options.\"\"\"\r\n        build_config[\"autodetect_collection\"][\"value\"] = True\r\n        build_config = self.reset_collection_list(build_config)\r\n\r\n        # Reset embedding model if collection selection changes\r\n        if field_value and field_value not in build_config[\"collection_name\"][\"options\"]:\r\n            build_config[\"collection_name\"][\"options\"].append(field_value)\r\n            build_config[\"collection_name\"][\"options_metadata\"].append(\r\n                {\r\n                    \"records\": 0,\r\n                    \"provider\": None,\r\n                    \"icon\": \"vectorstores\",\r\n                    \"model\": None,\r\n                }\r\n            )\r\n            build_config[\"autodetect_collection\"][\"value\"] = False\r\n\r\n        if not field_value:\r\n            return build_config\r\n\r\n        # Get the selected collection index\r\n        index = build_config[\"collection_name\"][\"options\"].index(field_value)\r\n\r\n        # Set the provider of the selected collection\r\n        provider = build_config[\"collection_name\"][\"options_metadata\"][index][\"provider\"]\r\n        build_config[\"embedding_model\"][\"show\"] = not bool(provider)\r\n        build_config[\"embedding_model\"][\"required\"] = not bool(provider)\r\n\r\n        # Grab the collection object\r\n        database = self.get_database_object(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\r\n        collection = database.get_collection(\r\n            name=field_value,\r\n            keyspace=build_config[\"keyspace\"][\"value\"],\r\n        )\r\n\r\n        # Check if hybrid and lexical are enabled\r\n        col_options = collection.options()\r\n        hyb_enabled = col_options.rerank and col_options.rerank.enabled\r\n        lex_enabled = col_options.lexical and col_options.lexical.enabled\r\n        user_hyb_enabled = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\r\n\r\n        # Show lexical terms if the collection is hybrid enabled\r\n        build_config[\"lexical_terms\"][\"show\"] = hyb_enabled and lex_enabled and user_hyb_enabled\r\n\r\n        return build_config\r\n\r\n    @check_cached_vector_store\r\n    def build_vector_store(self):\r\n        try:\r\n            from langchain_astradb import AstraDBVectorStore\r\n        except ImportError as e:\r\n            msg = (\r\n                \"Could not import langchain Astra DB integration package. \"\r\n                \"Please install it with `pip install langchain-astradb`.\"\r\n            )\r\n            raise ImportError(msg) from e\r\n\r\n        # Get the embedding model and additional params\r\n        embedding_params = {\"embedding\": self.embedding_model} if self.embedding_model else {}\r\n\r\n        # Get the additional parameters\r\n        additional_params = self.astradb_vectorstore_kwargs or {}\r\n\r\n        # Get Langflow version and platform information\r\n        __version__ = get_version_info()[\"version\"]\r\n        langflow_prefix = \"\"\r\n        # if os.getenv(\"AWS_EXECUTION_ENV\") == \"AWS_ECS_FARGATE\":  # TODO: More precise way of detecting\r\n        #     langflow_prefix = \"ds-\"\r\n\r\n        # Get the database object\r\n        database = self.get_database_object()\r\n        autodetect = self.collection_name in database.list_collection_names() and self.autodetect_collection\r\n\r\n        # Bundle up the auto-detect parameters\r\n        autodetect_params = {\r\n            \"autodetect_collection\": autodetect,\r\n            \"content_field\": (\r\n                self.content_field\r\n                if self.content_field and embedding_params\r\n                else (\r\n                    \"page_content\"\r\n                    if embedding_params\r\n                    and self.collection_data(collection_name=self.collection_name, database=database) == 0\r\n                    else None\r\n                )\r\n            ),\r\n            \"ignore_invalid_documents\": self.ignore_invalid_documents,\r\n        }\r\n\r\n        # Choose HybridSearchMode based on the selected param\r\n        hybrid_search_mode = HybridSearchMode.DEFAULT if self.search_method == \"Hybrid Search\" else HybridSearchMode.OFF\r\n\r\n        # Attempt to build the Vector Store object\r\n        try:\r\n            vector_store = AstraDBVectorStore(\r\n                # Astra DB Authentication Parameters\r\n                token=self.token,\r\n                api_endpoint=database.api_endpoint,\r\n                namespace=database.keyspace,\r\n                collection_name=self.collection_name,\r\n                environment=self.environment,\r\n                # Hybrid Search Parameters\r\n                hybrid_search=hybrid_search_mode,\r\n                # Astra DB Usage Tracking Parameters\r\n                ext_callers=[(f\"{langflow_prefix}langflow\", __version__)],\r\n                # Astra DB Vector Store Parameters\r\n                **autodetect_params,\r\n                **embedding_params,\r\n                **additional_params,\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error initializing AstraDBVectorStore: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n        # Add documents to the vector store\r\n        self._add_documents_to_vector_store(vector_store)\r\n\r\n        return vector_store\r\n\r\n    def _add_documents_to_vector_store(self, vector_store) -> None:\r\n        self.ingest_data = self._prepare_ingest_data()\r\n\r\n        documents = []\r\n        for _input in self.ingest_data or []:\r\n            if isinstance(_input, Data):\r\n                documents.append(_input.to_lc_document())\r\n            else:\r\n                msg = \"Vector Store Inputs must be Data objects.\"\r\n                raise TypeError(msg)\r\n\r\n        if documents and self.deletion_field:\r\n            self.log(f\"Deleting documents where {self.deletion_field}\")\r\n            try:\r\n                database = self.get_database_object()\r\n                collection = database.get_collection(self.collection_name, keyspace=database.keyspace)\r\n                delete_values = list({doc.metadata[self.deletion_field] for doc in documents})\r\n                self.log(f\"Deleting documents where {self.deletion_field} matches {delete_values}.\")\r\n                collection.delete_many({f\"metadata.{self.deletion_field}\": {\"$in\": delete_values}})\r\n            except Exception as e:\r\n                msg = f\"Error deleting documents from AstraDBVectorStore based on '{self.deletion_field}': {e}\"\r\n                raise ValueError(msg) from e\r\n\r\n        if documents:\r\n            self.log(f\"Adding {len(documents)} documents to the Vector Store.\")\r\n            try:\r\n                vector_store.add_documents(documents)\r\n            except Exception as e:\r\n                msg = f\"Error adding documents to AstraDBVectorStore: {e}\"\r\n                raise ValueError(msg) from e\r\n        else:\r\n            self.log(\"No documents to add to the Vector Store.\")\r\n\r\n    def _map_search_type(self) -> str:\r\n        search_type_mapping = {\r\n            \"Similarity with score threshold\": \"similarity_score_threshold\",\r\n            \"MMR (Max Marginal Relevance)\": \"mmr\",\r\n        }\r\n\r\n        return search_type_mapping.get(self.search_type, \"similarity\")\r\n\r\n    def _build_search_args(self):\r\n        # Clean up the search query\r\n        query = self.search_query if isinstance(self.search_query, str) and self.search_query.strip() else None\r\n        lexical_terms = self.lexical_terms or None\r\n\r\n        # Check if we have a search query, and if so set the args\r\n        if query:\r\n            args = {\r\n                \"query\": query,\r\n                \"search_type\": self._map_search_type(),\r\n                \"k\": self.number_of_results,\r\n                \"score_threshold\": self.search_score_threshold,\r\n                \"lexical_query\": lexical_terms,\r\n            }\r\n        elif self.advanced_search_filter:\r\n            args = {\r\n                \"n\": self.number_of_results,\r\n            }\r\n        else:\r\n            return {}\r\n\r\n        filter_arg = self.advanced_search_filter or {}\r\n        if filter_arg:\r\n            args[\"filter\"] = filter_arg\r\n\r\n        return args\r\n\r\n    def search_documents(self, vector_store=None) -> list[Data]:\r\n        vector_store = vector_store or self.build_vector_store()\r\n        \r\n        # Create a list of queries to process\r\n        queries = [self.search_query]\r\n        if hasattr(self, 'search_query_2') and self.search_query_2 and isinstance(self.search_query_2, str) and self.search_query_2.strip():\r\n            queries.append(self.search_query_2)\r\n        if hasattr(self, 'search_query_3') and self.search_query_3 and isinstance(self.search_query_3, str) and self.search_query_3.strip():\r\n            queries.append(self.search_query_3)\r\n        \r\n        self.log(f\"Processing {len(queries)} search queries\")\r\n        \r\n        # Store all retrieved documents\r\n        all_docs = []\r\n        \r\n        # Process each query\r\n        for idx, query in enumerate(queries, 1):\r\n            if not query:\r\n                continue\r\n                \r\n            self.log(f\"Search input #{idx}: {query}\")\r\n            self.log(f\"Search type: {self.search_type}\")\r\n            self.log(f\"Number of results: {self.number_of_results}\")\r\n            self.log(f\"store.hybrid_search: {vector_store.hybrid_search}\")\r\n            self.log(f\"Lexical terms: {self.lexical_terms}\")\r\n            self.log(f\"Reranker: {self.reranker}\")\r\n            \r\n            # Store the original search query\r\n            original_query = self.search_query\r\n            # Set the current query as search_query\r\n            self.search_query = query\r\n            \r\n            try:\r\n                search_args = self._build_search_args()\r\n            except Exception as e:\r\n                self.search_query = original_query  # Restore original query\r\n                msg = f\"Error in AstraDBVectorStore._build_search_args for query #{idx}: {e}\"\r\n                raise ValueError(msg) from e\r\n                \r\n            if not search_args:\r\n                self.log(f\"No search input or filters provided for query #{idx}. Skipping.\")\r\n                continue\r\n                \r\n            docs = []\r\n            search_method = \"search\" if \"query\" in search_args else \"metadata_search\"\r\n            \r\n            try:\r\n                self.log(f\"Calling vector_store.{search_method} with args: {search_args}\")\r\n                docs = getattr(vector_store, search_method)(**search_args)\r\n                self.log(f\"Retrieved {len(docs)} documents for query #{idx}\")\r\n                all_docs.extend(docs)\r\n            except Exception as e:\r\n                self.search_query = original_query  # Restore original query\r\n                msg = f\"Error performing {search_method} in AstraDBVectorStore for query #{idx}: {e}\"\r\n                raise ValueError(msg) from e\r\n            \r\n            # Restore the original search query\r\n            self.search_query = original_query\r\n        \r\n        # Deduplicate results if requested\r\n        if hasattr(self, 'deduplicate_results') and self.deduplicate_results:\r\n            # Create a set to track unique document content\r\n            seen_content = set()\r\n            unique_docs = []\r\n            \r\n            for doc in all_docs:\r\n                # Use page_content as a key for deduplication\r\n                content_hash = hash(doc.page_content)\r\n                if content_hash not in seen_content:\r\n                    seen_content.add(content_hash)\r\n                    unique_docs.append(doc)\r\n            \r\n            self.log(f\"Deduplicated from {len(all_docs)} to {len(unique_docs)} documents\")\r\n            all_docs = unique_docs\r\n        \r\n        self.log(f\"Total retrieved documents: {len(all_docs)}\")\r\n        \r\n        data = docs_to_data(all_docs)\r\n        self.log(f\"Converted documents to data: {len(data)}\")\r\n        self.status = data\r\n        \r\n        return data\r\n\r\n    def get_retriever_kwargs(self):\r\n        # For retrievers, we'll just use the primary search query\r\n        # This keeps compatibility with existing retriever interfaces\r\n        search_args = self._build_search_args()\r\n        \r\n        return {\r\n            \"search_type\": self._map_search_type(),\r\n            \"search_kwargs\": search_args,\r\n        }"
              },
              "collection_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {
                  "fields": {
                    "data": {
                      "node": {
                        "description": "Please allow several seconds for creation to complete.",
                        "display_name": "Create new collection",
                        "field_order": [
                          "01_new_collection_name",
                          "02_embedding_generation_provider",
                          "03_embedding_generation_model",
                          "04_dimension"
                        ],
                        "name": "create_collection",
                        "template": {
                          "01_new_collection_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Name",
                            "dynamic": false,
                            "info": "Name of the new collection to create in Astra DB.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_collection_name",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "02_embedding_generation_provider": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Embedding generation method",
                            "dynamic": false,
                            "helper_text": "To create collections with more embedding provider options, go to <a class=\"underline\" target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://astra.datastax.com/org/72c50b26-728b-4a86-8ee5-9dc701bc5adf/database/6feab22e-d3d5-4e4a-b788-cd5f2bbd2b7a/data-explorer?createCollection=1&namespace=default_keyspace\">your database in Astra DB</a>.",
                            "info": "Provider to use for generating embeddings.",
                            "name": "embedding_generation_provider",
                            "options": [
                              "Bring your own",
                              "Nvidia"
                            ],
                            "options_metadata": [
                              {
                                "icon": "vectorstores"
                              },
                              {
                                "icon": "NVIDIA"
                              }
                            ],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "03_embedding_generation_model": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Embedding model",
                            "dynamic": false,
                            "info": "Model to use for generating embeddings.",
                            "name": "embedding_generation_model",
                            "options": [],
                            "options_metadata": [],
                            "placeholder": null,
                            "readonly": "",
                            "real_time_refresh": true,
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": null
                          },
                          "04_dimension": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Dimensions",
                            "dynamic": false,
                            "info": "Dimensions of the embeddings to generate.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "dimension",
                            "placeholder": 1024,
                            "readonly": true,
                            "required": "",
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1024
                          }
                        }
                      }
                    }
                  },
                  "functionality": "create"
                },
                "display_name": "Collection",
                "dynamic": false,
                "info": "The name of the collection within Astra DB where the vectors will be stored.",
                "load_from_db": false,
                "name": "collection_name",
                "options": [
                  "textbook"
                ],
                "options_metadata": [
                  {
                    "icon": "vectorstores",
                    "model": null,
                    "provider": null,
                    "records": 154
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": true,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "textbook"
              },
              "content_field": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Content Field",
                "dynamic": false,
                "info": "Field to use as the text content field for the vector store.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "content_field",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "database_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {
                  "fields": {
                    "data": {
                      "node": {
                        "description": "Please allow several minutes for creation to complete.",
                        "display_name": "Create new database",
                        "field_order": [
                          "01_new_database_name",
                          "02_cloud_provider",
                          "03_region"
                        ],
                        "name": "create_database",
                        "template": {
                          "01_new_database_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Name",
                            "dynamic": false,
                            "info": "Name of the new database to create in Astra DB.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_database_name",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "02_cloud_provider": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Cloud provider",
                            "dynamic": false,
                            "info": "Cloud provider for the new database.",
                            "name": "cloud_provider",
                            "options": [
                              "Amazon Web Services",
                              "Google Cloud Platform",
                              "Microsoft Azure"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "03_region": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Region",
                            "dynamic": false,
                            "info": "Region for the new database.",
                            "name": "region",
                            "options": [],
                            "options_metadata": [],
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          }
                        }
                      }
                    }
                  },
                  "functionality": "create"
                },
                "display_name": "Database",
                "dynamic": false,
                "info": "The Database name for the Astra DB instance.",
                "load_from_db": false,
                "name": "database_name",
                "options": [
                  "G11 - History Text Book"
                ],
                "options_metadata": [
                  {
                    "api_endpoint": "https://6feab22e-d3d5-4e4a-b788-cd5f2bbd2b7a-us-east-2.apps.astra.datastax.com",
                    "collections": 1,
                    "keyspaces": [
                      "default_keyspace"
                    ],
                    "org_id": "72c50b26-728b-4a86-8ee5-9dc701bc5adf",
                    "status": null
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": true,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "G11 - History Text Book"
              },
              "deduplicate_results": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Deduplicate Results",
                "dynamic": false,
                "info": "Remove duplicate documents from the combined search results.",
                "list": false,
                "list_add_label": "Add More",
                "name": "deduplicate_results",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "deletion_field": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Deletion Based On Field",
                "dynamic": false,
                "info": "When this parameter is provided, documents in the target collection with metadata field values matching the input metadata field value will be deleted before new data is loaded.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "deletion_field",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "embedding_model": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Embedding Model",
                "dynamic": false,
                "info": "Specify the Embedding Model. Not required for Astra Vectorize collections.",
                "input_types": [
                  "Embeddings"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "embedding_model",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "environment": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Environment",
                "dynamic": false,
                "info": "The environment for the Astra DB API Endpoint.",
                "name": "environment",
                "options": [
                  "prod",
                  "test",
                  "dev"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "prod"
              },
              "ignore_invalid_documents": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Ignore Invalid Documents",
                "dynamic": false,
                "info": "Boolean flag to determine whether to ignore invalid documents at runtime.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ignore_invalid_documents",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "ingest_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Ingest Data",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Data",
                  "DataFrame"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "ingest_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "keyspace": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Keyspace",
                "dynamic": false,
                "info": "Optional keyspace within Astra DB to use for the collection.",
                "load_from_db": false,
                "name": "keyspace",
                "options": [
                  "default_keyspace"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "default_keyspace"
              },
              "lexical_terms": {
                "_input_type": "QueryInput",
                "advanced": true,
                "display_name": "Lexical Terms",
                "dynamic": false,
                "info": "Add additional terms/keywords to augment search precision.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "lexical_terms",
                "placeholder": "Enter terms to search...",
                "required": false,
                "separator": " ",
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "query",
                "value": ""
              },
              "number_of_results": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Search Results",
                "dynamic": false,
                "info": "Number of search results to return.",
                "list": false,
                "list_add_label": "Add More",
                "name": "number_of_results",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 4
              },
              "reranker": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Reranker",
                "dynamic": false,
                "info": "Post-retrieval model that re-scores results for optimal relevance ranking.",
                "load_from_db": false,
                "name": "reranker",
                "options": [
                  "nvidia/llama-3.2-nv-rerankqa-1b-v2"
                ],
                "options_metadata": [
                  {
                    "icon": "NVIDIA"
                  }
                ],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": true,
                "toggle_disable": true,
                "toggle_value": true,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "nvidia/llama-3.2-nv-rerankqa-1b-v2"
              },
              "search_method": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Search Method",
                "dynamic": false,
                "info": "Determine how your content is matched: Vector finds semantic similarity, and Hybrid Search (suggested) combines both approaches with a reranker.",
                "name": "search_method",
                "options": [
                  "Hybrid Search",
                  "Vector Search"
                ],
                "options_metadata": [
                  {
                    "icon": "SearchHybrid"
                  },
                  {
                    "icon": "SearchVector"
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Hybrid Search"
              },
              "search_query": {
                "_input_type": "QueryInput",
                "advanced": false,
                "display_name": "Search Query",
                "dynamic": false,
                "info": "Enter a query to run a similarity search.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "search_query",
                "placeholder": "Enter a query...",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "query",
                "value": ""
              },
              "search_query_2": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Second Search Query",
                "dynamic": false,
                "info": "Second query to search for in the vector database.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "search_query_2",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "search_query_3": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Third Search Query",
                "dynamic": false,
                "info": "Third query to search for in the vector database.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "search_query_3",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "search_score_threshold": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Search Score Threshold",
                "dynamic": false,
                "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
                "list": false,
                "list_add_label": "Add More",
                "name": "search_score_threshold",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": 0
              },
              "search_type": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Search Type",
                "dynamic": false,
                "info": "Search type to use",
                "name": "search_type",
                "options": [
                  "Similarity",
                  "Similarity with score threshold",
                  "MMR (Max Marginal Relevance)"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Similarity"
              },
              "should_cache_vector_store": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Cache Vector Store",
                "dynamic": false,
                "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_cache_vector_store",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "token": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Astra DB Application Token",
                "dynamic": false,
                "info": "Authentication token for accessing Astra DB.",
                "input_types": [],
                "load_from_db": true,
                "name": "token",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "AstraDB"
        },
        "id": "AstraDB-jLVbY",
        "measured": {
          "height": 858,
          "width": 320
        },
        "position": {
          "x": 5097.448939536962,
          "y": 1047.046023137001
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "JSONtoData-SWqoH",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Convert a JSON string to a Data object",
            "display_name": "Load JSON",
            "documentation": "",
            "edited": true,
            "field_order": [
              "json_string"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": true,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": false,
                "method": "convert_json_to_data",
                "name": "data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\r\nfrom json_repair import repair_json\r\nfrom langflow.custom import Component\r\nfrom langflow.io import MultilineInput, Output\r\nfrom langflow.schema import Data\r\n\r\nclass JSONToDataComponent(Component):\r\n    display_name = \"Load JSON\"\r\n    description = \"Convert a JSON string to a Data object\"\r\n    icon = \"braces\"\r\n    name = \"JSONtoData\"\r\n    legacy = True\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"json_string\",\r\n            display_name=\"JSON String\",\r\n            info=\"Enter a valid JSON string to convert to a Data object\",\r\n        ),\r\n    ]\r\n    outputs = [\r\n        Output(name=\"data\", display_name=\"Data\", method=\"convert_json_to_data\"),\r\n    ]\r\n\r\n    def convert_json_to_data(self) -> Data:\r\n        if not self.json_string:\r\n            msg = \"Please provide a JSON string.\"\r\n            self.status = msg\r\n            raise ValueError(msg)\r\n        \r\n        try:\r\n            # Try to parse the JSON string\r\n            try:\r\n                parsed_data = json.loads(self.json_string)\r\n            except json.JSONDecodeError:\r\n                # If JSON parsing fails, try to repair the JSON string\r\n                repaired_json_string = repair_json(self.json_string)\r\n                parsed_data = json.loads(repaired_json_string)\r\n            \r\n            # Convert the parsed data to a Data object\r\n            # If it's a list, we'll use the first item or merge them, depending on use case\r\n            if isinstance(parsed_data, list):\r\n                # Option 1: Use first item in the list\r\n                # result = Data(data=parsed_data[0])\r\n                \r\n                # Option 2: Keep the entire list as the data\r\n                result = Data(data=parsed_data)\r\n            else:\r\n                result = Data(data=parsed_data)\r\n            \r\n            self.status = result\r\n            return result\r\n            \r\n        except (json.JSONDecodeError, SyntaxError, ValueError) as e:\r\n            error_message = f\"Invalid JSON: {e}\"\r\n            self.status = error_message\r\n            raise ValueError(error_message) from e\r\n        except Exception as e:\r\n            error_message = f\"An error occurred: {e}\"\r\n            self.status = error_message\r\n            raise ValueError(error_message) from e"
              },
              "json_string": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "JSON String",
                "dynamic": false,
                "info": "Enter a valid JSON string to convert to a Data object",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "json_string",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "JSONtoData"
        },
        "id": "JSONtoData-SWqoH",
        "measured": {
          "height": 228,
          "width": 320
        },
        "position": {
          "x": 4121.759520993622,
          "y": 2052.4202426783786
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "MultiTemplateParserComponent-FbtVx",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Format a DataFrame or Data object into text using multiple templates. Outputs parsed results for each template separately.",
            "display_name": "Multi-Template Parser",
            "documentation": "",
            "edited": true,
            "field_order": [
              "mode",
              "template_1",
              "template_2",
              "template_3",
              "input_data",
              "sep"
            ],
            "frozen": false,
            "icon": "brackets",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "official": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Result 1",
                "hidden": false,
                "method": "get_result_1",
                "name": "result_1",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Result 2",
                "hidden": false,
                "method": "get_result_2",
                "name": "result_2",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Result 3",
                "hidden": false,
                "method": "get_result_3",
                "name": "result_3",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\r\nfrom typing import Any, List, Optional\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    BoolInput,\r\n    HandleInput,\r\n    MessageTextInput,\r\n    MultilineInput,\r\n    Output,\r\n    TabInput,\r\n)\r\nfrom langflow.schema import Data, DataFrame\r\nfrom langflow.schema.message import Message\r\n\r\n\r\nclass MultiTemplateParserComponent(Component):\r\n    display_name = \"Multi-Template Parser\"\r\n    description = (\r\n        \"Format a DataFrame or Data object into text using multiple templates. \"\r\n        \"Outputs parsed results for each template separately.\"\r\n    )\r\n    icon = \"brackets\"\r\n\r\n    inputs = [\r\n        TabInput(\r\n            name=\"mode\",\r\n            display_name=\"Mode\",\r\n            options=[\"Parser\", \"Stringify\"],\r\n            value=\"Parser\",\r\n            info=\"Convert into raw string instead of using templates.\",\r\n            real_time_refresh=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template_1\",\r\n            display_name=\"Template 1\",\r\n            info=(\r\n                \"Use variables within curly brackets to extract column values for DataFrames \"\r\n                \"or key values for Data.\"\r\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\r\n            ),\r\n            value=\"Text: {text}\",  # Example default\r\n            dynamic=True,\r\n            show=True,\r\n            required=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template_2\",\r\n            display_name=\"Template 2\",\r\n            info=(\r\n                \"Second template pattern for extraction. \"\r\n                \"For example: `{Name} is {Age} years old and from {Country}`\"\r\n            ),\r\n            value=\"Summary: {summary}\",  # Example default\r\n            dynamic=True,\r\n            show=True,\r\n            required=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template_3\",\r\n            display_name=\"Template 3\",\r\n            info=(\r\n                \"Third template pattern for extraction. \"\r\n                \"For example: `{Country}: {Name} ({Age})`\"\r\n            ),\r\n            value=\"ID: {id}\",  # Example default\r\n            dynamic=True,\r\n            show=True,\r\n            required=True,\r\n        ),\r\n        HandleInput(\r\n            name=\"input_data\",\r\n            display_name=\"Data or DataFrame\",\r\n            input_types=[\"DataFrame\", \"Data\"],\r\n            info=\"Accepts either a DataFrame or a Data object.\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"sep\",\r\n            display_name=\"Separator\",\r\n            advanced=True,\r\n            value=\"\\n\",\r\n            info=\"String used to separate rows/items.\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            display_name=\"Result 1\",\r\n            name=\"result_1\",\r\n            info=\"Formatted text output using Template 1.\",\r\n            method=\"get_result_1\",\r\n        ),\r\n        Output(\r\n            display_name=\"Result 2\",\r\n            name=\"result_2\",\r\n            info=\"Formatted text output using Template 2.\",\r\n            method=\"get_result_2\",\r\n        ),\r\n        Output(\r\n            display_name=\"Result 3\",\r\n            name=\"result_3\",\r\n            info=\"Formatted text output using Template 3.\",\r\n            method=\"get_result_3\",\r\n        ),\r\n    ]\r\n\r\n    def update_build_config(self, build_config, field_value, field_name=None):\r\n        \"\"\"Dynamically hide/show templates and enforce requirements based on mode.\"\"\"\r\n        if field_name == \"mode\":\r\n            # Show/hide templates based on mode\r\n            show_templates = self.mode == \"Parser\"\r\n            for i in range(1, 4):\r\n                template_key = f\"template_{i}\"\r\n                if template_key in build_config:\r\n                    build_config[template_key][\"show\"] = show_templates\r\n                    build_config[template_key][\"required\"] = show_templates\r\n            \r\n            # Add clean_data option for stringify mode\r\n            if field_value and self.mode == \"Stringify\":\r\n                clean_data = BoolInput(\r\n                    name=\"clean_data\",\r\n                    display_name=\"Clean Data\",\r\n                    info=(\r\n                        \"Enable to clean the data by removing empty rows and lines \"\r\n                        \"in each cell of the DataFrame/ Data object.\"\r\n                    ),\r\n                    value=True,\r\n                    advanced=True,\r\n                    required=False,\r\n                )\r\n                build_config[\"clean_data\"] = clean_data.to_dict()\r\n            else:\r\n                build_config.pop(\"clean_data\", None)\r\n\r\n        return build_config\r\n\r\n    def _clean_args(self):\r\n        \"\"\"Prepare arguments based on input type.\"\"\"\r\n        input_data = self.input_data\r\n\r\n        match input_data:\r\n            case list() if all(isinstance(item, Data) for item in input_data):\r\n                msg = \"List of Data objects is not supported.\"\r\n                raise ValueError(msg)\r\n            case DataFrame():\r\n                return input_data, None\r\n            case Data():\r\n                return None, input_data\r\n            case dict() if \"data\" in input_data:\r\n                try:\r\n                    if \"columns\" in input_data:  # Likely a DataFrame\r\n                        return DataFrame.from_dict(input_data), None\r\n                    # Likely a Data object\r\n                    return None, Data(**input_data)\r\n                except (TypeError, ValueError, KeyError) as e:\r\n                    msg = f\"Invalid structured input provided: {e!s}\"\r\n                    raise ValueError(msg) from e\r\n            case _:\r\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\r\n                raise ValueError(msg)\r\n\r\n    def _parse_with_template(self, template: str) -> str:\r\n        \"\"\"Parse all rows/items using the specified template.\"\"\"\r\n        # Early return for stringify option\r\n        if self.mode == \"Stringify\":\r\n            return self._convert_to_string()\r\n\r\n        df, data = self._clean_args()\r\n\r\n        lines = []\r\n        try:\r\n            if df is not None:\r\n                for _, row in df.iterrows():\r\n                    try:\r\n                        formatted_text = template.format(**row.to_dict())\r\n                        lines.append(formatted_text)\r\n                    except KeyError as key_error:\r\n                        self.log(f\"Warning: Key {key_error} not found in DataFrame row.\")\r\n                        # Skip this row or add placeholder\r\n                        continue\r\n            elif data is not None:\r\n                try:\r\n                    formatted_text = template.format(**data.data)\r\n                    lines.append(formatted_text)\r\n                except KeyError as key_error:\r\n                    self.log(f\"Warning: Key {key_error} not found in Data object.\")\r\n                    # Return empty or placeholder\r\n                    return f\"Missing key(s) in data: {key_error}\"\r\n        except Exception as e:\r\n            self.log(f\"Error during template parsing: {e}\")\r\n            return f\"Error: {str(e)}\"\r\n\r\n        return self.sep.join(lines)\r\n\r\n    def _safe_convert(self, data: Any) -> str:\r\n        \"\"\"Safely convert input data to string.\"\"\"\r\n        try:\r\n            if isinstance(data, str):\r\n                return data\r\n            if isinstance(data, Message):\r\n                return data.get_text()\r\n            if isinstance(data, Data):\r\n                return json.dumps(data.data)\r\n            if isinstance(data, DataFrame):\r\n                if hasattr(self, \"clean_data\") and self.clean_data:\r\n                    # Remove empty rows\r\n                    data = data.dropna(how=\"all\")\r\n                    # Remove empty lines in each cell\r\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\r\n                    # Replace multiple newlines with a single newline\r\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\r\n                return data.to_markdown(index=False)\r\n            return str(data)\r\n        except (ValueError, TypeError, AttributeError) as e:\r\n            msg = f\"Error converting data: {e!s}\"\r\n            raise ValueError(msg) from e\r\n\r\n    def _convert_to_string(self) -> str:\r\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\r\n        if isinstance(self.input_data, list):\r\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\r\n        else:\r\n            result = self._safe_convert(self.input_data)\r\n        self.log(f\"Converted to string with length: {len(result)}\")\r\n        return result\r\n\r\n    def get_result_1(self) -> Message:\r\n        \"\"\"Return the result parsed using template 1.\"\"\"\r\n        if self.mode == \"Parser\":\r\n            result = self._parse_with_template(self.template_1)\r\n        else:  # Stringify mode\r\n            result = self._convert_to_string()\r\n        \r\n        self.status = f\"Template 1 processed with {len(result)} characters\"\r\n        return Message(text=result)\r\n\r\n    def get_result_2(self) -> Message:\r\n        \"\"\"Return the result parsed using template 2.\"\"\"\r\n        if self.mode == \"Parser\":\r\n            result = self._parse_with_template(self.template_2)\r\n        else:  # Stringify mode\r\n            result = self._convert_to_string()\r\n        \r\n        self.status = f\"Template 2 processed with {len(result)} characters\"\r\n        return Message(text=result)\r\n\r\n    def get_result_3(self) -> Message:\r\n        \"\"\"Return the result parsed using template 3.\"\"\"\r\n        if self.mode == \"Parser\":\r\n            result = self._parse_with_template(self.template_3)\r\n        else:  # Stringify mode\r\n            result = self._convert_to_string()\r\n        \r\n        self.status = f\"Template 3 processed with {len(result)} characters\"\r\n        return Message(text=result)"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using templates.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              },
              "template_1": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template 1",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template_1",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{search_queries[0]}"
              },
              "template_2": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template 2",
                "dynamic": true,
                "info": "Second template pattern for extraction. For example: `{Name} is {Age} years old and from {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template_2",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{search_queries[1]}"
              },
              "template_3": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template 3",
                "dynamic": true,
                "info": "Third template pattern for extraction. For example: `{Country}: {Name} ({Age})`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template_3",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{search_queries[2]}"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "MultiTemplateParserComponent"
        },
        "id": "MultiTemplateParserComponent-FbtVx",
        "measured": {
          "height": 407,
          "width": 320
        },
        "position": {
          "x": 4597.638858604995,
          "y": 2013.9412224891723
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "AstraDB-jm2uO",
          "node": {
            "base_classes": [
              "Data",
              "DataFrame",
              "VectorStore"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Ingest and search documents in Astra DB with 3 Search Queries",
            "display_name": "Astra DB * 3",
            "documentation": "https://docs.datastax.com/en/langflow/astra-components.html",
            "edited": true,
            "field_order": [
              "search_query_2",
              "search_query_3",
              "deduplicate_results",
              "token",
              "environment",
              "database_name",
              "api_endpoint",
              "keyspace",
              "collection_name",
              "embedding_model",
              "ingest_data",
              "search_query",
              "should_cache_vector_store",
              "search_method",
              "reranker",
              "lexical_terms",
              "number_of_results",
              "search_type",
              "search_score_threshold",
              "advanced_search_filter",
              "autodetect_collection",
              "content_field",
              "deletion_field",
              "ignore_invalid_documents",
              "astradb_vectorstore_kwargs"
            ],
            "frozen": false,
            "icon": "AstraDB",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "official": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Search Results",
                "hidden": false,
                "method": "search_documents",
                "name": "search_results",
                "options": null,
                "required_inputs": [
                  "collection_name",
                  "database_name",
                  "embedding_model",
                  "token"
                ],
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": null,
                "method": "as_dataframe",
                "name": "dataframe",
                "options": null,
                "required_inputs": [],
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Vector Store Connection",
                "hidden": true,
                "method": "as_vector_store",
                "name": "vectorstoreconnection",
                "options": null,
                "required_inputs": null,
                "selected": "VectorStore",
                "tool_mode": true,
                "types": [
                  "VectorStore"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "advanced_search_filter": {
                "_input_type": "NestedDictInput",
                "advanced": true,
                "display_name": "Search Metadata Filter",
                "dynamic": false,
                "info": "Optional dictionary of filters to apply to the search query.",
                "list": false,
                "list_add_label": "Add More",
                "name": "advanced_search_filter",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "NestedDict",
                "value": {}
              },
              "api_endpoint": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Astra DB API Endpoint",
                "dynamic": false,
                "info": "The API Endpoint for the Astra DB instance. Supercedes database selection.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "api_endpoint",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "https://6feab22e-d3d5-4e4a-b788-cd5f2bbd2b7a-us-east-2.apps.astra.datastax.com"
              },
              "astradb_vectorstore_kwargs": {
                "_input_type": "NestedDictInput",
                "advanced": true,
                "display_name": "AstraDBVectorStore Parameters",
                "dynamic": false,
                "info": "Optional dictionary of additional parameters for the AstraDBVectorStore.",
                "list": false,
                "list_add_label": "Add More",
                "name": "astradb_vectorstore_kwargs",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "NestedDict",
                "value": {}
              },
              "autodetect_collection": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Autodetect Collection",
                "dynamic": false,
                "info": "Boolean flag to determine whether to autodetect the collection.",
                "list": false,
                "list_add_label": "Add More",
                "name": "autodetect_collection",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import re\r\nfrom collections import defaultdict\r\nfrom dataclasses import asdict, dataclass, field\r\n\r\nfrom astrapy import DataAPIClient, Database\r\nfrom astrapy.data.info.reranking import RerankServiceOptions\r\nfrom astrapy.info import CollectionDescriptor, CollectionLexicalOptions, CollectionRerankOptions\r\nfrom langchain_astradb import AstraDBVectorStore, VectorServiceOptions\r\nfrom langchain_astradb.utils.astradb import HybridSearchMode, _AstraDBCollectionEnvironment\r\n\r\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\r\nfrom langflow.base.vectorstores.vector_store_connection_decorator import vector_store_connection\r\nfrom langflow.helpers import docs_to_data\r\nfrom langflow.inputs import FloatInput, NestedDictInput\r\nfrom langflow.io import (\r\n    BoolInput,\r\n    DropdownInput,\r\n    HandleInput,\r\n    IntInput,\r\n    QueryInput,\r\n    SecretStrInput,\r\n    StrInput,\r\n    MultilineInput,\r\n)\r\nfrom langflow.schema import Data\r\nfrom langflow.utils.version import get_version_info\r\nfrom itertools import chain\r\nfrom typing import List, Optional, Union\r\n\r\n\r\n@vector_store_connection\r\nclass AstraDBVectorStoreComponent(LCVectorStoreComponent):\r\n    display_name: str = \"Astra DB\"\r\n    description: str = \"Ingest and search documents in Astra DB\"\r\n    documentation: str = \"https://docs.datastax.com/en/langflow/astra-components.html\"\r\n    name = \"AstraDB\"\r\n    icon: str = \"AstraDB\"\r\n\r\n    _cached_vector_store: AstraDBVectorStore | None = None\r\n\r\n    @dataclass\r\n    class NewDatabaseInput:\r\n        functionality: str = \"create\"\r\n        fields: dict[str, dict] = field(\r\n            default_factory=lambda: {\r\n                \"data\": {\r\n                    \"node\": {\r\n                        \"name\": \"create_database\",\r\n                        \"description\": \"Please allow several minutes for creation to complete.\",\r\n                        \"display_name\": \"Create new database\",\r\n                        \"field_order\": [\"01_new_database_name\", \"02_cloud_provider\", \"03_region\"],\r\n                        \"template\": {\r\n                            \"01_new_database_name\": StrInput(\r\n                                name=\"new_database_name\",\r\n                                display_name=\"Name\",\r\n                                info=\"Name of the new database to create in Astra DB.\",\r\n                                required=True,\r\n                            ),\r\n                            \"02_cloud_provider\": DropdownInput(\r\n                                name=\"cloud_provider\",\r\n                                display_name=\"Cloud provider\",\r\n                                info=\"Cloud provider for the new database.\",\r\n                                options=[],\r\n                                required=True,\r\n                                real_time_refresh=True,\r\n                            ),\r\n                            \"03_region\": DropdownInput(\r\n                                name=\"region\",\r\n                                display_name=\"Region\",\r\n                                info=\"Region for the new database.\",\r\n                                options=[],\r\n                                required=True,\r\n                            ),\r\n                        },\r\n                    },\r\n                }\r\n            }\r\n        )\r\n\r\n    @dataclass\r\n    class NewCollectionInput:\r\n        functionality: str = \"create\"\r\n        fields: dict[str, dict] = field(\r\n            default_factory=lambda: {\r\n                \"data\": {\r\n                    \"node\": {\r\n                        \"name\": \"create_collection\",\r\n                        \"description\": \"Please allow several seconds for creation to complete.\",\r\n                        \"display_name\": \"Create new collection\",\r\n                        \"field_order\": [\r\n                            \"01_new_collection_name\",\r\n                            \"02_embedding_generation_provider\",\r\n                            \"03_embedding_generation_model\",\r\n                            \"04_dimension\",\r\n                        ],\r\n                        \"template\": {\r\n                            \"01_new_collection_name\": StrInput(\r\n                                name=\"new_collection_name\",\r\n                                display_name=\"Name\",\r\n                                info=\"Name of the new collection to create in Astra DB.\",\r\n                                required=True,\r\n                            ),\r\n                            \"02_embedding_generation_provider\": DropdownInput(\r\n                                name=\"embedding_generation_provider\",\r\n                                display_name=\"Embedding generation method\",\r\n                                info=\"Provider to use for generating embeddings.\",\r\n                                helper_text=(\r\n                                    \"To create collections with more embedding provider options, go to \"\r\n                                    '<a class=\"underline\" href=\"https://astra.datastax.com/\" target=\" _blank\" '\r\n                                    'rel=\"noopener noreferrer\">your database in Astra DB</a>'\r\n                                ),\r\n                                real_time_refresh=True,\r\n                                required=True,\r\n                                options=[],\r\n                            ),\r\n                            \"03_embedding_generation_model\": DropdownInput(\r\n                                name=\"embedding_generation_model\",\r\n                                display_name=\"Embedding model\",\r\n                                info=\"Model to use for generating embeddings.\",\r\n                                real_time_refresh=True,\r\n                                options=[],\r\n                            ),\r\n                            \"04_dimension\": IntInput(\r\n                                name=\"dimension\",\r\n                                display_name=\"Dimensions\",\r\n                                info=\"Dimensions of the embeddings to generate.\",\r\n                                value=None,\r\n                            ),\r\n                        },\r\n                    },\r\n                }\r\n            }\r\n        )\r\n\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"search_query_2\",\r\n            display_name=\"Second Search Query\",\r\n            info=\"Second query to search for in the vector database.\",\r\n            advanced=False,\r\n        ),\r\n        MultilineInput(\r\n            name=\"search_query_3\",\r\n            display_name=\"Third Search Query\",\r\n            info=\"Third query to search for in the vector database.\",\r\n            advanced=False,\r\n        ),\r\n        BoolInput(\r\n            name=\"deduplicate_results\",\r\n            display_name=\"Deduplicate Results\",\r\n            info=\"Remove duplicate documents from the combined search results.\",\r\n            advanced=True,\r\n            value=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"token\",\r\n            display_name=\"Astra DB Application Token\",\r\n            info=\"Authentication token for accessing Astra DB.\",\r\n            value=\"ASTRA_DB_APPLICATION_TOKEN\",\r\n            required=True,\r\n            real_time_refresh=True,\r\n            input_types=[],\r\n        ),\r\n        DropdownInput(\r\n            name=\"environment\",\r\n            display_name=\"Environment\",\r\n            info=\"The environment for the Astra DB API Endpoint.\",\r\n            options=[\"prod\", \"test\", \"dev\"],\r\n            value=\"prod\",\r\n            advanced=True,\r\n            real_time_refresh=True,\r\n            combobox=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"database_name\",\r\n            display_name=\"Database\",\r\n            info=\"The Database name for the Astra DB instance.\",\r\n            required=True,\r\n            refresh_button=True,\r\n            real_time_refresh=True,\r\n            dialog_inputs=asdict(NewDatabaseInput()),\r\n            combobox=True,\r\n        ),\r\n        StrInput(\r\n            name=\"api_endpoint\",\r\n            display_name=\"Astra DB API Endpoint\",\r\n            info=\"The API Endpoint for the Astra DB instance. Supercedes database selection.\",\r\n            show=False,\r\n        ),\r\n        DropdownInput(\r\n            name=\"keyspace\",\r\n            display_name=\"Keyspace\",\r\n            info=\"Optional keyspace within Astra DB to use for the collection.\",\r\n            advanced=True,\r\n            options=[],\r\n            real_time_refresh=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"collection_name\",\r\n            display_name=\"Collection\",\r\n            info=\"The name of the collection within Astra DB where the vectors will be stored.\",\r\n            required=True,\r\n            refresh_button=True,\r\n            real_time_refresh=True,\r\n            dialog_inputs=asdict(NewCollectionInput()),\r\n            combobox=True,\r\n            show=True,\r\n        ),\r\n        HandleInput(\r\n            name=\"embedding_model\",\r\n            display_name=\"Embedding Model\",\r\n            input_types=[\"Embeddings\"],\r\n            info=\"Specify the Embedding Model. Not required for Astra Vectorize collections.\",\r\n            required=True,\r\n            show=True,\r\n        ),\r\n        *LCVectorStoreComponent.inputs,\r\n        DropdownInput(\r\n            name=\"search_method\",\r\n            display_name=\"Search Method\",\r\n            info=(\r\n                \"Determine how your content is matched: Vector finds semantic similarity, \"\r\n                \"and Hybrid Search (suggested) combines both approaches \"\r\n                \"with a reranker.\"\r\n            ),\r\n            options=[\"Hybrid Search\", \"Vector Search\"],  # TODO: Restore Lexical Search?\r\n            options_metadata=[{\"icon\": \"SearchHybrid\"}, {\"icon\": \"SearchVector\"}],\r\n            value=\"Vector Search\",\r\n            advanced=True,\r\n            real_time_refresh=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"reranker\",\r\n            display_name=\"Reranker\",\r\n            info=\"Post-retrieval model that re-scores results for optimal relevance ranking.\",\r\n            show=False,\r\n            toggle=True,\r\n        ),\r\n        QueryInput(\r\n            name=\"lexical_terms\",\r\n            display_name=\"Lexical Terms\",\r\n            info=\"Add additional terms/keywords to augment search precision.\",\r\n            placeholder=\"Enter terms to search...\",\r\n            separator=\" \",\r\n            show=False,\r\n            value=\"\",\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"number_of_results\",\r\n            display_name=\"Number of Search Results\",\r\n            info=\"Number of search results to return.\",\r\n            advanced=True,\r\n            value=4,\r\n        ),\r\n        DropdownInput(\r\n            name=\"search_type\",\r\n            display_name=\"Search Type\",\r\n            info=\"Search type to use\",\r\n            options=[\"Similarity\", \"Similarity with score threshold\", \"MMR (Max Marginal Relevance)\"],\r\n            value=\"Similarity\",\r\n            advanced=True,\r\n        ),\r\n        FloatInput(\r\n            name=\"search_score_threshold\",\r\n            display_name=\"Search Score Threshold\",\r\n            info=\"Minimum similarity score threshold for search results. \"\r\n            \"(when using 'Similarity with score threshold')\",\r\n            value=0,\r\n            advanced=True,\r\n        ),\r\n        NestedDictInput(\r\n            name=\"advanced_search_filter\",\r\n            display_name=\"Search Metadata Filter\",\r\n            info=\"Optional dictionary of filters to apply to the search query.\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"autodetect_collection\",\r\n            display_name=\"Autodetect Collection\",\r\n            info=\"Boolean flag to determine whether to autodetect the collection.\",\r\n            advanced=True,\r\n            value=True,\r\n        ),\r\n        StrInput(\r\n            name=\"content_field\",\r\n            display_name=\"Content Field\",\r\n            info=\"Field to use as the text content field for the vector store.\",\r\n            advanced=True,\r\n        ),\r\n        StrInput(\r\n            name=\"deletion_field\",\r\n            display_name=\"Deletion Based On Field\",\r\n            info=\"When this parameter is provided, documents in the target collection with \"\r\n            \"metadata field values matching the input metadata field value will be deleted \"\r\n            \"before new data is loaded.\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"ignore_invalid_documents\",\r\n            display_name=\"Ignore Invalid Documents\",\r\n            info=\"Boolean flag to determine whether to ignore invalid documents at runtime.\",\r\n            advanced=True,\r\n        ),\r\n        NestedDictInput(\r\n            name=\"astradb_vectorstore_kwargs\",\r\n            display_name=\"AstraDBVectorStore Parameters\",\r\n            info=\"Optional dictionary of additional parameters for the AstraDBVectorStore.\",\r\n            advanced=True,\r\n        ),\r\n    ]\r\n\r\n    @classmethod\r\n    def map_cloud_providers(cls):\r\n        # TODO: Programmatically fetch the regions for each cloud provider\r\n        return {\r\n            \"dev\": {\r\n                \"Amazon Web Services\": {\r\n                    \"id\": \"aws\",\r\n                    \"regions\": [\"us-west-2\"],\r\n                },\r\n                \"Google Cloud Platform\": {\r\n                    \"id\": \"gcp\",\r\n                    \"regions\": [\"us-central1\", \"europe-west4\"],\r\n                },\r\n            },\r\n            \"test\": {\r\n                \"Google Cloud Platform\": {\r\n                    \"id\": \"gcp\",\r\n                    \"regions\": [\"us-central1\"],\r\n                },\r\n            },\r\n            \"prod\": {\r\n                \"Amazon Web Services\": {\r\n                    \"id\": \"aws\",\r\n                    \"regions\": [\"us-east-2\", \"ap-south-1\", \"eu-west-1\"],\r\n                },\r\n                \"Google Cloud Platform\": {\r\n                    \"id\": \"gcp\",\r\n                    \"regions\": [\"us-east1\"],\r\n                },\r\n                \"Microsoft Azure\": {\r\n                    \"id\": \"azure\",\r\n                    \"regions\": [\"westus3\"],\r\n                },\r\n            },\r\n        }\r\n\r\n    @classmethod\r\n    def get_vectorize_providers(cls, token: str, environment: str | None = None, api_endpoint: str | None = None):\r\n        try:\r\n            # Get the admin object\r\n            client = DataAPIClient(environment=environment)\r\n            admin_client = client.get_admin()\r\n            db_admin = admin_client.get_database_admin(api_endpoint, token=token)\r\n\r\n            # Get the list of embedding providers\r\n            embedding_providers = db_admin.find_embedding_providers()\r\n\r\n            vectorize_providers_mapping = {}\r\n            # Map the provider display name to the provider key and models\r\n            for provider_key, provider_data in embedding_providers.embedding_providers.items():\r\n                # Get the provider display name and models\r\n                display_name = provider_data.display_name\r\n                models = [model.name for model in provider_data.models]\r\n\r\n                # Build our mapping\r\n                vectorize_providers_mapping[display_name] = [provider_key, models]\r\n\r\n            # Sort the resulting dictionary\r\n            return defaultdict(list, dict(sorted(vectorize_providers_mapping.items())))\r\n        except Exception as _:  # noqa: BLE001\r\n            return {}\r\n\r\n    @classmethod\r\n    async def create_database_api(\r\n        cls,\r\n        new_database_name: str,\r\n        cloud_provider: str,\r\n        region: str,\r\n        token: str,\r\n        environment: str | None = None,\r\n        keyspace: str | None = None,\r\n    ):\r\n        client = DataAPIClient(environment=environment)\r\n\r\n        # Get the admin object\r\n        admin_client = client.get_admin(token=token)\r\n\r\n        # Get the environment, set to prod if null like\r\n        my_env = environment or \"prod\"\r\n\r\n        # Raise a value error if name isn't provided\r\n        if not new_database_name:\r\n            msg = \"Database name is required to create a new database.\"\r\n            raise ValueError(msg)\r\n\r\n        # Call the create database function\r\n        return await admin_client.async_create_database(\r\n            name=new_database_name,\r\n            cloud_provider=cls.map_cloud_providers()[my_env][cloud_provider][\"id\"],\r\n            region=region,\r\n            keyspace=keyspace,\r\n            wait_until_active=False,\r\n        )\r\n\r\n    @classmethod\r\n    async def create_collection_api(\r\n        cls,\r\n        new_collection_name: str,\r\n        token: str,\r\n        api_endpoint: str,\r\n        environment: str | None = None,\r\n        keyspace: str | None = None,\r\n        dimension: int | None = None,\r\n        embedding_generation_provider: str | None = None,\r\n        embedding_generation_model: str | None = None,\r\n        reranker: str | None = None,\r\n    ):\r\n        # Build vectorize options, if needed\r\n        vectorize_options = None\r\n        if not dimension:\r\n            providers = cls.get_vectorize_providers(token=token, environment=environment, api_endpoint=api_endpoint)\r\n            vectorize_options = VectorServiceOptions(\r\n                provider=providers.get(embedding_generation_provider, [None, []])[0],\r\n                model_name=embedding_generation_model,\r\n            )\r\n\r\n        # Raise a value error if name isn't provided\r\n        if not new_collection_name:\r\n            msg = \"Collection name is required to create a new collection.\"\r\n            raise ValueError(msg)\r\n\r\n        # Define the base arguments being passed to the create collection function\r\n        base_args = {\r\n            \"collection_name\": new_collection_name,\r\n            \"token\": token,\r\n            \"api_endpoint\": api_endpoint,\r\n            \"keyspace\": keyspace,\r\n            \"environment\": environment,\r\n            \"embedding_dimension\": dimension,\r\n            \"collection_vector_service_options\": vectorize_options,\r\n        }\r\n\r\n        # Add optional arguments only if environment is \"dev\"\r\n        if environment == \"dev\" and reranker:  # TODO: Remove conditional check soon\r\n            # Split the reranker field into a provider a model name\r\n            provider, _ = reranker.split(\"/\")\r\n            base_args[\"collection_rerank\"] = CollectionRerankOptions(\r\n                service=RerankServiceOptions(provider=provider, model_name=reranker),\r\n            )\r\n            base_args[\"collection_lexical\"] = CollectionLexicalOptions(analyzer=\"STANDARD\")\r\n\r\n        _AstraDBCollectionEnvironment(**base_args)\r\n\r\n    @classmethod\r\n    def get_database_list_static(cls, token: str, environment: str | None = None):\r\n        client = DataAPIClient(environment=environment)\r\n\r\n        # Get the admin object\r\n        admin_client = client.get_admin(token=token)\r\n\r\n        # Get the list of databases\r\n        db_list = admin_client.list_databases()\r\n\r\n        # Generate the api endpoint for each database\r\n        db_info_dict = {}\r\n        for db in db_list:\r\n            try:\r\n                # Get the API endpoint for the database\r\n                api_endpoint = db.regions[0].api_endpoint\r\n\r\n                # Get the number of collections\r\n                try:\r\n                    # Get the number of collections in the database\r\n                    num_collections = len(\r\n                        client.get_database(\r\n                            api_endpoint,\r\n                            token=token,\r\n                        ).list_collection_names()\r\n                    )\r\n                except Exception:  # noqa: BLE001\r\n                    if db.status != \"PENDING\":\r\n                        continue\r\n                    num_collections = 0\r\n\r\n                # Add the database to the dictionary\r\n                db_info_dict[db.name] = {\r\n                    \"api_endpoint\": api_endpoint,\r\n                    \"keyspaces\": db.keyspaces,\r\n                    \"collections\": num_collections,\r\n                    \"status\": db.status if db.status != \"ACTIVE\" else None,\r\n                    \"org_id\": db.org_id if db.org_id else None,\r\n                }\r\n            except Exception:  # noqa: BLE001, S110\r\n                pass\r\n\r\n        return db_info_dict\r\n\r\n    def get_database_list(self):\r\n        return self.get_database_list_static(\r\n            token=self.token,\r\n            environment=self.environment,\r\n        )\r\n\r\n    @classmethod\r\n    def get_api_endpoint_static(\r\n        cls,\r\n        token: str,\r\n        environment: str | None = None,\r\n        api_endpoint: str | None = None,\r\n        database_name: str | None = None,\r\n    ):\r\n        # If the api_endpoint is set, return it\r\n        if api_endpoint:\r\n            return api_endpoint\r\n\r\n        # Check if the database_name is like a url\r\n        if database_name and database_name.startswith(\"https://\"):\r\n            return database_name\r\n\r\n        # If the database is not set, nothing we can do.\r\n        if not database_name:\r\n            return None\r\n\r\n        # Grab the database object\r\n        db = cls.get_database_list_static(token=token, environment=environment).get(database_name)\r\n        if not db:\r\n            return None\r\n\r\n        # Otherwise, get the URL from the database list\r\n        return db.get(\"api_endpoint\")\r\n\r\n    def get_api_endpoint(self):\r\n        return self.get_api_endpoint_static(\r\n            token=self.token,\r\n            environment=self.environment,\r\n            api_endpoint=self.api_endpoint,\r\n            database_name=self.database_name,\r\n        )\r\n\r\n    @classmethod\r\n    def get_database_id_static(cls, api_endpoint: str) -> str | None:\r\n        # Pattern matches standard UUID format: 8-4-4-4-12 hexadecimal characters\r\n        uuid_pattern = r\"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\r\n        match = re.search(uuid_pattern, api_endpoint)\r\n\r\n        return match.group(0) if match else None\r\n\r\n    def get_database_id(self):\r\n        return self.get_database_id_static(api_endpoint=self.get_api_endpoint())\r\n\r\n    def get_keyspace(self):\r\n        keyspace = self.keyspace\r\n\r\n        if keyspace:\r\n            return keyspace.strip()\r\n\r\n        return \"default_keyspace\"\r\n\r\n    def get_database_object(self, api_endpoint: str | None = None):\r\n        try:\r\n            client = DataAPIClient(environment=self.environment)\r\n\r\n            return client.get_database(\r\n                api_endpoint or self.get_api_endpoint(),\r\n                token=self.token,\r\n                keyspace=self.get_keyspace(),\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error fetching database object: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n    def collection_data(self, collection_name: str, database: Database | None = None):\r\n        try:\r\n            if not database:\r\n                client = DataAPIClient(environment=self.environment)\r\n\r\n                database = client.get_database(\r\n                    self.get_api_endpoint(),\r\n                    token=self.token,\r\n                    keyspace=self.get_keyspace(),\r\n                )\r\n\r\n            collection = database.get_collection(collection_name)\r\n\r\n            return collection.estimated_document_count()\r\n        except Exception as e:  # noqa: BLE001\r\n            self.log(f\"Error checking collection data: {e}\")\r\n\r\n            return None\r\n\r\n    def _initialize_database_options(self):\r\n        try:\r\n            return [\r\n                {\r\n                    \"name\": name,\r\n                    \"status\": info[\"status\"],\r\n                    \"collections\": info[\"collections\"],\r\n                    \"api_endpoint\": info[\"api_endpoint\"],\r\n                    \"keyspaces\": info[\"keyspaces\"],\r\n                    \"org_id\": info[\"org_id\"],\r\n                }\r\n                for name, info in self.get_database_list().items()\r\n            ]\r\n        except Exception as e:\r\n            msg = f\"Error fetching database options: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n    @classmethod\r\n    def get_provider_icon(cls, collection: CollectionDescriptor | None = None, provider_name: str | None = None) -> str:\r\n        # Get the provider name from the collection\r\n        provider_name = provider_name or (\r\n            collection.definition.vector.service.provider\r\n            if (\r\n                collection\r\n                and collection.definition\r\n                and collection.definition.vector\r\n                and collection.definition.vector.service\r\n            )\r\n            else None\r\n        )\r\n\r\n        # If there is no provider, use the vector store icon\r\n        if not provider_name or provider_name.lower() == \"bring your own\":\r\n            return \"vectorstores\"\r\n\r\n        # Map provider casings\r\n        case_map = {\r\n            \"nvidia\": \"NVIDIA\",\r\n            \"openai\": \"OpenAI\",\r\n            \"amazon bedrock\": \"AmazonBedrockEmbeddings\",\r\n            \"azure openai\": \"AzureOpenAiEmbeddings\",\r\n            \"cohere\": \"Cohere\",\r\n            \"jina ai\": \"JinaAI\",\r\n            \"mistral ai\": \"MistralAI\",\r\n            \"upstage\": \"Upstage\",\r\n            \"voyage ai\": \"VoyageAI\",\r\n        }\r\n\r\n        # Adjust the casing on some like nvidia\r\n        return case_map[provider_name.lower()] if provider_name.lower() in case_map else provider_name.title()\r\n\r\n    def _initialize_collection_options(self, api_endpoint: str | None = None):\r\n        # Nothing to generate if we don't have an API endpoint yet\r\n        api_endpoint = api_endpoint or self.get_api_endpoint()\r\n        if not api_endpoint:\r\n            return []\r\n\r\n        # Retrieve the database object\r\n        database = self.get_database_object(api_endpoint=api_endpoint)\r\n\r\n        # Get the list of collections\r\n        collection_list = database.list_collections(keyspace=self.get_keyspace())\r\n\r\n        # Return the list of collections and metadata associated\r\n        return [\r\n            {\r\n                \"name\": col.name,\r\n                \"records\": self.collection_data(collection_name=col.name, database=database),\r\n                \"provider\": (\r\n                    col.definition.vector.service.provider\r\n                    if col.definition.vector and col.definition.vector.service\r\n                    else None\r\n                ),\r\n                \"icon\": self.get_provider_icon(collection=col),\r\n                \"model\": (\r\n                    col.definition.vector.service.model_name\r\n                    if col.definition.vector and col.definition.vector.service\r\n                    else None\r\n                ),\r\n            }\r\n            for col in collection_list\r\n        ]\r\n\r\n    def reset_provider_options(self, build_config: dict) -> dict:\r\n        \"\"\"Reset provider options and related configurations in the build_config dictionary.\"\"\"\r\n        # Extract template path for cleaner access\r\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n\r\n        # Get vectorize providers\r\n        vectorize_providers_api = self.get_vectorize_providers(\r\n            token=self.token,\r\n            environment=self.environment,\r\n            api_endpoint=build_config[\"api_endpoint\"][\"value\"],\r\n        )\r\n\r\n        # Create a new dictionary with \"Bring your own\" first\r\n        vectorize_providers: dict[str, list[list[str]]] = {\"Bring your own\": [[], []]}\r\n\r\n        # Add the remaining items (only Nvidia) from the original dictionary\r\n        vectorize_providers.update(\r\n            {\r\n                k: v\r\n                for k, v in vectorize_providers_api.items()\r\n                if k.lower() in [\"nvidia\"]  # TODO: Eventually support more\r\n            }\r\n        )\r\n\r\n        # Set provider options\r\n        provider_field = \"02_embedding_generation_provider\"\r\n        template[provider_field][\"options\"] = list(vectorize_providers.keys())\r\n\r\n        # Add metadata for each provider option\r\n        template[provider_field][\"options_metadata\"] = [\r\n            {\"icon\": self.get_provider_icon(provider_name=provider)} for provider in template[provider_field][\"options\"]\r\n        ]\r\n\r\n        # Get selected embedding provider\r\n        embedding_provider = template[provider_field][\"value\"]\r\n        is_bring_your_own = embedding_provider and embedding_provider == \"Bring your own\"\r\n\r\n        # Configure embedding model field\r\n        model_field = \"03_embedding_generation_model\"\r\n        template[model_field].update(\r\n            {\r\n                \"options\": vectorize_providers.get(embedding_provider, [[], []])[1],\r\n                \"placeholder\": \"Bring your own\" if is_bring_your_own else None,\r\n                \"readonly\": is_bring_your_own,\r\n                \"required\": not is_bring_your_own,\r\n                \"value\": None,\r\n            }\r\n        )\r\n\r\n        # If this is a bring your own, set dimensions to 0\r\n        return self.reset_dimension_field(build_config)\r\n\r\n    def reset_dimension_field(self, build_config: dict) -> dict:\r\n        \"\"\"Reset dimension field options based on provided configuration.\"\"\"\r\n        # Extract template path for cleaner access\r\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n\r\n        # Get selected embedding model\r\n        provider_field = \"02_embedding_generation_provider\"\r\n        embedding_provider = template[provider_field][\"value\"]\r\n        is_bring_your_own = embedding_provider and embedding_provider == \"Bring your own\"\r\n\r\n        # Configure dimension field\r\n        dimension_field = \"04_dimension\"\r\n        dimension_value = 1024 if not is_bring_your_own else None  # TODO: Dynamically figure this out\r\n        template[dimension_field].update(\r\n            {\r\n                \"placeholder\": dimension_value,\r\n                \"value\": dimension_value,\r\n                \"readonly\": not is_bring_your_own,\r\n                \"required\": is_bring_your_own,\r\n            }\r\n        )\r\n\r\n        return build_config\r\n\r\n    def reset_collection_list(self, build_config: dict) -> dict:\r\n        \"\"\"Reset collection list options based on provided configuration.\"\"\"\r\n        # Get collection options\r\n        collection_options = self._initialize_collection_options(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\r\n        # Update collection configuration\r\n        collection_config = build_config[\"collection_name\"]\r\n        collection_config.update(\r\n            {\r\n                \"options\": [col[\"name\"] for col in collection_options],\r\n                \"options_metadata\": [{k: v for k, v in col.items() if k != \"name\"} for col in collection_options],\r\n            }\r\n        )\r\n\r\n        # Reset selected collection if not in options\r\n        if collection_config[\"value\"] not in collection_config[\"options\"]:\r\n            collection_config[\"value\"] = \"\"\r\n\r\n        # Set advanced status based on database selection\r\n        collection_config[\"show\"] = bool(build_config[\"database_name\"][\"value\"])\r\n\r\n        return build_config\r\n\r\n    def reset_database_list(self, build_config: dict) -> dict:\r\n        \"\"\"Reset database list options and related configurations.\"\"\"\r\n        # Get database options\r\n        database_options = self._initialize_database_options()\r\n\r\n        # Update cloud provider options\r\n        env = self.environment\r\n        template = build_config[\"database_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n        template[\"02_cloud_provider\"][\"options\"] = list(self.map_cloud_providers()[env].keys())\r\n\r\n        # Update database configuration\r\n        database_config = build_config[\"database_name\"]\r\n        database_config.update(\r\n            {\r\n                \"options\": [db[\"name\"] for db in database_options],\r\n                \"options_metadata\": [{k: v for k, v in db.items() if k != \"name\"} for db in database_options],\r\n            }\r\n        )\r\n\r\n        # Reset selections if value not in options\r\n        if database_config[\"value\"] not in database_config[\"options\"]:\r\n            database_config[\"value\"] = \"\"\r\n            build_config[\"api_endpoint\"][\"value\"] = \"\"\r\n            build_config[\"collection_name\"][\"show\"] = False\r\n\r\n        # Set advanced status based on token presence\r\n        database_config[\"show\"] = bool(build_config[\"token\"][\"value\"])\r\n\r\n        return build_config\r\n\r\n    def reset_build_config(self, build_config: dict) -> dict:\r\n        \"\"\"Reset all build configuration options to default empty state.\"\"\"\r\n        # Reset database configuration\r\n        database_config = build_config[\"database_name\"]\r\n        database_config.update({\"options\": [], \"options_metadata\": [], \"value\": \"\", \"show\": False})\r\n        build_config[\"api_endpoint\"][\"value\"] = \"\"\r\n\r\n        # Reset collection configuration\r\n        collection_config = build_config[\"collection_name\"]\r\n        collection_config.update({\"options\": [], \"options_metadata\": [], \"value\": \"\", \"show\": False})\r\n\r\n        return build_config\r\n\r\n    def _handle_hybrid_search_options(self, build_config: dict) -> dict:\r\n        \"\"\"Set hybrid search options in the build configuration.\"\"\"\r\n        # Detect what hybrid options are available\r\n        # Get the admin object\r\n        client = DataAPIClient(environment=self.environment)\r\n        admin_client = client.get_admin()\r\n        db_admin = admin_client.get_database_admin(self.get_api_endpoint(), token=self.token)\r\n\r\n        # We will try to get the reranking providers to see if its hybrid emabled\r\n        try:\r\n            providers = db_admin.find_reranking_providers()\r\n            build_config[\"reranker\"][\"options\"] = [\r\n                model.name for provider_data in providers.reranking_providers.values() for model in provider_data.models\r\n            ]\r\n            build_config[\"reranker\"][\"options_metadata\"] = [\r\n                {\"icon\": self.get_provider_icon(provider_name=model.name.split(\"/\")[0])}\r\n                for provider in providers.reranking_providers.values()\r\n                for model in provider.models\r\n            ]\r\n            build_config[\"reranker\"][\"value\"] = build_config[\"reranker\"][\"options\"][0]\r\n\r\n            # Set the default search field to hybrid search\r\n            build_config[\"search_method\"][\"show\"] = True\r\n            build_config[\"search_method\"][\"options\"] = [\"Hybrid Search\", \"Vector Search\"]\r\n            build_config[\"search_method\"][\"value\"] = \"Hybrid Search\"\r\n        except Exception as _:  # noqa: BLE001\r\n            build_config[\"reranker\"][\"options\"] = []\r\n            build_config[\"reranker\"][\"options_metadata\"] = []\r\n\r\n            # Set the default search field to vector search\r\n            build_config[\"search_method\"][\"show\"] = False\r\n            build_config[\"search_method\"][\"options\"] = [\"Vector Search\"]\r\n            build_config[\"search_method\"][\"value\"] = \"Vector Search\"\r\n\r\n        # Set reranker and lexical terms options based on search method\r\n        build_config[\"reranker\"][\"toggle_value\"] = True\r\n        build_config[\"reranker\"][\"show\"] = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\r\n        build_config[\"reranker\"][\"toggle_disable\"] = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\r\n        if build_config[\"reranker\"][\"show\"]:\r\n            build_config[\"search_type\"][\"value\"] = \"Similarity\"\r\n\r\n        return build_config\r\n\r\n    async def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\r\n        \"\"\"Update build configuration based on field name and value.\"\"\"\r\n        # Early return if no token provided\r\n        if not self.token:\r\n            return self.reset_build_config(build_config)\r\n\r\n        # Database creation callback\r\n        if field_name == \"database_name\" and isinstance(field_value, dict):\r\n            if \"01_new_database_name\" in field_value:\r\n                await self._create_new_database(build_config, field_value)\r\n                return self.reset_collection_list(build_config)\r\n            return self._update_cloud_regions(build_config, field_value)\r\n\r\n        # Collection creation callback\r\n        if field_name == \"collection_name\" and isinstance(field_value, dict):\r\n            # Case 1: New collection creation\r\n            if \"01_new_collection_name\" in field_value:\r\n                await self._create_new_collection(build_config, field_value)\r\n                return build_config\r\n\r\n            # Case 2: Update embedding provider options\r\n            if \"02_embedding_generation_provider\" in field_value:\r\n                return self.reset_provider_options(build_config)\r\n\r\n            # Case 3: Update dimension field\r\n            if \"03_embedding_generation_model\" in field_value:\r\n                return self.reset_dimension_field(build_config)\r\n\r\n        # Initial execution or token/environment change\r\n        first_run = field_name == \"collection_name\" and not field_value and not build_config[\"database_name\"][\"options\"]\r\n        if first_run or field_name in {\"token\", \"environment\"}:\r\n            return self.reset_database_list(build_config)\r\n\r\n        # Database selection change\r\n        if field_name == \"database_name\" and not isinstance(field_value, dict):\r\n            return self._handle_database_selection(build_config, field_value)\r\n\r\n        # Keyspace selection change\r\n        if field_name == \"keyspace\":\r\n            return self.reset_collection_list(build_config)\r\n\r\n        # Collection selection change\r\n        if field_name == \"collection_name\" and not isinstance(field_value, dict):\r\n            return self._handle_collection_selection(build_config, field_value)\r\n\r\n        # Search method selection change\r\n        if field_name == \"search_method\":\r\n            is_vector_search = field_value == \"Vector Search\"\r\n            is_autodetect = build_config[\"autodetect_collection\"][\"value\"]\r\n\r\n            # Configure lexical terms (same for both cases)\r\n            build_config[\"lexical_terms\"][\"show\"] = not is_vector_search\r\n            build_config[\"lexical_terms\"][\"value\"] = \"\" if is_vector_search else build_config[\"lexical_terms\"][\"value\"]\r\n\r\n            # Disable reranker disabling if hybrid search is selected\r\n            build_config[\"reranker\"][\"toggle_disable\"] = not is_vector_search\r\n            build_config[\"reranker\"][\"toggle_value\"] = True\r\n            build_config[\"reranker\"][\"value\"] = build_config[\"reranker\"][\"options\"][0]\r\n\r\n            # Toggle search type and score threshold based on search method\r\n            build_config[\"search_type\"][\"show\"] = is_vector_search\r\n            build_config[\"search_score_threshold\"][\"show\"] = is_vector_search\r\n\r\n            # Make sure the search_type is set to \"Similarity\"\r\n            if not is_vector_search or is_autodetect:\r\n                build_config[\"search_type\"][\"value\"] = \"Similarity\"\r\n\r\n        return build_config\r\n\r\n    async def _create_new_database(self, build_config: dict, field_value: dict) -> None:\r\n        \"\"\"Create a new database and update build config options.\"\"\"\r\n        try:\r\n            await self.create_database_api(\r\n                new_database_name=field_value[\"01_new_database_name\"],\r\n                token=self.token,\r\n                keyspace=self.get_keyspace(),\r\n                environment=self.environment,\r\n                cloud_provider=field_value[\"02_cloud_provider\"],\r\n                region=field_value[\"03_region\"],\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error creating database: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n        build_config[\"database_name\"][\"options\"].append(field_value[\"01_new_database_name\"])\r\n        build_config[\"database_name\"][\"options_metadata\"].append(\r\n            {\r\n                \"status\": \"PENDING\",\r\n                \"collections\": 0,\r\n                \"api_endpoint\": None,\r\n                \"keyspaces\": [self.get_keyspace()],\r\n                \"org_id\": None,\r\n            }\r\n        )\r\n\r\n    def _update_cloud_regions(self, build_config: dict, field_value: dict) -> dict:\r\n        \"\"\"Update cloud provider regions in build config.\"\"\"\r\n        env = self.environment\r\n        cloud_provider = field_value[\"02_cloud_provider\"]\r\n\r\n        # Update the region options based on the selected cloud provider\r\n        template = build_config[\"database_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n        template[\"03_region\"][\"options\"] = self.map_cloud_providers()[env][cloud_provider][\"regions\"]\r\n\r\n        # Reset the the 03_region value if it's not in the new options\r\n        if template[\"03_region\"][\"value\"] not in template[\"03_region\"][\"options\"]:\r\n            template[\"03_region\"][\"value\"] = None\r\n\r\n        return build_config\r\n\r\n    async def _create_new_collection(self, build_config: dict, field_value: dict) -> None:\r\n        \"\"\"Create a new collection and update build config options.\"\"\"\r\n        embedding_provider = field_value.get(\"02_embedding_generation_provider\")\r\n        try:\r\n            await self.create_collection_api(\r\n                new_collection_name=field_value[\"01_new_collection_name\"],\r\n                token=self.token,\r\n                api_endpoint=build_config[\"api_endpoint\"][\"value\"],\r\n                environment=self.environment,\r\n                keyspace=self.get_keyspace(),\r\n                dimension=field_value.get(\"04_dimension\") if embedding_provider == \"Bring your own\" else None,\r\n                embedding_generation_provider=embedding_provider,\r\n                embedding_generation_model=field_value.get(\"03_embedding_generation_model\"),\r\n                reranker=self.reranker,\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error creating collection: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n        provider = embedding_provider.lower() if embedding_provider and embedding_provider != \"Bring your own\" else None\r\n        build_config[\"collection_name\"].update(\r\n            {\r\n                \"value\": field_value[\"01_new_collection_name\"],\r\n                \"options\": build_config[\"collection_name\"][\"options\"] + [field_value[\"01_new_collection_name\"]],\r\n            }\r\n        )\r\n        build_config[\"embedding_model\"][\"show\"] = not bool(provider)\r\n        build_config[\"embedding_model\"][\"required\"] = not bool(provider)\r\n        build_config[\"collection_name\"][\"options_metadata\"].append(\r\n            {\r\n                \"records\": 0,\r\n                \"provider\": provider,\r\n                \"icon\": self.get_provider_icon(provider_name=provider),\r\n                \"model\": field_value.get(\"03_embedding_generation_model\"),\r\n            }\r\n        )\r\n\r\n        # Make sure we always show the reranker options if the collection is hybrid enabled\r\n        # And right now they always are\r\n        build_config[\"lexical_terms\"][\"show\"] = True\r\n\r\n    def _handle_database_selection(self, build_config: dict, field_value: str) -> dict:\r\n        \"\"\"Handle database selection and update related configurations.\"\"\"\r\n        build_config = self.reset_database_list(build_config)\r\n\r\n        # Reset collection list if database selection changes\r\n        if field_value not in build_config[\"database_name\"][\"options\"]:\r\n            build_config[\"database_name\"][\"value\"] = \"\"\r\n            return build_config\r\n\r\n        # Get the api endpoint for the selected database\r\n        index = build_config[\"database_name\"][\"options\"].index(field_value)\r\n        build_config[\"api_endpoint\"][\"value\"] = build_config[\"database_name\"][\"options_metadata\"][index][\"api_endpoint\"]\r\n\r\n        # Get the org_id for the selected database\r\n        org_id = build_config[\"database_name\"][\"options_metadata\"][index][\"org_id\"]\r\n        if not org_id:\r\n            return build_config\r\n\r\n        # Update the list of keyspaces based on the db info\r\n        build_config[\"keyspace\"][\"options\"] = build_config[\"database_name\"][\"options_metadata\"][index][\"keyspaces\"]\r\n        build_config[\"keyspace\"][\"value\"] = (\r\n            build_config[\"keyspace\"][\"options\"] and build_config[\"keyspace\"][\"options\"][0]\r\n            if build_config[\"keyspace\"][\"value\"] not in build_config[\"keyspace\"][\"options\"]\r\n            else build_config[\"keyspace\"][\"value\"]\r\n        )\r\n\r\n        # Get the database id for the selected database\r\n        db_id = self.get_database_id_static(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\r\n        keyspace = self.get_keyspace()\r\n\r\n        # Update the helper text for the embedding provider field\r\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n        template[\"02_embedding_generation_provider\"][\"helper_text\"] = (\r\n            \"To create collections with more embedding provider options, go to \"\r\n            f'<a class=\"underline\" target=\"_blank\" rel=\"noopener noreferrer\" '\r\n            f'href=\"https://astra.datastax.com/org/{org_id}/database/{db_id}/data-explorer?createCollection=1&namespace={keyspace}\">'\r\n            \"your database in Astra DB</a>.\"\r\n        )\r\n\r\n        # Reset provider options\r\n        build_config = self.reset_provider_options(build_config)\r\n\r\n        # Handle hybrid search options\r\n        build_config = self._handle_hybrid_search_options(build_config)\r\n\r\n        return self.reset_collection_list(build_config)\r\n\r\n    def _handle_collection_selection(self, build_config: dict, field_value: str) -> dict:\r\n        \"\"\"Handle collection selection and update embedding options.\"\"\"\r\n        build_config[\"autodetect_collection\"][\"value\"] = True\r\n        build_config = self.reset_collection_list(build_config)\r\n\r\n        # Reset embedding model if collection selection changes\r\n        if field_value and field_value not in build_config[\"collection_name\"][\"options\"]:\r\n            build_config[\"collection_name\"][\"options\"].append(field_value)\r\n            build_config[\"collection_name\"][\"options_metadata\"].append(\r\n                {\r\n                    \"records\": 0,\r\n                    \"provider\": None,\r\n                    \"icon\": \"vectorstores\",\r\n                    \"model\": None,\r\n                }\r\n            )\r\n            build_config[\"autodetect_collection\"][\"value\"] = False\r\n\r\n        if not field_value:\r\n            return build_config\r\n\r\n        # Get the selected collection index\r\n        index = build_config[\"collection_name\"][\"options\"].index(field_value)\r\n\r\n        # Set the provider of the selected collection\r\n        provider = build_config[\"collection_name\"][\"options_metadata\"][index][\"provider\"]\r\n        build_config[\"embedding_model\"][\"show\"] = not bool(provider)\r\n        build_config[\"embedding_model\"][\"required\"] = not bool(provider)\r\n\r\n        # Grab the collection object\r\n        database = self.get_database_object(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\r\n        collection = database.get_collection(\r\n            name=field_value,\r\n            keyspace=build_config[\"keyspace\"][\"value\"],\r\n        )\r\n\r\n        # Check if hybrid and lexical are enabled\r\n        col_options = collection.options()\r\n        hyb_enabled = col_options.rerank and col_options.rerank.enabled\r\n        lex_enabled = col_options.lexical and col_options.lexical.enabled\r\n        user_hyb_enabled = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\r\n\r\n        # Show lexical terms if the collection is hybrid enabled\r\n        build_config[\"lexical_terms\"][\"show\"] = hyb_enabled and lex_enabled and user_hyb_enabled\r\n\r\n        return build_config\r\n\r\n    @check_cached_vector_store\r\n    def build_vector_store(self):\r\n        try:\r\n            from langchain_astradb import AstraDBVectorStore\r\n        except ImportError as e:\r\n            msg = (\r\n                \"Could not import langchain Astra DB integration package. \"\r\n                \"Please install it with `pip install langchain-astradb`.\"\r\n            )\r\n            raise ImportError(msg) from e\r\n\r\n        # Get the embedding model and additional params\r\n        embedding_params = {\"embedding\": self.embedding_model} if self.embedding_model else {}\r\n\r\n        # Get the additional parameters\r\n        additional_params = self.astradb_vectorstore_kwargs or {}\r\n\r\n        # Get Langflow version and platform information\r\n        __version__ = get_version_info()[\"version\"]\r\n        langflow_prefix = \"\"\r\n        # if os.getenv(\"AWS_EXECUTION_ENV\") == \"AWS_ECS_FARGATE\":  # TODO: More precise way of detecting\r\n        #     langflow_prefix = \"ds-\"\r\n\r\n        # Get the database object\r\n        database = self.get_database_object()\r\n        autodetect = self.collection_name in database.list_collection_names() and self.autodetect_collection\r\n\r\n        # Bundle up the auto-detect parameters\r\n        autodetect_params = {\r\n            \"autodetect_collection\": autodetect,\r\n            \"content_field\": (\r\n                self.content_field\r\n                if self.content_field and embedding_params\r\n                else (\r\n                    \"page_content\"\r\n                    if embedding_params\r\n                    and self.collection_data(collection_name=self.collection_name, database=database) == 0\r\n                    else None\r\n                )\r\n            ),\r\n            \"ignore_invalid_documents\": self.ignore_invalid_documents,\r\n        }\r\n\r\n        # Choose HybridSearchMode based on the selected param\r\n        hybrid_search_mode = HybridSearchMode.DEFAULT if self.search_method == \"Hybrid Search\" else HybridSearchMode.OFF\r\n\r\n        # Attempt to build the Vector Store object\r\n        try:\r\n            vector_store = AstraDBVectorStore(\r\n                # Astra DB Authentication Parameters\r\n                token=self.token,\r\n                api_endpoint=database.api_endpoint,\r\n                namespace=database.keyspace,\r\n                collection_name=self.collection_name,\r\n                environment=self.environment,\r\n                # Hybrid Search Parameters\r\n                hybrid_search=hybrid_search_mode,\r\n                # Astra DB Usage Tracking Parameters\r\n                ext_callers=[(f\"{langflow_prefix}langflow\", __version__)],\r\n                # Astra DB Vector Store Parameters\r\n                **autodetect_params,\r\n                **embedding_params,\r\n                **additional_params,\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error initializing AstraDBVectorStore: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n        # Add documents to the vector store\r\n        self._add_documents_to_vector_store(vector_store)\r\n\r\n        return vector_store\r\n\r\n    def _add_documents_to_vector_store(self, vector_store) -> None:\r\n        self.ingest_data = self._prepare_ingest_data()\r\n\r\n        documents = []\r\n        for _input in self.ingest_data or []:\r\n            if isinstance(_input, Data):\r\n                documents.append(_input.to_lc_document())\r\n            else:\r\n                msg = \"Vector Store Inputs must be Data objects.\"\r\n                raise TypeError(msg)\r\n\r\n        if documents and self.deletion_field:\r\n            self.log(f\"Deleting documents where {self.deletion_field}\")\r\n            try:\r\n                database = self.get_database_object()\r\n                collection = database.get_collection(self.collection_name, keyspace=database.keyspace)\r\n                delete_values = list({doc.metadata[self.deletion_field] for doc in documents})\r\n                self.log(f\"Deleting documents where {self.deletion_field} matches {delete_values}.\")\r\n                collection.delete_many({f\"metadata.{self.deletion_field}\": {\"$in\": delete_values}})\r\n            except Exception as e:\r\n                msg = f\"Error deleting documents from AstraDBVectorStore based on '{self.deletion_field}': {e}\"\r\n                raise ValueError(msg) from e\r\n\r\n        if documents:\r\n            self.log(f\"Adding {len(documents)} documents to the Vector Store.\")\r\n            try:\r\n                vector_store.add_documents(documents)\r\n            except Exception as e:\r\n                msg = f\"Error adding documents to AstraDBVectorStore: {e}\"\r\n                raise ValueError(msg) from e\r\n        else:\r\n            self.log(\"No documents to add to the Vector Store.\")\r\n\r\n    def _map_search_type(self) -> str:\r\n        search_type_mapping = {\r\n            \"Similarity with score threshold\": \"similarity_score_threshold\",\r\n            \"MMR (Max Marginal Relevance)\": \"mmr\",\r\n        }\r\n\r\n        return search_type_mapping.get(self.search_type, \"similarity\")\r\n\r\n    def _build_search_args(self):\r\n        # Clean up the search query\r\n        query = self.search_query if isinstance(self.search_query, str) and self.search_query.strip() else None\r\n        lexical_terms = self.lexical_terms or None\r\n\r\n        # Check if we have a search query, and if so set the args\r\n        if query:\r\n            args = {\r\n                \"query\": query,\r\n                \"search_type\": self._map_search_type(),\r\n                \"k\": self.number_of_results,\r\n                \"score_threshold\": self.search_score_threshold,\r\n                \"lexical_query\": lexical_terms,\r\n            }\r\n        elif self.advanced_search_filter:\r\n            args = {\r\n                \"n\": self.number_of_results,\r\n            }\r\n        else:\r\n            return {}\r\n\r\n        filter_arg = self.advanced_search_filter or {}\r\n        if filter_arg:\r\n            args[\"filter\"] = filter_arg\r\n\r\n        return args\r\n\r\n    def search_documents(self, vector_store=None) -> list[Data]:\r\n        vector_store = vector_store or self.build_vector_store()\r\n        \r\n        # Create a list of queries to process\r\n        queries = [self.search_query]\r\n        if hasattr(self, 'search_query_2') and self.search_query_2 and isinstance(self.search_query_2, str) and self.search_query_2.strip():\r\n            queries.append(self.search_query_2)\r\n        if hasattr(self, 'search_query_3') and self.search_query_3 and isinstance(self.search_query_3, str) and self.search_query_3.strip():\r\n            queries.append(self.search_query_3)\r\n        \r\n        self.log(f\"Processing {len(queries)} search queries\")\r\n        \r\n        # Store all retrieved documents\r\n        all_docs = []\r\n        \r\n        # Process each query\r\n        for idx, query in enumerate(queries, 1):\r\n            if not query:\r\n                continue\r\n                \r\n            self.log(f\"Search input #{idx}: {query}\")\r\n            self.log(f\"Search type: {self.search_type}\")\r\n            self.log(f\"Number of results: {self.number_of_results}\")\r\n            self.log(f\"store.hybrid_search: {vector_store.hybrid_search}\")\r\n            self.log(f\"Lexical terms: {self.lexical_terms}\")\r\n            self.log(f\"Reranker: {self.reranker}\")\r\n            \r\n            # Store the original search query\r\n            original_query = self.search_query\r\n            # Set the current query as search_query\r\n            self.search_query = query\r\n            \r\n            try:\r\n                search_args = self._build_search_args()\r\n            except Exception as e:\r\n                self.search_query = original_query  # Restore original query\r\n                msg = f\"Error in AstraDBVectorStore._build_search_args for query #{idx}: {e}\"\r\n                raise ValueError(msg) from e\r\n                \r\n            if not search_args:\r\n                self.log(f\"No search input or filters provided for query #{idx}. Skipping.\")\r\n                continue\r\n                \r\n            docs = []\r\n            search_method = \"search\" if \"query\" in search_args else \"metadata_search\"\r\n            \r\n            try:\r\n                self.log(f\"Calling vector_store.{search_method} with args: {search_args}\")\r\n                docs = getattr(vector_store, search_method)(**search_args)\r\n                self.log(f\"Retrieved {len(docs)} documents for query #{idx}\")\r\n                all_docs.extend(docs)\r\n            except Exception as e:\r\n                self.search_query = original_query  # Restore original query\r\n                msg = f\"Error performing {search_method} in AstraDBVectorStore for query #{idx}: {e}\"\r\n                raise ValueError(msg) from e\r\n            \r\n            # Restore the original search query\r\n            self.search_query = original_query\r\n        \r\n        # Deduplicate results if requested\r\n        if hasattr(self, 'deduplicate_results') and self.deduplicate_results:\r\n            # Create a set to track unique document content\r\n            seen_content = set()\r\n            unique_docs = []\r\n            \r\n            for doc in all_docs:\r\n                # Use page_content as a key for deduplication\r\n                content_hash = hash(doc.page_content)\r\n                if content_hash not in seen_content:\r\n                    seen_content.add(content_hash)\r\n                    unique_docs.append(doc)\r\n            \r\n            self.log(f\"Deduplicated from {len(all_docs)} to {len(unique_docs)} documents\")\r\n            all_docs = unique_docs\r\n        \r\n        self.log(f\"Total retrieved documents: {len(all_docs)}\")\r\n        \r\n        data = docs_to_data(all_docs)\r\n        self.log(f\"Converted documents to data: {len(data)}\")\r\n        self.status = data\r\n        \r\n        return data\r\n\r\n    def get_retriever_kwargs(self):\r\n        # For retrievers, we'll just use the primary search query\r\n        # This keeps compatibility with existing retriever interfaces\r\n        search_args = self._build_search_args()\r\n        \r\n        return {\r\n            \"search_type\": self._map_search_type(),\r\n            \"search_kwargs\": search_args,\r\n        }"
              },
              "collection_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {
                  "fields": {
                    "data": {
                      "node": {
                        "description": "Please allow several seconds for creation to complete.",
                        "display_name": "Create new collection",
                        "field_order": [
                          "01_new_collection_name",
                          "02_embedding_generation_provider",
                          "03_embedding_generation_model",
                          "04_dimension"
                        ],
                        "name": "create_collection",
                        "template": {
                          "01_new_collection_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Name",
                            "dynamic": false,
                            "info": "Name of the new collection to create in Astra DB.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_collection_name",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "02_embedding_generation_provider": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Embedding generation method",
                            "dynamic": false,
                            "helper_text": "To create collections with more embedding provider options, go to <a class=\"underline\" target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://astra.datastax.com/org/72c50b26-728b-4a86-8ee5-9dc701bc5adf/database/6feab22e-d3d5-4e4a-b788-cd5f2bbd2b7a/data-explorer?createCollection=1&namespace=default_keyspace\">your database in Astra DB</a>.",
                            "info": "Provider to use for generating embeddings.",
                            "name": "embedding_generation_provider",
                            "options": [
                              "Bring your own",
                              "Nvidia"
                            ],
                            "options_metadata": [
                              {
                                "icon": "vectorstores"
                              },
                              {
                                "icon": "NVIDIA"
                              }
                            ],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "03_embedding_generation_model": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Embedding model",
                            "dynamic": false,
                            "info": "Model to use for generating embeddings.",
                            "name": "embedding_generation_model",
                            "options": [],
                            "options_metadata": [],
                            "placeholder": null,
                            "readonly": "",
                            "real_time_refresh": true,
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": null
                          },
                          "04_dimension": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Dimensions",
                            "dynamic": false,
                            "info": "Dimensions of the embeddings to generate.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "dimension",
                            "placeholder": 1024,
                            "readonly": true,
                            "required": "",
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1024
                          }
                        }
                      }
                    }
                  },
                  "functionality": "create"
                },
                "display_name": "Collection",
                "dynamic": false,
                "info": "The name of the collection within Astra DB where the vectors will be stored.",
                "load_from_db": false,
                "name": "collection_name",
                "options": [
                  "textbook"
                ],
                "options_metadata": [
                  {
                    "icon": "vectorstores",
                    "model": null,
                    "provider": null,
                    "records": 154
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": true,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "textbook"
              },
              "content_field": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Content Field",
                "dynamic": false,
                "info": "Field to use as the text content field for the vector store.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "content_field",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "database_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {
                  "fields": {
                    "data": {
                      "node": {
                        "description": "Please allow several minutes for creation to complete.",
                        "display_name": "Create new database",
                        "field_order": [
                          "01_new_database_name",
                          "02_cloud_provider",
                          "03_region"
                        ],
                        "name": "create_database",
                        "template": {
                          "01_new_database_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Name",
                            "dynamic": false,
                            "info": "Name of the new database to create in Astra DB.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_database_name",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "02_cloud_provider": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Cloud provider",
                            "dynamic": false,
                            "info": "Cloud provider for the new database.",
                            "name": "cloud_provider",
                            "options": [
                              "Amazon Web Services",
                              "Google Cloud Platform",
                              "Microsoft Azure"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "03_region": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Region",
                            "dynamic": false,
                            "info": "Region for the new database.",
                            "name": "region",
                            "options": [],
                            "options_metadata": [],
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          }
                        }
                      }
                    }
                  },
                  "functionality": "create"
                },
                "display_name": "Database",
                "dynamic": false,
                "info": "The Database name for the Astra DB instance.",
                "load_from_db": false,
                "name": "database_name",
                "options": [
                  "G11 - History Text Book"
                ],
                "options_metadata": [
                  {
                    "api_endpoint": "https://6feab22e-d3d5-4e4a-b788-cd5f2bbd2b7a-us-east-2.apps.astra.datastax.com",
                    "collections": 1,
                    "keyspaces": [
                      "default_keyspace"
                    ],
                    "org_id": "72c50b26-728b-4a86-8ee5-9dc701bc5adf",
                    "status": null
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": true,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "G11 - History Text Book"
              },
              "deduplicate_results": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Deduplicate Results",
                "dynamic": false,
                "info": "Remove duplicate documents from the combined search results.",
                "list": false,
                "list_add_label": "Add More",
                "name": "deduplicate_results",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "deletion_field": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Deletion Based On Field",
                "dynamic": false,
                "info": "When this parameter is provided, documents in the target collection with metadata field values matching the input metadata field value will be deleted before new data is loaded.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "deletion_field",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "embedding_model": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Embedding Model",
                "dynamic": false,
                "info": "Specify the Embedding Model. Not required for Astra Vectorize collections.",
                "input_types": [
                  "Embeddings"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "embedding_model",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "environment": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Environment",
                "dynamic": false,
                "info": "The environment for the Astra DB API Endpoint.",
                "name": "environment",
                "options": [
                  "prod",
                  "test",
                  "dev"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "prod"
              },
              "ignore_invalid_documents": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Ignore Invalid Documents",
                "dynamic": false,
                "info": "Boolean flag to determine whether to ignore invalid documents at runtime.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ignore_invalid_documents",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "ingest_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Ingest Data",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Data",
                  "DataFrame"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "ingest_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "keyspace": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Keyspace",
                "dynamic": false,
                "info": "Optional keyspace within Astra DB to use for the collection.",
                "load_from_db": false,
                "name": "keyspace",
                "options": [
                  "default_keyspace"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "default_keyspace"
              },
              "lexical_terms": {
                "_input_type": "QueryInput",
                "advanced": true,
                "display_name": "Lexical Terms",
                "dynamic": false,
                "info": "Add additional terms/keywords to augment search precision.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "lexical_terms",
                "placeholder": "Enter terms to search...",
                "required": false,
                "separator": " ",
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "query",
                "value": ""
              },
              "number_of_results": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Search Results",
                "dynamic": false,
                "info": "Number of search results to return.",
                "list": false,
                "list_add_label": "Add More",
                "name": "number_of_results",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 4
              },
              "reranker": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Reranker",
                "dynamic": false,
                "info": "Post-retrieval model that re-scores results for optimal relevance ranking.",
                "load_from_db": false,
                "name": "reranker",
                "options": [
                  "nvidia/llama-3.2-nv-rerankqa-1b-v2"
                ],
                "options_metadata": [
                  {
                    "icon": "NVIDIA"
                  }
                ],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": true,
                "toggle_disable": true,
                "toggle_value": true,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "nvidia/llama-3.2-nv-rerankqa-1b-v2"
              },
              "search_method": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Search Method",
                "dynamic": false,
                "info": "Determine how your content is matched: Vector finds semantic similarity, and Hybrid Search (suggested) combines both approaches with a reranker.",
                "name": "search_method",
                "options": [
                  "Hybrid Search",
                  "Vector Search"
                ],
                "options_metadata": [
                  {
                    "icon": "SearchHybrid"
                  },
                  {
                    "icon": "SearchVector"
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Hybrid Search"
              },
              "search_query": {
                "_input_type": "QueryInput",
                "advanced": false,
                "display_name": "Search Query",
                "dynamic": false,
                "info": "Enter a query to run a similarity search.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "search_query",
                "placeholder": "Enter a query...",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "query",
                "value": ""
              },
              "search_query_2": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Second Search Query",
                "dynamic": false,
                "info": "Second query to search for in the vector database.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "search_query_2",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "search_query_3": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Third Search Query",
                "dynamic": false,
                "info": "Third query to search for in the vector database.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "search_query_3",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "search_score_threshold": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Search Score Threshold",
                "dynamic": false,
                "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
                "list": false,
                "list_add_label": "Add More",
                "name": "search_score_threshold",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": 0
              },
              "search_type": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Search Type",
                "dynamic": false,
                "info": "Search type to use",
                "name": "search_type",
                "options": [
                  "Similarity",
                  "Similarity with score threshold",
                  "MMR (Max Marginal Relevance)"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Similarity"
              },
              "should_cache_vector_store": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Cache Vector Store",
                "dynamic": false,
                "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_cache_vector_store",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "token": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Astra DB Application Token",
                "dynamic": false,
                "info": "Authentication token for accessing Astra DB.",
                "input_types": [],
                "load_from_db": true,
                "name": "token",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "AstraDB"
        },
        "id": "AstraDB-jm2uO",
        "measured": {
          "height": 858,
          "width": 320
        },
        "position": {
          "x": 5475.854292694007,
          "y": 1982.002124331793
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "JSONtoData-qjsYa",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Convert a JSON string to a Data object",
            "display_name": "Load JSON",
            "documentation": "",
            "edited": true,
            "field_order": [
              "json_string"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": true,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": false,
                "method": "convert_json_to_data",
                "name": "data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\r\nfrom json_repair import repair_json\r\nfrom langflow.custom import Component\r\nfrom langflow.io import MultilineInput, Output\r\nfrom langflow.schema import Data\r\n\r\nclass JSONToDataComponent(Component):\r\n    display_name = \"Load JSON\"\r\n    description = \"Convert a JSON string to a Data object\"\r\n    icon = \"braces\"\r\n    name = \"JSONtoData\"\r\n    legacy = True\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"json_string\",\r\n            display_name=\"JSON String\",\r\n            info=\"Enter a valid JSON string to convert to a Data object\",\r\n        ),\r\n    ]\r\n    outputs = [\r\n        Output(name=\"data\", display_name=\"Data\", method=\"convert_json_to_data\"),\r\n    ]\r\n\r\n    def convert_json_to_data(self) -> Data:\r\n        if not self.json_string:\r\n            msg = \"Please provide a JSON string.\"\r\n            self.status = msg\r\n            raise ValueError(msg)\r\n        \r\n        try:\r\n            # Try to parse the JSON string\r\n            try:\r\n                parsed_data = json.loads(self.json_string)\r\n            except json.JSONDecodeError:\r\n                # If JSON parsing fails, try to repair the JSON string\r\n                repaired_json_string = repair_json(self.json_string)\r\n                parsed_data = json.loads(repaired_json_string)\r\n            \r\n            # Convert the parsed data to a Data object\r\n            # If it's a list, we'll use the first item or merge them, depending on use case\r\n            if isinstance(parsed_data, list):\r\n                # Option 1: Use first item in the list\r\n                # result = Data(data=parsed_data[0])\r\n                \r\n                # Option 2: Keep the entire list as the data\r\n                result = Data(data=parsed_data)\r\n            else:\r\n                result = Data(data=parsed_data)\r\n            \r\n            self.status = result\r\n            return result\r\n            \r\n        except (json.JSONDecodeError, SyntaxError, ValueError) as e:\r\n            error_message = f\"Invalid JSON: {e}\"\r\n            self.status = error_message\r\n            raise ValueError(error_message) from e\r\n        except Exception as e:\r\n            error_message = f\"An error occurred: {e}\"\r\n            self.status = error_message\r\n            raise ValueError(error_message) from e"
              },
              "json_string": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "JSON String",
                "dynamic": false,
                "info": "Enter a valid JSON string to convert to a Data object",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "json_string",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "JSONtoData"
        },
        "id": "JSONtoData-qjsYa",
        "measured": {
          "height": 228,
          "width": 320
        },
        "position": {
          "x": 4121.99954190505,
          "y": 2453.453280651316
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "MultiTemplateParserComponent-TFe9s",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Format a DataFrame or Data object into text using multiple templates. Outputs parsed results for each template separately.",
            "display_name": "Multi-Template Parser",
            "documentation": "",
            "edited": true,
            "field_order": [
              "mode",
              "template_1",
              "template_2",
              "template_3",
              "input_data",
              "sep"
            ],
            "frozen": false,
            "icon": "brackets",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "official": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Result 1",
                "hidden": false,
                "method": "get_result_1",
                "name": "result_1",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Result 2",
                "hidden": false,
                "method": "get_result_2",
                "name": "result_2",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Result 3",
                "hidden": false,
                "method": "get_result_3",
                "name": "result_3",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\r\nfrom typing import Any, List, Optional\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    BoolInput,\r\n    HandleInput,\r\n    MessageTextInput,\r\n    MultilineInput,\r\n    Output,\r\n    TabInput,\r\n)\r\nfrom langflow.schema import Data, DataFrame\r\nfrom langflow.schema.message import Message\r\n\r\n\r\nclass MultiTemplateParserComponent(Component):\r\n    display_name = \"Multi-Template Parser\"\r\n    description = (\r\n        \"Format a DataFrame or Data object into text using multiple templates. \"\r\n        \"Outputs parsed results for each template separately.\"\r\n    )\r\n    icon = \"brackets\"\r\n\r\n    inputs = [\r\n        TabInput(\r\n            name=\"mode\",\r\n            display_name=\"Mode\",\r\n            options=[\"Parser\", \"Stringify\"],\r\n            value=\"Parser\",\r\n            info=\"Convert into raw string instead of using templates.\",\r\n            real_time_refresh=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template_1\",\r\n            display_name=\"Template 1\",\r\n            info=(\r\n                \"Use variables within curly brackets to extract column values for DataFrames \"\r\n                \"or key values for Data.\"\r\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\r\n            ),\r\n            value=\"Text: {text}\",  # Example default\r\n            dynamic=True,\r\n            show=True,\r\n            required=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template_2\",\r\n            display_name=\"Template 2\",\r\n            info=(\r\n                \"Second template pattern for extraction. \"\r\n                \"For example: `{Name} is {Age} years old and from {Country}`\"\r\n            ),\r\n            value=\"Summary: {summary}\",  # Example default\r\n            dynamic=True,\r\n            show=True,\r\n            required=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template_3\",\r\n            display_name=\"Template 3\",\r\n            info=(\r\n                \"Third template pattern for extraction. \"\r\n                \"For example: `{Country}: {Name} ({Age})`\"\r\n            ),\r\n            value=\"ID: {id}\",  # Example default\r\n            dynamic=True,\r\n            show=True,\r\n            required=True,\r\n        ),\r\n        HandleInput(\r\n            name=\"input_data\",\r\n            display_name=\"Data or DataFrame\",\r\n            input_types=[\"DataFrame\", \"Data\"],\r\n            info=\"Accepts either a DataFrame or a Data object.\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"sep\",\r\n            display_name=\"Separator\",\r\n            advanced=True,\r\n            value=\"\\n\",\r\n            info=\"String used to separate rows/items.\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            display_name=\"Result 1\",\r\n            name=\"result_1\",\r\n            info=\"Formatted text output using Template 1.\",\r\n            method=\"get_result_1\",\r\n        ),\r\n        Output(\r\n            display_name=\"Result 2\",\r\n            name=\"result_2\",\r\n            info=\"Formatted text output using Template 2.\",\r\n            method=\"get_result_2\",\r\n        ),\r\n        Output(\r\n            display_name=\"Result 3\",\r\n            name=\"result_3\",\r\n            info=\"Formatted text output using Template 3.\",\r\n            method=\"get_result_3\",\r\n        ),\r\n    ]\r\n\r\n    def update_build_config(self, build_config, field_value, field_name=None):\r\n        \"\"\"Dynamically hide/show templates and enforce requirements based on mode.\"\"\"\r\n        if field_name == \"mode\":\r\n            # Show/hide templates based on mode\r\n            show_templates = self.mode == \"Parser\"\r\n            for i in range(1, 4):\r\n                template_key = f\"template_{i}\"\r\n                if template_key in build_config:\r\n                    build_config[template_key][\"show\"] = show_templates\r\n                    build_config[template_key][\"required\"] = show_templates\r\n            \r\n            # Add clean_data option for stringify mode\r\n            if field_value and self.mode == \"Stringify\":\r\n                clean_data = BoolInput(\r\n                    name=\"clean_data\",\r\n                    display_name=\"Clean Data\",\r\n                    info=(\r\n                        \"Enable to clean the data by removing empty rows and lines \"\r\n                        \"in each cell of the DataFrame/ Data object.\"\r\n                    ),\r\n                    value=True,\r\n                    advanced=True,\r\n                    required=False,\r\n                )\r\n                build_config[\"clean_data\"] = clean_data.to_dict()\r\n            else:\r\n                build_config.pop(\"clean_data\", None)\r\n\r\n        return build_config\r\n\r\n    def _clean_args(self):\r\n        \"\"\"Prepare arguments based on input type.\"\"\"\r\n        input_data = self.input_data\r\n\r\n        match input_data:\r\n            case list() if all(isinstance(item, Data) for item in input_data):\r\n                msg = \"List of Data objects is not supported.\"\r\n                raise ValueError(msg)\r\n            case DataFrame():\r\n                return input_data, None\r\n            case Data():\r\n                return None, input_data\r\n            case dict() if \"data\" in input_data:\r\n                try:\r\n                    if \"columns\" in input_data:  # Likely a DataFrame\r\n                        return DataFrame.from_dict(input_data), None\r\n                    # Likely a Data object\r\n                    return None, Data(**input_data)\r\n                except (TypeError, ValueError, KeyError) as e:\r\n                    msg = f\"Invalid structured input provided: {e!s}\"\r\n                    raise ValueError(msg) from e\r\n            case _:\r\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\r\n                raise ValueError(msg)\r\n\r\n    def _parse_with_template(self, template: str) -> str:\r\n        \"\"\"Parse all rows/items using the specified template.\"\"\"\r\n        # Early return for stringify option\r\n        if self.mode == \"Stringify\":\r\n            return self._convert_to_string()\r\n\r\n        df, data = self._clean_args()\r\n\r\n        lines = []\r\n        try:\r\n            if df is not None:\r\n                for _, row in df.iterrows():\r\n                    try:\r\n                        formatted_text = template.format(**row.to_dict())\r\n                        lines.append(formatted_text)\r\n                    except KeyError as key_error:\r\n                        self.log(f\"Warning: Key {key_error} not found in DataFrame row.\")\r\n                        # Skip this row or add placeholder\r\n                        continue\r\n            elif data is not None:\r\n                try:\r\n                    formatted_text = template.format(**data.data)\r\n                    lines.append(formatted_text)\r\n                except KeyError as key_error:\r\n                    self.log(f\"Warning: Key {key_error} not found in Data object.\")\r\n                    # Return empty or placeholder\r\n                    return f\"Missing key(s) in data: {key_error}\"\r\n        except Exception as e:\r\n            self.log(f\"Error during template parsing: {e}\")\r\n            return f\"Error: {str(e)}\"\r\n\r\n        return self.sep.join(lines)\r\n\r\n    def _safe_convert(self, data: Any) -> str:\r\n        \"\"\"Safely convert input data to string.\"\"\"\r\n        try:\r\n            if isinstance(data, str):\r\n                return data\r\n            if isinstance(data, Message):\r\n                return data.get_text()\r\n            if isinstance(data, Data):\r\n                return json.dumps(data.data)\r\n            if isinstance(data, DataFrame):\r\n                if hasattr(self, \"clean_data\") and self.clean_data:\r\n                    # Remove empty rows\r\n                    data = data.dropna(how=\"all\")\r\n                    # Remove empty lines in each cell\r\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\r\n                    # Replace multiple newlines with a single newline\r\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\r\n                return data.to_markdown(index=False)\r\n            return str(data)\r\n        except (ValueError, TypeError, AttributeError) as e:\r\n            msg = f\"Error converting data: {e!s}\"\r\n            raise ValueError(msg) from e\r\n\r\n    def _convert_to_string(self) -> str:\r\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\r\n        if isinstance(self.input_data, list):\r\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\r\n        else:\r\n            result = self._safe_convert(self.input_data)\r\n        self.log(f\"Converted to string with length: {len(result)}\")\r\n        return result\r\n\r\n    def get_result_1(self) -> Message:\r\n        \"\"\"Return the result parsed using template 1.\"\"\"\r\n        if self.mode == \"Parser\":\r\n            result = self._parse_with_template(self.template_1)\r\n        else:  # Stringify mode\r\n            result = self._convert_to_string()\r\n        \r\n        self.status = f\"Template 1 processed with {len(result)} characters\"\r\n        return Message(text=result)\r\n\r\n    def get_result_2(self) -> Message:\r\n        \"\"\"Return the result parsed using template 2.\"\"\"\r\n        if self.mode == \"Parser\":\r\n            result = self._parse_with_template(self.template_2)\r\n        else:  # Stringify mode\r\n            result = self._convert_to_string()\r\n        \r\n        self.status = f\"Template 2 processed with {len(result)} characters\"\r\n        return Message(text=result)\r\n\r\n    def get_result_3(self) -> Message:\r\n        \"\"\"Return the result parsed using template 3.\"\"\"\r\n        if self.mode == \"Parser\":\r\n            result = self._parse_with_template(self.template_3)\r\n        else:  # Stringify mode\r\n            result = self._convert_to_string()\r\n        \r\n        self.status = f\"Template 3 processed with {len(result)} characters\"\r\n        return Message(text=result)"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using templates.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              },
              "template_1": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template 1",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template_1",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{search_queries[0]}"
              },
              "template_2": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template 2",
                "dynamic": true,
                "info": "Second template pattern for extraction. For example: `{Name} is {Age} years old and from {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template_2",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{search_queries[1]}"
              },
              "template_3": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template 3",
                "dynamic": true,
                "info": "Third template pattern for extraction. For example: `{Country}: {Name} ({Age})`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template_3",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{search_queries[2]}"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "MultiTemplateParserComponent"
        },
        "id": "MultiTemplateParserComponent-TFe9s",
        "measured": {
          "height": 407,
          "width": 320
        },
        "position": {
          "x": 4561.169150693936,
          "y": 2602.135572814606
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "AstraDB-XcO2c",
          "node": {
            "base_classes": [
              "Data",
              "DataFrame",
              "VectorStore"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Ingest and search documents in Astra DB with 3 Search Queries",
            "display_name": "Astra DB * 3",
            "documentation": "https://docs.datastax.com/en/langflow/astra-components.html",
            "edited": true,
            "field_order": [
              "search_query_2",
              "search_query_3",
              "deduplicate_results",
              "token",
              "environment",
              "database_name",
              "api_endpoint",
              "keyspace",
              "collection_name",
              "embedding_model",
              "ingest_data",
              "search_query",
              "should_cache_vector_store",
              "search_method",
              "reranker",
              "lexical_terms",
              "number_of_results",
              "search_type",
              "search_score_threshold",
              "advanced_search_filter",
              "autodetect_collection",
              "content_field",
              "deletion_field",
              "ignore_invalid_documents",
              "astradb_vectorstore_kwargs"
            ],
            "frozen": false,
            "icon": "AstraDB",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "official": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Search Results",
                "hidden": false,
                "method": "search_documents",
                "name": "search_results",
                "options": null,
                "required_inputs": [
                  "collection_name",
                  "database_name",
                  "embedding_model",
                  "token"
                ],
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": null,
                "method": "as_dataframe",
                "name": "dataframe",
                "options": null,
                "required_inputs": [],
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Vector Store Connection",
                "hidden": true,
                "method": "as_vector_store",
                "name": "vectorstoreconnection",
                "options": null,
                "required_inputs": null,
                "selected": "VectorStore",
                "tool_mode": true,
                "types": [
                  "VectorStore"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "advanced_search_filter": {
                "_input_type": "NestedDictInput",
                "advanced": true,
                "display_name": "Search Metadata Filter",
                "dynamic": false,
                "info": "Optional dictionary of filters to apply to the search query.",
                "list": false,
                "list_add_label": "Add More",
                "name": "advanced_search_filter",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "NestedDict",
                "value": {}
              },
              "api_endpoint": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Astra DB API Endpoint",
                "dynamic": false,
                "info": "The API Endpoint for the Astra DB instance. Supercedes database selection.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "api_endpoint",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "https://6feab22e-d3d5-4e4a-b788-cd5f2bbd2b7a-us-east-2.apps.astra.datastax.com"
              },
              "astradb_vectorstore_kwargs": {
                "_input_type": "NestedDictInput",
                "advanced": true,
                "display_name": "AstraDBVectorStore Parameters",
                "dynamic": false,
                "info": "Optional dictionary of additional parameters for the AstraDBVectorStore.",
                "list": false,
                "list_add_label": "Add More",
                "name": "astradb_vectorstore_kwargs",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "NestedDict",
                "value": {}
              },
              "autodetect_collection": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Autodetect Collection",
                "dynamic": false,
                "info": "Boolean flag to determine whether to autodetect the collection.",
                "list": false,
                "list_add_label": "Add More",
                "name": "autodetect_collection",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import re\r\nfrom collections import defaultdict\r\nfrom dataclasses import asdict, dataclass, field\r\n\r\nfrom astrapy import DataAPIClient, Database\r\nfrom astrapy.data.info.reranking import RerankServiceOptions\r\nfrom astrapy.info import CollectionDescriptor, CollectionLexicalOptions, CollectionRerankOptions\r\nfrom langchain_astradb import AstraDBVectorStore, VectorServiceOptions\r\nfrom langchain_astradb.utils.astradb import HybridSearchMode, _AstraDBCollectionEnvironment\r\n\r\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\r\nfrom langflow.base.vectorstores.vector_store_connection_decorator import vector_store_connection\r\nfrom langflow.helpers import docs_to_data\r\nfrom langflow.inputs import FloatInput, NestedDictInput\r\nfrom langflow.io import (\r\n    BoolInput,\r\n    DropdownInput,\r\n    HandleInput,\r\n    IntInput,\r\n    QueryInput,\r\n    SecretStrInput,\r\n    StrInput,\r\n    MultilineInput,\r\n)\r\nfrom langflow.schema import Data\r\nfrom langflow.utils.version import get_version_info\r\nfrom itertools import chain\r\nfrom typing import List, Optional, Union\r\n\r\n\r\n@vector_store_connection\r\nclass AstraDBVectorStoreComponent(LCVectorStoreComponent):\r\n    display_name: str = \"Astra DB\"\r\n    description: str = \"Ingest and search documents in Astra DB\"\r\n    documentation: str = \"https://docs.datastax.com/en/langflow/astra-components.html\"\r\n    name = \"AstraDB\"\r\n    icon: str = \"AstraDB\"\r\n\r\n    _cached_vector_store: AstraDBVectorStore | None = None\r\n\r\n    @dataclass\r\n    class NewDatabaseInput:\r\n        functionality: str = \"create\"\r\n        fields: dict[str, dict] = field(\r\n            default_factory=lambda: {\r\n                \"data\": {\r\n                    \"node\": {\r\n                        \"name\": \"create_database\",\r\n                        \"description\": \"Please allow several minutes for creation to complete.\",\r\n                        \"display_name\": \"Create new database\",\r\n                        \"field_order\": [\"01_new_database_name\", \"02_cloud_provider\", \"03_region\"],\r\n                        \"template\": {\r\n                            \"01_new_database_name\": StrInput(\r\n                                name=\"new_database_name\",\r\n                                display_name=\"Name\",\r\n                                info=\"Name of the new database to create in Astra DB.\",\r\n                                required=True,\r\n                            ),\r\n                            \"02_cloud_provider\": DropdownInput(\r\n                                name=\"cloud_provider\",\r\n                                display_name=\"Cloud provider\",\r\n                                info=\"Cloud provider for the new database.\",\r\n                                options=[],\r\n                                required=True,\r\n                                real_time_refresh=True,\r\n                            ),\r\n                            \"03_region\": DropdownInput(\r\n                                name=\"region\",\r\n                                display_name=\"Region\",\r\n                                info=\"Region for the new database.\",\r\n                                options=[],\r\n                                required=True,\r\n                            ),\r\n                        },\r\n                    },\r\n                }\r\n            }\r\n        )\r\n\r\n    @dataclass\r\n    class NewCollectionInput:\r\n        functionality: str = \"create\"\r\n        fields: dict[str, dict] = field(\r\n            default_factory=lambda: {\r\n                \"data\": {\r\n                    \"node\": {\r\n                        \"name\": \"create_collection\",\r\n                        \"description\": \"Please allow several seconds for creation to complete.\",\r\n                        \"display_name\": \"Create new collection\",\r\n                        \"field_order\": [\r\n                            \"01_new_collection_name\",\r\n                            \"02_embedding_generation_provider\",\r\n                            \"03_embedding_generation_model\",\r\n                            \"04_dimension\",\r\n                        ],\r\n                        \"template\": {\r\n                            \"01_new_collection_name\": StrInput(\r\n                                name=\"new_collection_name\",\r\n                                display_name=\"Name\",\r\n                                info=\"Name of the new collection to create in Astra DB.\",\r\n                                required=True,\r\n                            ),\r\n                            \"02_embedding_generation_provider\": DropdownInput(\r\n                                name=\"embedding_generation_provider\",\r\n                                display_name=\"Embedding generation method\",\r\n                                info=\"Provider to use for generating embeddings.\",\r\n                                helper_text=(\r\n                                    \"To create collections with more embedding provider options, go to \"\r\n                                    '<a class=\"underline\" href=\"https://astra.datastax.com/\" target=\" _blank\" '\r\n                                    'rel=\"noopener noreferrer\">your database in Astra DB</a>'\r\n                                ),\r\n                                real_time_refresh=True,\r\n                                required=True,\r\n                                options=[],\r\n                            ),\r\n                            \"03_embedding_generation_model\": DropdownInput(\r\n                                name=\"embedding_generation_model\",\r\n                                display_name=\"Embedding model\",\r\n                                info=\"Model to use for generating embeddings.\",\r\n                                real_time_refresh=True,\r\n                                options=[],\r\n                            ),\r\n                            \"04_dimension\": IntInput(\r\n                                name=\"dimension\",\r\n                                display_name=\"Dimensions\",\r\n                                info=\"Dimensions of the embeddings to generate.\",\r\n                                value=None,\r\n                            ),\r\n                        },\r\n                    },\r\n                }\r\n            }\r\n        )\r\n\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"search_query_2\",\r\n            display_name=\"Second Search Query\",\r\n            info=\"Second query to search for in the vector database.\",\r\n            advanced=False,\r\n        ),\r\n        MultilineInput(\r\n            name=\"search_query_3\",\r\n            display_name=\"Third Search Query\",\r\n            info=\"Third query to search for in the vector database.\",\r\n            advanced=False,\r\n        ),\r\n        BoolInput(\r\n            name=\"deduplicate_results\",\r\n            display_name=\"Deduplicate Results\",\r\n            info=\"Remove duplicate documents from the combined search results.\",\r\n            advanced=True,\r\n            value=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"token\",\r\n            display_name=\"Astra DB Application Token\",\r\n            info=\"Authentication token for accessing Astra DB.\",\r\n            value=\"ASTRA_DB_APPLICATION_TOKEN\",\r\n            required=True,\r\n            real_time_refresh=True,\r\n            input_types=[],\r\n        ),\r\n        DropdownInput(\r\n            name=\"environment\",\r\n            display_name=\"Environment\",\r\n            info=\"The environment for the Astra DB API Endpoint.\",\r\n            options=[\"prod\", \"test\", \"dev\"],\r\n            value=\"prod\",\r\n            advanced=True,\r\n            real_time_refresh=True,\r\n            combobox=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"database_name\",\r\n            display_name=\"Database\",\r\n            info=\"The Database name for the Astra DB instance.\",\r\n            required=True,\r\n            refresh_button=True,\r\n            real_time_refresh=True,\r\n            dialog_inputs=asdict(NewDatabaseInput()),\r\n            combobox=True,\r\n        ),\r\n        StrInput(\r\n            name=\"api_endpoint\",\r\n            display_name=\"Astra DB API Endpoint\",\r\n            info=\"The API Endpoint for the Astra DB instance. Supercedes database selection.\",\r\n            show=False,\r\n        ),\r\n        DropdownInput(\r\n            name=\"keyspace\",\r\n            display_name=\"Keyspace\",\r\n            info=\"Optional keyspace within Astra DB to use for the collection.\",\r\n            advanced=True,\r\n            options=[],\r\n            real_time_refresh=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"collection_name\",\r\n            display_name=\"Collection\",\r\n            info=\"The name of the collection within Astra DB where the vectors will be stored.\",\r\n            required=True,\r\n            refresh_button=True,\r\n            real_time_refresh=True,\r\n            dialog_inputs=asdict(NewCollectionInput()),\r\n            combobox=True,\r\n            show=True,\r\n        ),\r\n        HandleInput(\r\n            name=\"embedding_model\",\r\n            display_name=\"Embedding Model\",\r\n            input_types=[\"Embeddings\"],\r\n            info=\"Specify the Embedding Model. Not required for Astra Vectorize collections.\",\r\n            required=True,\r\n            show=True,\r\n        ),\r\n        *LCVectorStoreComponent.inputs,\r\n        DropdownInput(\r\n            name=\"search_method\",\r\n            display_name=\"Search Method\",\r\n            info=(\r\n                \"Determine how your content is matched: Vector finds semantic similarity, \"\r\n                \"and Hybrid Search (suggested) combines both approaches \"\r\n                \"with a reranker.\"\r\n            ),\r\n            options=[\"Hybrid Search\", \"Vector Search\"],  # TODO: Restore Lexical Search?\r\n            options_metadata=[{\"icon\": \"SearchHybrid\"}, {\"icon\": \"SearchVector\"}],\r\n            value=\"Vector Search\",\r\n            advanced=True,\r\n            real_time_refresh=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"reranker\",\r\n            display_name=\"Reranker\",\r\n            info=\"Post-retrieval model that re-scores results for optimal relevance ranking.\",\r\n            show=False,\r\n            toggle=True,\r\n        ),\r\n        QueryInput(\r\n            name=\"lexical_terms\",\r\n            display_name=\"Lexical Terms\",\r\n            info=\"Add additional terms/keywords to augment search precision.\",\r\n            placeholder=\"Enter terms to search...\",\r\n            separator=\" \",\r\n            show=False,\r\n            value=\"\",\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"number_of_results\",\r\n            display_name=\"Number of Search Results\",\r\n            info=\"Number of search results to return.\",\r\n            advanced=True,\r\n            value=4,\r\n        ),\r\n        DropdownInput(\r\n            name=\"search_type\",\r\n            display_name=\"Search Type\",\r\n            info=\"Search type to use\",\r\n            options=[\"Similarity\", \"Similarity with score threshold\", \"MMR (Max Marginal Relevance)\"],\r\n            value=\"Similarity\",\r\n            advanced=True,\r\n        ),\r\n        FloatInput(\r\n            name=\"search_score_threshold\",\r\n            display_name=\"Search Score Threshold\",\r\n            info=\"Minimum similarity score threshold for search results. \"\r\n            \"(when using 'Similarity with score threshold')\",\r\n            value=0,\r\n            advanced=True,\r\n        ),\r\n        NestedDictInput(\r\n            name=\"advanced_search_filter\",\r\n            display_name=\"Search Metadata Filter\",\r\n            info=\"Optional dictionary of filters to apply to the search query.\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"autodetect_collection\",\r\n            display_name=\"Autodetect Collection\",\r\n            info=\"Boolean flag to determine whether to autodetect the collection.\",\r\n            advanced=True,\r\n            value=True,\r\n        ),\r\n        StrInput(\r\n            name=\"content_field\",\r\n            display_name=\"Content Field\",\r\n            info=\"Field to use as the text content field for the vector store.\",\r\n            advanced=True,\r\n        ),\r\n        StrInput(\r\n            name=\"deletion_field\",\r\n            display_name=\"Deletion Based On Field\",\r\n            info=\"When this parameter is provided, documents in the target collection with \"\r\n            \"metadata field values matching the input metadata field value will be deleted \"\r\n            \"before new data is loaded.\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"ignore_invalid_documents\",\r\n            display_name=\"Ignore Invalid Documents\",\r\n            info=\"Boolean flag to determine whether to ignore invalid documents at runtime.\",\r\n            advanced=True,\r\n        ),\r\n        NestedDictInput(\r\n            name=\"astradb_vectorstore_kwargs\",\r\n            display_name=\"AstraDBVectorStore Parameters\",\r\n            info=\"Optional dictionary of additional parameters for the AstraDBVectorStore.\",\r\n            advanced=True,\r\n        ),\r\n    ]\r\n\r\n    @classmethod\r\n    def map_cloud_providers(cls):\r\n        # TODO: Programmatically fetch the regions for each cloud provider\r\n        return {\r\n            \"dev\": {\r\n                \"Amazon Web Services\": {\r\n                    \"id\": \"aws\",\r\n                    \"regions\": [\"us-west-2\"],\r\n                },\r\n                \"Google Cloud Platform\": {\r\n                    \"id\": \"gcp\",\r\n                    \"regions\": [\"us-central1\", \"europe-west4\"],\r\n                },\r\n            },\r\n            \"test\": {\r\n                \"Google Cloud Platform\": {\r\n                    \"id\": \"gcp\",\r\n                    \"regions\": [\"us-central1\"],\r\n                },\r\n            },\r\n            \"prod\": {\r\n                \"Amazon Web Services\": {\r\n                    \"id\": \"aws\",\r\n                    \"regions\": [\"us-east-2\", \"ap-south-1\", \"eu-west-1\"],\r\n                },\r\n                \"Google Cloud Platform\": {\r\n                    \"id\": \"gcp\",\r\n                    \"regions\": [\"us-east1\"],\r\n                },\r\n                \"Microsoft Azure\": {\r\n                    \"id\": \"azure\",\r\n                    \"regions\": [\"westus3\"],\r\n                },\r\n            },\r\n        }\r\n\r\n    @classmethod\r\n    def get_vectorize_providers(cls, token: str, environment: str | None = None, api_endpoint: str | None = None):\r\n        try:\r\n            # Get the admin object\r\n            client = DataAPIClient(environment=environment)\r\n            admin_client = client.get_admin()\r\n            db_admin = admin_client.get_database_admin(api_endpoint, token=token)\r\n\r\n            # Get the list of embedding providers\r\n            embedding_providers = db_admin.find_embedding_providers()\r\n\r\n            vectorize_providers_mapping = {}\r\n            # Map the provider display name to the provider key and models\r\n            for provider_key, provider_data in embedding_providers.embedding_providers.items():\r\n                # Get the provider display name and models\r\n                display_name = provider_data.display_name\r\n                models = [model.name for model in provider_data.models]\r\n\r\n                # Build our mapping\r\n                vectorize_providers_mapping[display_name] = [provider_key, models]\r\n\r\n            # Sort the resulting dictionary\r\n            return defaultdict(list, dict(sorted(vectorize_providers_mapping.items())))\r\n        except Exception as _:  # noqa: BLE001\r\n            return {}\r\n\r\n    @classmethod\r\n    async def create_database_api(\r\n        cls,\r\n        new_database_name: str,\r\n        cloud_provider: str,\r\n        region: str,\r\n        token: str,\r\n        environment: str | None = None,\r\n        keyspace: str | None = None,\r\n    ):\r\n        client = DataAPIClient(environment=environment)\r\n\r\n        # Get the admin object\r\n        admin_client = client.get_admin(token=token)\r\n\r\n        # Get the environment, set to prod if null like\r\n        my_env = environment or \"prod\"\r\n\r\n        # Raise a value error if name isn't provided\r\n        if not new_database_name:\r\n            msg = \"Database name is required to create a new database.\"\r\n            raise ValueError(msg)\r\n\r\n        # Call the create database function\r\n        return await admin_client.async_create_database(\r\n            name=new_database_name,\r\n            cloud_provider=cls.map_cloud_providers()[my_env][cloud_provider][\"id\"],\r\n            region=region,\r\n            keyspace=keyspace,\r\n            wait_until_active=False,\r\n        )\r\n\r\n    @classmethod\r\n    async def create_collection_api(\r\n        cls,\r\n        new_collection_name: str,\r\n        token: str,\r\n        api_endpoint: str,\r\n        environment: str | None = None,\r\n        keyspace: str | None = None,\r\n        dimension: int | None = None,\r\n        embedding_generation_provider: str | None = None,\r\n        embedding_generation_model: str | None = None,\r\n        reranker: str | None = None,\r\n    ):\r\n        # Build vectorize options, if needed\r\n        vectorize_options = None\r\n        if not dimension:\r\n            providers = cls.get_vectorize_providers(token=token, environment=environment, api_endpoint=api_endpoint)\r\n            vectorize_options = VectorServiceOptions(\r\n                provider=providers.get(embedding_generation_provider, [None, []])[0],\r\n                model_name=embedding_generation_model,\r\n            )\r\n\r\n        # Raise a value error if name isn't provided\r\n        if not new_collection_name:\r\n            msg = \"Collection name is required to create a new collection.\"\r\n            raise ValueError(msg)\r\n\r\n        # Define the base arguments being passed to the create collection function\r\n        base_args = {\r\n            \"collection_name\": new_collection_name,\r\n            \"token\": token,\r\n            \"api_endpoint\": api_endpoint,\r\n            \"keyspace\": keyspace,\r\n            \"environment\": environment,\r\n            \"embedding_dimension\": dimension,\r\n            \"collection_vector_service_options\": vectorize_options,\r\n        }\r\n\r\n        # Add optional arguments only if environment is \"dev\"\r\n        if environment == \"dev\" and reranker:  # TODO: Remove conditional check soon\r\n            # Split the reranker field into a provider a model name\r\n            provider, _ = reranker.split(\"/\")\r\n            base_args[\"collection_rerank\"] = CollectionRerankOptions(\r\n                service=RerankServiceOptions(provider=provider, model_name=reranker),\r\n            )\r\n            base_args[\"collection_lexical\"] = CollectionLexicalOptions(analyzer=\"STANDARD\")\r\n\r\n        _AstraDBCollectionEnvironment(**base_args)\r\n\r\n    @classmethod\r\n    def get_database_list_static(cls, token: str, environment: str | None = None):\r\n        client = DataAPIClient(environment=environment)\r\n\r\n        # Get the admin object\r\n        admin_client = client.get_admin(token=token)\r\n\r\n        # Get the list of databases\r\n        db_list = admin_client.list_databases()\r\n\r\n        # Generate the api endpoint for each database\r\n        db_info_dict = {}\r\n        for db in db_list:\r\n            try:\r\n                # Get the API endpoint for the database\r\n                api_endpoint = db.regions[0].api_endpoint\r\n\r\n                # Get the number of collections\r\n                try:\r\n                    # Get the number of collections in the database\r\n                    num_collections = len(\r\n                        client.get_database(\r\n                            api_endpoint,\r\n                            token=token,\r\n                        ).list_collection_names()\r\n                    )\r\n                except Exception:  # noqa: BLE001\r\n                    if db.status != \"PENDING\":\r\n                        continue\r\n                    num_collections = 0\r\n\r\n                # Add the database to the dictionary\r\n                db_info_dict[db.name] = {\r\n                    \"api_endpoint\": api_endpoint,\r\n                    \"keyspaces\": db.keyspaces,\r\n                    \"collections\": num_collections,\r\n                    \"status\": db.status if db.status != \"ACTIVE\" else None,\r\n                    \"org_id\": db.org_id if db.org_id else None,\r\n                }\r\n            except Exception:  # noqa: BLE001, S110\r\n                pass\r\n\r\n        return db_info_dict\r\n\r\n    def get_database_list(self):\r\n        return self.get_database_list_static(\r\n            token=self.token,\r\n            environment=self.environment,\r\n        )\r\n\r\n    @classmethod\r\n    def get_api_endpoint_static(\r\n        cls,\r\n        token: str,\r\n        environment: str | None = None,\r\n        api_endpoint: str | None = None,\r\n        database_name: str | None = None,\r\n    ):\r\n        # If the api_endpoint is set, return it\r\n        if api_endpoint:\r\n            return api_endpoint\r\n\r\n        # Check if the database_name is like a url\r\n        if database_name and database_name.startswith(\"https://\"):\r\n            return database_name\r\n\r\n        # If the database is not set, nothing we can do.\r\n        if not database_name:\r\n            return None\r\n\r\n        # Grab the database object\r\n        db = cls.get_database_list_static(token=token, environment=environment).get(database_name)\r\n        if not db:\r\n            return None\r\n\r\n        # Otherwise, get the URL from the database list\r\n        return db.get(\"api_endpoint\")\r\n\r\n    def get_api_endpoint(self):\r\n        return self.get_api_endpoint_static(\r\n            token=self.token,\r\n            environment=self.environment,\r\n            api_endpoint=self.api_endpoint,\r\n            database_name=self.database_name,\r\n        )\r\n\r\n    @classmethod\r\n    def get_database_id_static(cls, api_endpoint: str) -> str | None:\r\n        # Pattern matches standard UUID format: 8-4-4-4-12 hexadecimal characters\r\n        uuid_pattern = r\"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\r\n        match = re.search(uuid_pattern, api_endpoint)\r\n\r\n        return match.group(0) if match else None\r\n\r\n    def get_database_id(self):\r\n        return self.get_database_id_static(api_endpoint=self.get_api_endpoint())\r\n\r\n    def get_keyspace(self):\r\n        keyspace = self.keyspace\r\n\r\n        if keyspace:\r\n            return keyspace.strip()\r\n\r\n        return \"default_keyspace\"\r\n\r\n    def get_database_object(self, api_endpoint: str | None = None):\r\n        try:\r\n            client = DataAPIClient(environment=self.environment)\r\n\r\n            return client.get_database(\r\n                api_endpoint or self.get_api_endpoint(),\r\n                token=self.token,\r\n                keyspace=self.get_keyspace(),\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error fetching database object: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n    def collection_data(self, collection_name: str, database: Database | None = None):\r\n        try:\r\n            if not database:\r\n                client = DataAPIClient(environment=self.environment)\r\n\r\n                database = client.get_database(\r\n                    self.get_api_endpoint(),\r\n                    token=self.token,\r\n                    keyspace=self.get_keyspace(),\r\n                )\r\n\r\n            collection = database.get_collection(collection_name)\r\n\r\n            return collection.estimated_document_count()\r\n        except Exception as e:  # noqa: BLE001\r\n            self.log(f\"Error checking collection data: {e}\")\r\n\r\n            return None\r\n\r\n    def _initialize_database_options(self):\r\n        try:\r\n            return [\r\n                {\r\n                    \"name\": name,\r\n                    \"status\": info[\"status\"],\r\n                    \"collections\": info[\"collections\"],\r\n                    \"api_endpoint\": info[\"api_endpoint\"],\r\n                    \"keyspaces\": info[\"keyspaces\"],\r\n                    \"org_id\": info[\"org_id\"],\r\n                }\r\n                for name, info in self.get_database_list().items()\r\n            ]\r\n        except Exception as e:\r\n            msg = f\"Error fetching database options: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n    @classmethod\r\n    def get_provider_icon(cls, collection: CollectionDescriptor | None = None, provider_name: str | None = None) -> str:\r\n        # Get the provider name from the collection\r\n        provider_name = provider_name or (\r\n            collection.definition.vector.service.provider\r\n            if (\r\n                collection\r\n                and collection.definition\r\n                and collection.definition.vector\r\n                and collection.definition.vector.service\r\n            )\r\n            else None\r\n        )\r\n\r\n        # If there is no provider, use the vector store icon\r\n        if not provider_name or provider_name.lower() == \"bring your own\":\r\n            return \"vectorstores\"\r\n\r\n        # Map provider casings\r\n        case_map = {\r\n            \"nvidia\": \"NVIDIA\",\r\n            \"openai\": \"OpenAI\",\r\n            \"amazon bedrock\": \"AmazonBedrockEmbeddings\",\r\n            \"azure openai\": \"AzureOpenAiEmbeddings\",\r\n            \"cohere\": \"Cohere\",\r\n            \"jina ai\": \"JinaAI\",\r\n            \"mistral ai\": \"MistralAI\",\r\n            \"upstage\": \"Upstage\",\r\n            \"voyage ai\": \"VoyageAI\",\r\n        }\r\n\r\n        # Adjust the casing on some like nvidia\r\n        return case_map[provider_name.lower()] if provider_name.lower() in case_map else provider_name.title()\r\n\r\n    def _initialize_collection_options(self, api_endpoint: str | None = None):\r\n        # Nothing to generate if we don't have an API endpoint yet\r\n        api_endpoint = api_endpoint or self.get_api_endpoint()\r\n        if not api_endpoint:\r\n            return []\r\n\r\n        # Retrieve the database object\r\n        database = self.get_database_object(api_endpoint=api_endpoint)\r\n\r\n        # Get the list of collections\r\n        collection_list = database.list_collections(keyspace=self.get_keyspace())\r\n\r\n        # Return the list of collections and metadata associated\r\n        return [\r\n            {\r\n                \"name\": col.name,\r\n                \"records\": self.collection_data(collection_name=col.name, database=database),\r\n                \"provider\": (\r\n                    col.definition.vector.service.provider\r\n                    if col.definition.vector and col.definition.vector.service\r\n                    else None\r\n                ),\r\n                \"icon\": self.get_provider_icon(collection=col),\r\n                \"model\": (\r\n                    col.definition.vector.service.model_name\r\n                    if col.definition.vector and col.definition.vector.service\r\n                    else None\r\n                ),\r\n            }\r\n            for col in collection_list\r\n        ]\r\n\r\n    def reset_provider_options(self, build_config: dict) -> dict:\r\n        \"\"\"Reset provider options and related configurations in the build_config dictionary.\"\"\"\r\n        # Extract template path for cleaner access\r\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n\r\n        # Get vectorize providers\r\n        vectorize_providers_api = self.get_vectorize_providers(\r\n            token=self.token,\r\n            environment=self.environment,\r\n            api_endpoint=build_config[\"api_endpoint\"][\"value\"],\r\n        )\r\n\r\n        # Create a new dictionary with \"Bring your own\" first\r\n        vectorize_providers: dict[str, list[list[str]]] = {\"Bring your own\": [[], []]}\r\n\r\n        # Add the remaining items (only Nvidia) from the original dictionary\r\n        vectorize_providers.update(\r\n            {\r\n                k: v\r\n                for k, v in vectorize_providers_api.items()\r\n                if k.lower() in [\"nvidia\"]  # TODO: Eventually support more\r\n            }\r\n        )\r\n\r\n        # Set provider options\r\n        provider_field = \"02_embedding_generation_provider\"\r\n        template[provider_field][\"options\"] = list(vectorize_providers.keys())\r\n\r\n        # Add metadata for each provider option\r\n        template[provider_field][\"options_metadata\"] = [\r\n            {\"icon\": self.get_provider_icon(provider_name=provider)} for provider in template[provider_field][\"options\"]\r\n        ]\r\n\r\n        # Get selected embedding provider\r\n        embedding_provider = template[provider_field][\"value\"]\r\n        is_bring_your_own = embedding_provider and embedding_provider == \"Bring your own\"\r\n\r\n        # Configure embedding model field\r\n        model_field = \"03_embedding_generation_model\"\r\n        template[model_field].update(\r\n            {\r\n                \"options\": vectorize_providers.get(embedding_provider, [[], []])[1],\r\n                \"placeholder\": \"Bring your own\" if is_bring_your_own else None,\r\n                \"readonly\": is_bring_your_own,\r\n                \"required\": not is_bring_your_own,\r\n                \"value\": None,\r\n            }\r\n        )\r\n\r\n        # If this is a bring your own, set dimensions to 0\r\n        return self.reset_dimension_field(build_config)\r\n\r\n    def reset_dimension_field(self, build_config: dict) -> dict:\r\n        \"\"\"Reset dimension field options based on provided configuration.\"\"\"\r\n        # Extract template path for cleaner access\r\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n\r\n        # Get selected embedding model\r\n        provider_field = \"02_embedding_generation_provider\"\r\n        embedding_provider = template[provider_field][\"value\"]\r\n        is_bring_your_own = embedding_provider and embedding_provider == \"Bring your own\"\r\n\r\n        # Configure dimension field\r\n        dimension_field = \"04_dimension\"\r\n        dimension_value = 1024 if not is_bring_your_own else None  # TODO: Dynamically figure this out\r\n        template[dimension_field].update(\r\n            {\r\n                \"placeholder\": dimension_value,\r\n                \"value\": dimension_value,\r\n                \"readonly\": not is_bring_your_own,\r\n                \"required\": is_bring_your_own,\r\n            }\r\n        )\r\n\r\n        return build_config\r\n\r\n    def reset_collection_list(self, build_config: dict) -> dict:\r\n        \"\"\"Reset collection list options based on provided configuration.\"\"\"\r\n        # Get collection options\r\n        collection_options = self._initialize_collection_options(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\r\n        # Update collection configuration\r\n        collection_config = build_config[\"collection_name\"]\r\n        collection_config.update(\r\n            {\r\n                \"options\": [col[\"name\"] for col in collection_options],\r\n                \"options_metadata\": [{k: v for k, v in col.items() if k != \"name\"} for col in collection_options],\r\n            }\r\n        )\r\n\r\n        # Reset selected collection if not in options\r\n        if collection_config[\"value\"] not in collection_config[\"options\"]:\r\n            collection_config[\"value\"] = \"\"\r\n\r\n        # Set advanced status based on database selection\r\n        collection_config[\"show\"] = bool(build_config[\"database_name\"][\"value\"])\r\n\r\n        return build_config\r\n\r\n    def reset_database_list(self, build_config: dict) -> dict:\r\n        \"\"\"Reset database list options and related configurations.\"\"\"\r\n        # Get database options\r\n        database_options = self._initialize_database_options()\r\n\r\n        # Update cloud provider options\r\n        env = self.environment\r\n        template = build_config[\"database_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n        template[\"02_cloud_provider\"][\"options\"] = list(self.map_cloud_providers()[env].keys())\r\n\r\n        # Update database configuration\r\n        database_config = build_config[\"database_name\"]\r\n        database_config.update(\r\n            {\r\n                \"options\": [db[\"name\"] for db in database_options],\r\n                \"options_metadata\": [{k: v for k, v in db.items() if k != \"name\"} for db in database_options],\r\n            }\r\n        )\r\n\r\n        # Reset selections if value not in options\r\n        if database_config[\"value\"] not in database_config[\"options\"]:\r\n            database_config[\"value\"] = \"\"\r\n            build_config[\"api_endpoint\"][\"value\"] = \"\"\r\n            build_config[\"collection_name\"][\"show\"] = False\r\n\r\n        # Set advanced status based on token presence\r\n        database_config[\"show\"] = bool(build_config[\"token\"][\"value\"])\r\n\r\n        return build_config\r\n\r\n    def reset_build_config(self, build_config: dict) -> dict:\r\n        \"\"\"Reset all build configuration options to default empty state.\"\"\"\r\n        # Reset database configuration\r\n        database_config = build_config[\"database_name\"]\r\n        database_config.update({\"options\": [], \"options_metadata\": [], \"value\": \"\", \"show\": False})\r\n        build_config[\"api_endpoint\"][\"value\"] = \"\"\r\n\r\n        # Reset collection configuration\r\n        collection_config = build_config[\"collection_name\"]\r\n        collection_config.update({\"options\": [], \"options_metadata\": [], \"value\": \"\", \"show\": False})\r\n\r\n        return build_config\r\n\r\n    def _handle_hybrid_search_options(self, build_config: dict) -> dict:\r\n        \"\"\"Set hybrid search options in the build configuration.\"\"\"\r\n        # Detect what hybrid options are available\r\n        # Get the admin object\r\n        client = DataAPIClient(environment=self.environment)\r\n        admin_client = client.get_admin()\r\n        db_admin = admin_client.get_database_admin(self.get_api_endpoint(), token=self.token)\r\n\r\n        # We will try to get the reranking providers to see if its hybrid emabled\r\n        try:\r\n            providers = db_admin.find_reranking_providers()\r\n            build_config[\"reranker\"][\"options\"] = [\r\n                model.name for provider_data in providers.reranking_providers.values() for model in provider_data.models\r\n            ]\r\n            build_config[\"reranker\"][\"options_metadata\"] = [\r\n                {\"icon\": self.get_provider_icon(provider_name=model.name.split(\"/\")[0])}\r\n                for provider in providers.reranking_providers.values()\r\n                for model in provider.models\r\n            ]\r\n            build_config[\"reranker\"][\"value\"] = build_config[\"reranker\"][\"options\"][0]\r\n\r\n            # Set the default search field to hybrid search\r\n            build_config[\"search_method\"][\"show\"] = True\r\n            build_config[\"search_method\"][\"options\"] = [\"Hybrid Search\", \"Vector Search\"]\r\n            build_config[\"search_method\"][\"value\"] = \"Hybrid Search\"\r\n        except Exception as _:  # noqa: BLE001\r\n            build_config[\"reranker\"][\"options\"] = []\r\n            build_config[\"reranker\"][\"options_metadata\"] = []\r\n\r\n            # Set the default search field to vector search\r\n            build_config[\"search_method\"][\"show\"] = False\r\n            build_config[\"search_method\"][\"options\"] = [\"Vector Search\"]\r\n            build_config[\"search_method\"][\"value\"] = \"Vector Search\"\r\n\r\n        # Set reranker and lexical terms options based on search method\r\n        build_config[\"reranker\"][\"toggle_value\"] = True\r\n        build_config[\"reranker\"][\"show\"] = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\r\n        build_config[\"reranker\"][\"toggle_disable\"] = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\r\n        if build_config[\"reranker\"][\"show\"]:\r\n            build_config[\"search_type\"][\"value\"] = \"Similarity\"\r\n\r\n        return build_config\r\n\r\n    async def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\r\n        \"\"\"Update build configuration based on field name and value.\"\"\"\r\n        # Early return if no token provided\r\n        if not self.token:\r\n            return self.reset_build_config(build_config)\r\n\r\n        # Database creation callback\r\n        if field_name == \"database_name\" and isinstance(field_value, dict):\r\n            if \"01_new_database_name\" in field_value:\r\n                await self._create_new_database(build_config, field_value)\r\n                return self.reset_collection_list(build_config)\r\n            return self._update_cloud_regions(build_config, field_value)\r\n\r\n        # Collection creation callback\r\n        if field_name == \"collection_name\" and isinstance(field_value, dict):\r\n            # Case 1: New collection creation\r\n            if \"01_new_collection_name\" in field_value:\r\n                await self._create_new_collection(build_config, field_value)\r\n                return build_config\r\n\r\n            # Case 2: Update embedding provider options\r\n            if \"02_embedding_generation_provider\" in field_value:\r\n                return self.reset_provider_options(build_config)\r\n\r\n            # Case 3: Update dimension field\r\n            if \"03_embedding_generation_model\" in field_value:\r\n                return self.reset_dimension_field(build_config)\r\n\r\n        # Initial execution or token/environment change\r\n        first_run = field_name == \"collection_name\" and not field_value and not build_config[\"database_name\"][\"options\"]\r\n        if first_run or field_name in {\"token\", \"environment\"}:\r\n            return self.reset_database_list(build_config)\r\n\r\n        # Database selection change\r\n        if field_name == \"database_name\" and not isinstance(field_value, dict):\r\n            return self._handle_database_selection(build_config, field_value)\r\n\r\n        # Keyspace selection change\r\n        if field_name == \"keyspace\":\r\n            return self.reset_collection_list(build_config)\r\n\r\n        # Collection selection change\r\n        if field_name == \"collection_name\" and not isinstance(field_value, dict):\r\n            return self._handle_collection_selection(build_config, field_value)\r\n\r\n        # Search method selection change\r\n        if field_name == \"search_method\":\r\n            is_vector_search = field_value == \"Vector Search\"\r\n            is_autodetect = build_config[\"autodetect_collection\"][\"value\"]\r\n\r\n            # Configure lexical terms (same for both cases)\r\n            build_config[\"lexical_terms\"][\"show\"] = not is_vector_search\r\n            build_config[\"lexical_terms\"][\"value\"] = \"\" if is_vector_search else build_config[\"lexical_terms\"][\"value\"]\r\n\r\n            # Disable reranker disabling if hybrid search is selected\r\n            build_config[\"reranker\"][\"toggle_disable\"] = not is_vector_search\r\n            build_config[\"reranker\"][\"toggle_value\"] = True\r\n            build_config[\"reranker\"][\"value\"] = build_config[\"reranker\"][\"options\"][0]\r\n\r\n            # Toggle search type and score threshold based on search method\r\n            build_config[\"search_type\"][\"show\"] = is_vector_search\r\n            build_config[\"search_score_threshold\"][\"show\"] = is_vector_search\r\n\r\n            # Make sure the search_type is set to \"Similarity\"\r\n            if not is_vector_search or is_autodetect:\r\n                build_config[\"search_type\"][\"value\"] = \"Similarity\"\r\n\r\n        return build_config\r\n\r\n    async def _create_new_database(self, build_config: dict, field_value: dict) -> None:\r\n        \"\"\"Create a new database and update build config options.\"\"\"\r\n        try:\r\n            await self.create_database_api(\r\n                new_database_name=field_value[\"01_new_database_name\"],\r\n                token=self.token,\r\n                keyspace=self.get_keyspace(),\r\n                environment=self.environment,\r\n                cloud_provider=field_value[\"02_cloud_provider\"],\r\n                region=field_value[\"03_region\"],\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error creating database: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n        build_config[\"database_name\"][\"options\"].append(field_value[\"01_new_database_name\"])\r\n        build_config[\"database_name\"][\"options_metadata\"].append(\r\n            {\r\n                \"status\": \"PENDING\",\r\n                \"collections\": 0,\r\n                \"api_endpoint\": None,\r\n                \"keyspaces\": [self.get_keyspace()],\r\n                \"org_id\": None,\r\n            }\r\n        )\r\n\r\n    def _update_cloud_regions(self, build_config: dict, field_value: dict) -> dict:\r\n        \"\"\"Update cloud provider regions in build config.\"\"\"\r\n        env = self.environment\r\n        cloud_provider = field_value[\"02_cloud_provider\"]\r\n\r\n        # Update the region options based on the selected cloud provider\r\n        template = build_config[\"database_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n        template[\"03_region\"][\"options\"] = self.map_cloud_providers()[env][cloud_provider][\"regions\"]\r\n\r\n        # Reset the the 03_region value if it's not in the new options\r\n        if template[\"03_region\"][\"value\"] not in template[\"03_region\"][\"options\"]:\r\n            template[\"03_region\"][\"value\"] = None\r\n\r\n        return build_config\r\n\r\n    async def _create_new_collection(self, build_config: dict, field_value: dict) -> None:\r\n        \"\"\"Create a new collection and update build config options.\"\"\"\r\n        embedding_provider = field_value.get(\"02_embedding_generation_provider\")\r\n        try:\r\n            await self.create_collection_api(\r\n                new_collection_name=field_value[\"01_new_collection_name\"],\r\n                token=self.token,\r\n                api_endpoint=build_config[\"api_endpoint\"][\"value\"],\r\n                environment=self.environment,\r\n                keyspace=self.get_keyspace(),\r\n                dimension=field_value.get(\"04_dimension\") if embedding_provider == \"Bring your own\" else None,\r\n                embedding_generation_provider=embedding_provider,\r\n                embedding_generation_model=field_value.get(\"03_embedding_generation_model\"),\r\n                reranker=self.reranker,\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error creating collection: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n        provider = embedding_provider.lower() if embedding_provider and embedding_provider != \"Bring your own\" else None\r\n        build_config[\"collection_name\"].update(\r\n            {\r\n                \"value\": field_value[\"01_new_collection_name\"],\r\n                \"options\": build_config[\"collection_name\"][\"options\"] + [field_value[\"01_new_collection_name\"]],\r\n            }\r\n        )\r\n        build_config[\"embedding_model\"][\"show\"] = not bool(provider)\r\n        build_config[\"embedding_model\"][\"required\"] = not bool(provider)\r\n        build_config[\"collection_name\"][\"options_metadata\"].append(\r\n            {\r\n                \"records\": 0,\r\n                \"provider\": provider,\r\n                \"icon\": self.get_provider_icon(provider_name=provider),\r\n                \"model\": field_value.get(\"03_embedding_generation_model\"),\r\n            }\r\n        )\r\n\r\n        # Make sure we always show the reranker options if the collection is hybrid enabled\r\n        # And right now they always are\r\n        build_config[\"lexical_terms\"][\"show\"] = True\r\n\r\n    def _handle_database_selection(self, build_config: dict, field_value: str) -> dict:\r\n        \"\"\"Handle database selection and update related configurations.\"\"\"\r\n        build_config = self.reset_database_list(build_config)\r\n\r\n        # Reset collection list if database selection changes\r\n        if field_value not in build_config[\"database_name\"][\"options\"]:\r\n            build_config[\"database_name\"][\"value\"] = \"\"\r\n            return build_config\r\n\r\n        # Get the api endpoint for the selected database\r\n        index = build_config[\"database_name\"][\"options\"].index(field_value)\r\n        build_config[\"api_endpoint\"][\"value\"] = build_config[\"database_name\"][\"options_metadata\"][index][\"api_endpoint\"]\r\n\r\n        # Get the org_id for the selected database\r\n        org_id = build_config[\"database_name\"][\"options_metadata\"][index][\"org_id\"]\r\n        if not org_id:\r\n            return build_config\r\n\r\n        # Update the list of keyspaces based on the db info\r\n        build_config[\"keyspace\"][\"options\"] = build_config[\"database_name\"][\"options_metadata\"][index][\"keyspaces\"]\r\n        build_config[\"keyspace\"][\"value\"] = (\r\n            build_config[\"keyspace\"][\"options\"] and build_config[\"keyspace\"][\"options\"][0]\r\n            if build_config[\"keyspace\"][\"value\"] not in build_config[\"keyspace\"][\"options\"]\r\n            else build_config[\"keyspace\"][\"value\"]\r\n        )\r\n\r\n        # Get the database id for the selected database\r\n        db_id = self.get_database_id_static(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\r\n        keyspace = self.get_keyspace()\r\n\r\n        # Update the helper text for the embedding provider field\r\n        template = build_config[\"collection_name\"][\"dialog_inputs\"][\"fields\"][\"data\"][\"node\"][\"template\"]\r\n        template[\"02_embedding_generation_provider\"][\"helper_text\"] = (\r\n            \"To create collections with more embedding provider options, go to \"\r\n            f'<a class=\"underline\" target=\"_blank\" rel=\"noopener noreferrer\" '\r\n            f'href=\"https://astra.datastax.com/org/{org_id}/database/{db_id}/data-explorer?createCollection=1&namespace={keyspace}\">'\r\n            \"your database in Astra DB</a>.\"\r\n        )\r\n\r\n        # Reset provider options\r\n        build_config = self.reset_provider_options(build_config)\r\n\r\n        # Handle hybrid search options\r\n        build_config = self._handle_hybrid_search_options(build_config)\r\n\r\n        return self.reset_collection_list(build_config)\r\n\r\n    def _handle_collection_selection(self, build_config: dict, field_value: str) -> dict:\r\n        \"\"\"Handle collection selection and update embedding options.\"\"\"\r\n        build_config[\"autodetect_collection\"][\"value\"] = True\r\n        build_config = self.reset_collection_list(build_config)\r\n\r\n        # Reset embedding model if collection selection changes\r\n        if field_value and field_value not in build_config[\"collection_name\"][\"options\"]:\r\n            build_config[\"collection_name\"][\"options\"].append(field_value)\r\n            build_config[\"collection_name\"][\"options_metadata\"].append(\r\n                {\r\n                    \"records\": 0,\r\n                    \"provider\": None,\r\n                    \"icon\": \"vectorstores\",\r\n                    \"model\": None,\r\n                }\r\n            )\r\n            build_config[\"autodetect_collection\"][\"value\"] = False\r\n\r\n        if not field_value:\r\n            return build_config\r\n\r\n        # Get the selected collection index\r\n        index = build_config[\"collection_name\"][\"options\"].index(field_value)\r\n\r\n        # Set the provider of the selected collection\r\n        provider = build_config[\"collection_name\"][\"options_metadata\"][index][\"provider\"]\r\n        build_config[\"embedding_model\"][\"show\"] = not bool(provider)\r\n        build_config[\"embedding_model\"][\"required\"] = not bool(provider)\r\n\r\n        # Grab the collection object\r\n        database = self.get_database_object(api_endpoint=build_config[\"api_endpoint\"][\"value\"])\r\n        collection = database.get_collection(\r\n            name=field_value,\r\n            keyspace=build_config[\"keyspace\"][\"value\"],\r\n        )\r\n\r\n        # Check if hybrid and lexical are enabled\r\n        col_options = collection.options()\r\n        hyb_enabled = col_options.rerank and col_options.rerank.enabled\r\n        lex_enabled = col_options.lexical and col_options.lexical.enabled\r\n        user_hyb_enabled = build_config[\"search_method\"][\"value\"] == \"Hybrid Search\"\r\n\r\n        # Show lexical terms if the collection is hybrid enabled\r\n        build_config[\"lexical_terms\"][\"show\"] = hyb_enabled and lex_enabled and user_hyb_enabled\r\n\r\n        return build_config\r\n\r\n    @check_cached_vector_store\r\n    def build_vector_store(self):\r\n        try:\r\n            from langchain_astradb import AstraDBVectorStore\r\n        except ImportError as e:\r\n            msg = (\r\n                \"Could not import langchain Astra DB integration package. \"\r\n                \"Please install it with `pip install langchain-astradb`.\"\r\n            )\r\n            raise ImportError(msg) from e\r\n\r\n        # Get the embedding model and additional params\r\n        embedding_params = {\"embedding\": self.embedding_model} if self.embedding_model else {}\r\n\r\n        # Get the additional parameters\r\n        additional_params = self.astradb_vectorstore_kwargs or {}\r\n\r\n        # Get Langflow version and platform information\r\n        __version__ = get_version_info()[\"version\"]\r\n        langflow_prefix = \"\"\r\n        # if os.getenv(\"AWS_EXECUTION_ENV\") == \"AWS_ECS_FARGATE\":  # TODO: More precise way of detecting\r\n        #     langflow_prefix = \"ds-\"\r\n\r\n        # Get the database object\r\n        database = self.get_database_object()\r\n        autodetect = self.collection_name in database.list_collection_names() and self.autodetect_collection\r\n\r\n        # Bundle up the auto-detect parameters\r\n        autodetect_params = {\r\n            \"autodetect_collection\": autodetect,\r\n            \"content_field\": (\r\n                self.content_field\r\n                if self.content_field and embedding_params\r\n                else (\r\n                    \"page_content\"\r\n                    if embedding_params\r\n                    and self.collection_data(collection_name=self.collection_name, database=database) == 0\r\n                    else None\r\n                )\r\n            ),\r\n            \"ignore_invalid_documents\": self.ignore_invalid_documents,\r\n        }\r\n\r\n        # Choose HybridSearchMode based on the selected param\r\n        hybrid_search_mode = HybridSearchMode.DEFAULT if self.search_method == \"Hybrid Search\" else HybridSearchMode.OFF\r\n\r\n        # Attempt to build the Vector Store object\r\n        try:\r\n            vector_store = AstraDBVectorStore(\r\n                # Astra DB Authentication Parameters\r\n                token=self.token,\r\n                api_endpoint=database.api_endpoint,\r\n                namespace=database.keyspace,\r\n                collection_name=self.collection_name,\r\n                environment=self.environment,\r\n                # Hybrid Search Parameters\r\n                hybrid_search=hybrid_search_mode,\r\n                # Astra DB Usage Tracking Parameters\r\n                ext_callers=[(f\"{langflow_prefix}langflow\", __version__)],\r\n                # Astra DB Vector Store Parameters\r\n                **autodetect_params,\r\n                **embedding_params,\r\n                **additional_params,\r\n            )\r\n        except Exception as e:\r\n            msg = f\"Error initializing AstraDBVectorStore: {e}\"\r\n            raise ValueError(msg) from e\r\n\r\n        # Add documents to the vector store\r\n        self._add_documents_to_vector_store(vector_store)\r\n\r\n        return vector_store\r\n\r\n    def _add_documents_to_vector_store(self, vector_store) -> None:\r\n        self.ingest_data = self._prepare_ingest_data()\r\n\r\n        documents = []\r\n        for _input in self.ingest_data or []:\r\n            if isinstance(_input, Data):\r\n                documents.append(_input.to_lc_document())\r\n            else:\r\n                msg = \"Vector Store Inputs must be Data objects.\"\r\n                raise TypeError(msg)\r\n\r\n        if documents and self.deletion_field:\r\n            self.log(f\"Deleting documents where {self.deletion_field}\")\r\n            try:\r\n                database = self.get_database_object()\r\n                collection = database.get_collection(self.collection_name, keyspace=database.keyspace)\r\n                delete_values = list({doc.metadata[self.deletion_field] for doc in documents})\r\n                self.log(f\"Deleting documents where {self.deletion_field} matches {delete_values}.\")\r\n                collection.delete_many({f\"metadata.{self.deletion_field}\": {\"$in\": delete_values}})\r\n            except Exception as e:\r\n                msg = f\"Error deleting documents from AstraDBVectorStore based on '{self.deletion_field}': {e}\"\r\n                raise ValueError(msg) from e\r\n\r\n        if documents:\r\n            self.log(f\"Adding {len(documents)} documents to the Vector Store.\")\r\n            try:\r\n                vector_store.add_documents(documents)\r\n            except Exception as e:\r\n                msg = f\"Error adding documents to AstraDBVectorStore: {e}\"\r\n                raise ValueError(msg) from e\r\n        else:\r\n            self.log(\"No documents to add to the Vector Store.\")\r\n\r\n    def _map_search_type(self) -> str:\r\n        search_type_mapping = {\r\n            \"Similarity with score threshold\": \"similarity_score_threshold\",\r\n            \"MMR (Max Marginal Relevance)\": \"mmr\",\r\n        }\r\n\r\n        return search_type_mapping.get(self.search_type, \"similarity\")\r\n\r\n    def _build_search_args(self):\r\n        # Clean up the search query\r\n        query = self.search_query if isinstance(self.search_query, str) and self.search_query.strip() else None\r\n        lexical_terms = self.lexical_terms or None\r\n\r\n        # Check if we have a search query, and if so set the args\r\n        if query:\r\n            args = {\r\n                \"query\": query,\r\n                \"search_type\": self._map_search_type(),\r\n                \"k\": self.number_of_results,\r\n                \"score_threshold\": self.search_score_threshold,\r\n                \"lexical_query\": lexical_terms,\r\n            }\r\n        elif self.advanced_search_filter:\r\n            args = {\r\n                \"n\": self.number_of_results,\r\n            }\r\n        else:\r\n            return {}\r\n\r\n        filter_arg = self.advanced_search_filter or {}\r\n        if filter_arg:\r\n            args[\"filter\"] = filter_arg\r\n\r\n        return args\r\n\r\n    def search_documents(self, vector_store=None) -> list[Data]:\r\n        vector_store = vector_store or self.build_vector_store()\r\n        \r\n        # Create a list of queries to process\r\n        queries = [self.search_query]\r\n        if hasattr(self, 'search_query_2') and self.search_query_2 and isinstance(self.search_query_2, str) and self.search_query_2.strip():\r\n            queries.append(self.search_query_2)\r\n        if hasattr(self, 'search_query_3') and self.search_query_3 and isinstance(self.search_query_3, str) and self.search_query_3.strip():\r\n            queries.append(self.search_query_3)\r\n        \r\n        self.log(f\"Processing {len(queries)} search queries\")\r\n        \r\n        # Store all retrieved documents\r\n        all_docs = []\r\n        \r\n        # Process each query\r\n        for idx, query in enumerate(queries, 1):\r\n            if not query:\r\n                continue\r\n                \r\n            self.log(f\"Search input #{idx}: {query}\")\r\n            self.log(f\"Search type: {self.search_type}\")\r\n            self.log(f\"Number of results: {self.number_of_results}\")\r\n            self.log(f\"store.hybrid_search: {vector_store.hybrid_search}\")\r\n            self.log(f\"Lexical terms: {self.lexical_terms}\")\r\n            self.log(f\"Reranker: {self.reranker}\")\r\n            \r\n            # Store the original search query\r\n            original_query = self.search_query\r\n            # Set the current query as search_query\r\n            self.search_query = query\r\n            \r\n            try:\r\n                search_args = self._build_search_args()\r\n            except Exception as e:\r\n                self.search_query = original_query  # Restore original query\r\n                msg = f\"Error in AstraDBVectorStore._build_search_args for query #{idx}: {e}\"\r\n                raise ValueError(msg) from e\r\n                \r\n            if not search_args:\r\n                self.log(f\"No search input or filters provided for query #{idx}. Skipping.\")\r\n                continue\r\n                \r\n            docs = []\r\n            search_method = \"search\" if \"query\" in search_args else \"metadata_search\"\r\n            \r\n            try:\r\n                self.log(f\"Calling vector_store.{search_method} with args: {search_args}\")\r\n                docs = getattr(vector_store, search_method)(**search_args)\r\n                self.log(f\"Retrieved {len(docs)} documents for query #{idx}\")\r\n                all_docs.extend(docs)\r\n            except Exception as e:\r\n                self.search_query = original_query  # Restore original query\r\n                msg = f\"Error performing {search_method} in AstraDBVectorStore for query #{idx}: {e}\"\r\n                raise ValueError(msg) from e\r\n            \r\n            # Restore the original search query\r\n            self.search_query = original_query\r\n        \r\n        # Deduplicate results if requested\r\n        if hasattr(self, 'deduplicate_results') and self.deduplicate_results:\r\n            # Create a set to track unique document content\r\n            seen_content = set()\r\n            unique_docs = []\r\n            \r\n            for doc in all_docs:\r\n                # Use page_content as a key for deduplication\r\n                content_hash = hash(doc.page_content)\r\n                if content_hash not in seen_content:\r\n                    seen_content.add(content_hash)\r\n                    unique_docs.append(doc)\r\n            \r\n            self.log(f\"Deduplicated from {len(all_docs)} to {len(unique_docs)} documents\")\r\n            all_docs = unique_docs\r\n        \r\n        self.log(f\"Total retrieved documents: {len(all_docs)}\")\r\n        \r\n        data = docs_to_data(all_docs)\r\n        self.log(f\"Converted documents to data: {len(data)}\")\r\n        self.status = data\r\n        \r\n        return data\r\n\r\n    def get_retriever_kwargs(self):\r\n        # For retrievers, we'll just use the primary search query\r\n        # This keeps compatibility with existing retriever interfaces\r\n        search_args = self._build_search_args()\r\n        \r\n        return {\r\n            \"search_type\": self._map_search_type(),\r\n            \"search_kwargs\": search_args,\r\n        }"
              },
              "collection_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {
                  "fields": {
                    "data": {
                      "node": {
                        "description": "Please allow several seconds for creation to complete.",
                        "display_name": "Create new collection",
                        "field_order": [
                          "01_new_collection_name",
                          "02_embedding_generation_provider",
                          "03_embedding_generation_model",
                          "04_dimension"
                        ],
                        "name": "create_collection",
                        "template": {
                          "01_new_collection_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Name",
                            "dynamic": false,
                            "info": "Name of the new collection to create in Astra DB.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_collection_name",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "02_embedding_generation_provider": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Embedding generation method",
                            "dynamic": false,
                            "helper_text": "To create collections with more embedding provider options, go to <a class=\"underline\" target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://astra.datastax.com/org/72c50b26-728b-4a86-8ee5-9dc701bc5adf/database/6feab22e-d3d5-4e4a-b788-cd5f2bbd2b7a/data-explorer?createCollection=1&namespace=default_keyspace\">your database in Astra DB</a>.",
                            "info": "Provider to use for generating embeddings.",
                            "name": "embedding_generation_provider",
                            "options": [
                              "Bring your own",
                              "Nvidia"
                            ],
                            "options_metadata": [
                              {
                                "icon": "vectorstores"
                              },
                              {
                                "icon": "NVIDIA"
                              }
                            ],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "03_embedding_generation_model": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Embedding model",
                            "dynamic": false,
                            "info": "Model to use for generating embeddings.",
                            "name": "embedding_generation_model",
                            "options": [],
                            "options_metadata": [],
                            "placeholder": null,
                            "readonly": "",
                            "real_time_refresh": true,
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": null
                          },
                          "04_dimension": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Dimensions",
                            "dynamic": false,
                            "info": "Dimensions of the embeddings to generate.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "dimension",
                            "placeholder": 1024,
                            "readonly": true,
                            "required": "",
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1024
                          }
                        }
                      }
                    }
                  },
                  "functionality": "create"
                },
                "display_name": "Collection",
                "dynamic": false,
                "info": "The name of the collection within Astra DB where the vectors will be stored.",
                "load_from_db": false,
                "name": "collection_name",
                "options": [
                  "textbook"
                ],
                "options_metadata": [
                  {
                    "icon": "vectorstores",
                    "model": null,
                    "provider": null,
                    "records": 154
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": true,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "textbook"
              },
              "content_field": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Content Field",
                "dynamic": false,
                "info": "Field to use as the text content field for the vector store.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "content_field",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "database_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {
                  "fields": {
                    "data": {
                      "node": {
                        "description": "Please allow several minutes for creation to complete.",
                        "display_name": "Create new database",
                        "field_order": [
                          "01_new_database_name",
                          "02_cloud_provider",
                          "03_region"
                        ],
                        "name": "create_database",
                        "template": {
                          "01_new_database_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Name",
                            "dynamic": false,
                            "info": "Name of the new database to create in Astra DB.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_database_name",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "02_cloud_provider": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Cloud provider",
                            "dynamic": false,
                            "info": "Cloud provider for the new database.",
                            "name": "cloud_provider",
                            "options": [
                              "Amazon Web Services",
                              "Google Cloud Platform",
                              "Microsoft Azure"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "03_region": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Region",
                            "dynamic": false,
                            "info": "Region for the new database.",
                            "name": "region",
                            "options": [],
                            "options_metadata": [],
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          }
                        }
                      }
                    }
                  },
                  "functionality": "create"
                },
                "display_name": "Database",
                "dynamic": false,
                "info": "The Database name for the Astra DB instance.",
                "load_from_db": false,
                "name": "database_name",
                "options": [
                  "G11 - History Text Book"
                ],
                "options_metadata": [
                  {
                    "api_endpoint": "https://6feab22e-d3d5-4e4a-b788-cd5f2bbd2b7a-us-east-2.apps.astra.datastax.com",
                    "collections": 1,
                    "keyspaces": [
                      "default_keyspace"
                    ],
                    "org_id": "72c50b26-728b-4a86-8ee5-9dc701bc5adf",
                    "status": null
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "refresh_button": true,
                "required": true,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "G11 - History Text Book"
              },
              "deduplicate_results": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Deduplicate Results",
                "dynamic": false,
                "info": "Remove duplicate documents from the combined search results.",
                "list": false,
                "list_add_label": "Add More",
                "name": "deduplicate_results",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "deletion_field": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Deletion Based On Field",
                "dynamic": false,
                "info": "When this parameter is provided, documents in the target collection with metadata field values matching the input metadata field value will be deleted before new data is loaded.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "deletion_field",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "embedding_model": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Embedding Model",
                "dynamic": false,
                "info": "Specify the Embedding Model. Not required for Astra Vectorize collections.",
                "input_types": [
                  "Embeddings"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "embedding_model",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "environment": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Environment",
                "dynamic": false,
                "info": "The environment for the Astra DB API Endpoint.",
                "name": "environment",
                "options": [
                  "prod",
                  "test",
                  "dev"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "prod"
              },
              "ignore_invalid_documents": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Ignore Invalid Documents",
                "dynamic": false,
                "info": "Boolean flag to determine whether to ignore invalid documents at runtime.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ignore_invalid_documents",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "ingest_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Ingest Data",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Data",
                  "DataFrame"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "ingest_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "keyspace": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Keyspace",
                "dynamic": false,
                "info": "Optional keyspace within Astra DB to use for the collection.",
                "load_from_db": false,
                "name": "keyspace",
                "options": [
                  "default_keyspace"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "default_keyspace"
              },
              "lexical_terms": {
                "_input_type": "QueryInput",
                "advanced": true,
                "display_name": "Lexical Terms",
                "dynamic": false,
                "info": "Add additional terms/keywords to augment search precision.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "lexical_terms",
                "placeholder": "Enter terms to search...",
                "required": false,
                "separator": " ",
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "query",
                "value": ""
              },
              "number_of_results": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Search Results",
                "dynamic": false,
                "info": "Number of search results to return.",
                "list": false,
                "list_add_label": "Add More",
                "name": "number_of_results",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 4
              },
              "reranker": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Reranker",
                "dynamic": false,
                "info": "Post-retrieval model that re-scores results for optimal relevance ranking.",
                "load_from_db": false,
                "name": "reranker",
                "options": [
                  "nvidia/llama-3.2-nv-rerankqa-1b-v2"
                ],
                "options_metadata": [
                  {
                    "icon": "NVIDIA"
                  }
                ],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": true,
                "toggle_disable": true,
                "toggle_value": true,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "nvidia/llama-3.2-nv-rerankqa-1b-v2"
              },
              "search_method": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Search Method",
                "dynamic": false,
                "info": "Determine how your content is matched: Vector finds semantic similarity, and Hybrid Search (suggested) combines both approaches with a reranker.",
                "name": "search_method",
                "options": [
                  "Hybrid Search",
                  "Vector Search"
                ],
                "options_metadata": [
                  {
                    "icon": "SearchHybrid"
                  },
                  {
                    "icon": "SearchVector"
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Hybrid Search"
              },
              "search_query": {
                "_input_type": "QueryInput",
                "advanced": false,
                "display_name": "Search Query",
                "dynamic": false,
                "info": "Enter a query to run a similarity search.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "search_query",
                "placeholder": "Enter a query...",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "query",
                "value": ""
              },
              "search_query_2": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Second Search Query",
                "dynamic": false,
                "info": "Second query to search for in the vector database.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "search_query_2",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "search_query_3": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Third Search Query",
                "dynamic": false,
                "info": "Third query to search for in the vector database.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "search_query_3",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "search_score_threshold": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Search Score Threshold",
                "dynamic": false,
                "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
                "list": false,
                "list_add_label": "Add More",
                "name": "search_score_threshold",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": 0
              },
              "search_type": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Search Type",
                "dynamic": false,
                "info": "Search type to use",
                "name": "search_type",
                "options": [
                  "Similarity",
                  "Similarity with score threshold",
                  "MMR (Max Marginal Relevance)"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Similarity"
              },
              "should_cache_vector_store": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Cache Vector Store",
                "dynamic": false,
                "info": "If True, the vector store will be cached for the current build of the component. This is useful for components that have multiple output methods and want to share the same vector store.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_cache_vector_store",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "token": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Astra DB Application Token",
                "dynamic": false,
                "info": "Authentication token for accessing Astra DB.",
                "input_types": [],
                "load_from_db": true,
                "name": "token",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "AstraDB"
        },
        "id": "AstraDB-XcO2c",
        "measured": {
          "height": 858,
          "width": 320
        },
        "position": {
          "x": 5043.088699081982,
          "y": 2521.44953995332
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "RemoveDuplicates-Im6AN",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Removes duplicate Data objects from a list based on the 'text' column.",
            "display_name": "Remove Duplicates",
            "documentation": "",
            "edited": true,
            "field_order": [
              "data_list"
            ],
            "frozen": false,
            "icon": "filter",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Deduplicated Data List",
                "hidden": false,
                "method": "remove_duplicates",
                "name": "deduplicated_data_list",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import List\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, Output\nfrom langflow.schema import Data\n\nclass RemoveDuplicatesComponent(Component):\n    display_name = \"Remove Duplicates\"\n    description = \"Removes duplicate Data objects from a list based on the 'text' column.\"\n    icon = \"filter\"\n    name = \"RemoveDuplicates\"\n    inputs = [\n        DataInput(\n            name=\"data_list\",\n            display_name=\"Data List\",\n            info=\"List of Data objects to remove duplicates from.\",\n            is_list=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Deduplicated Data List\", name=\"deduplicated_data_list\", method=\"remove_duplicates\"),\n    ]\n\n    def remove_duplicates(self) -> List[Data]:\n        data_list: List[Data] = self.data_list if isinstance(self.data_list, list) else []\n        unique_data_list = []\n        seen_texts = set()\n        for data_item in data_list:\n            if isinstance(data_item, Data) and isinstance(data_item.data, dict):\n                text = data_item.data.get(\"page\")\n                if text is not None and text not in seen_texts:\n                    seen_texts.add(text)\n                    unique_data_list.append(data_item)\n\n        self.status = unique_data_list # f\"Removed {len(data_list) - len(unique_data_list)} duplicates\"\n        return unique_data_list\n"
              },
              "data_list": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Data List",
                "dynamic": false,
                "info": "List of Data objects to remove duplicates from.",
                "input_types": [
                  "Data"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "data_list",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "RemoveDuplicates"
        },
        "id": "RemoveDuplicates-Im6AN",
        "measured": {
          "height": 211,
          "width": 320
        },
        "position": {
          "x": 6052.543774152299,
          "y": 1129.8802864015072
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-MMfCE",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Format a DataFrame or Data object into text using a template. Enable 'Stringify' to convert input into a readable string instead.",
            "display_name": "Parser",
            "documentation": "",
            "edited": false,
            "field_order": [
              "mode",
              "pattern",
              "input_data",
              "sep"
            ],
            "frozen": false,
            "icon": "braces",
            "key": "ParserComponent",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "hidden": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.001,
            "template": {
              "_type": "Component",
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Clean Data",
                "dynamic": false,
                "info": "Enable to clean the data by removing empty rows and lines in each cell of the DataFrame/ Data object.",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Stringify"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-MMfCE",
        "measured": {
          "height": 311,
          "width": 320
        },
        "position": {
          "x": 8715.822308677905,
          "y": 1250.0073830164538
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt-Axryi",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "context",
                "question"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt",
            "documentation": "",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "prompts",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt Message",
                "hidden": false,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": null,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "context": {
                "advanced": false,
                "display_name": "context",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "context",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "question": {
                "advanced": false,
                "display_name": "question",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "question",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "You are an intelligent educational assistant trained to answer questions using the context provided from a history textbook.\n\nContext:\n{context}\n\nQuestion:\n{question}\n\nPlease generate a clear, factual, and concise answer *only using the context above*. Do not make up any information. \n\nIf the context does not contain enough information to answer the question, respond with:\n\"The provided context does not contain enough information to answer this question.\"\n\nAfter the answer, clearly mention the section and page number that the answer was derived from.\n\nFinal Answer Format:\n\n(answer goes here)\n\nSection : (section goes here)\nPage No : (page number goes here)"
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt"
        },
        "id": "Prompt-Axryi",
        "measured": {
          "height": 492,
          "width": 320
        },
        "position": {
          "x": 6909.5092259378125,
          "y": 985.8006376758442
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GoogleGenerativeAIModel-C84qd",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generate text using Google Generative AI.",
            "display_name": "Google Generative AI",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_output_tokens",
              "model_name",
              "api_key",
              "top_p",
              "temperature",
              "n",
              "top_k",
              "tool_model_enabled"
            ],
            "frozen": false,
            "icon": "GoogleGenerativeAI",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": false,
                "method": "text_response",
                "name": "text_output",
                "options": null,
                "required_inputs": [],
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "hidden": null,
                "method": "build_model",
                "name": "model_output",
                "options": null,
                "required_inputs": [
                  "api_key"
                ],
                "selected": "LanguageModel",
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Google API Key",
                "dynamic": false,
                "info": "The Google API Key to use for the Google Generative AI.",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nimport requests\nfrom loguru import logger\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.google_generative_ai_constants import GOOGLE_GENERATIVE_AI_MODELS\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import DropdownInput, FloatInput, IntInput, SecretStrInput, SliderInput\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.schema import dotdict\n\n\nclass GoogleGenerativeAIComponent(LCModelComponent):\n    display_name = \"Google Generative AI\"\n    description = \"Generate text using Google Generative AI.\"\n    icon = \"GoogleGenerativeAI\"\n    name = \"GoogleGenerativeAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_output_tokens\", display_name=\"Max Output Tokens\", info=\"The maximum number of tokens to generate.\"\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model\",\n            info=\"The name of the model to use.\",\n            options=GOOGLE_GENERATIVE_AI_MODELS,\n            value=\"gemini-1.5-pro\",\n            refresh_button=True,\n            combobox=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Google API Key\",\n            info=\"The Google API Key to use for the Google Generative AI.\",\n            required=True,\n            real_time_refresh=True,\n        ),\n        FloatInput(\n            name=\"top_p\",\n            display_name=\"Top P\",\n            info=\"The maximum cumulative probability of tokens to consider when sampling.\",\n            advanced=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            range_spec=RangeSpec(min=0, max=2, step=0.01),\n            info=\"Controls randomness. Lower values are more deterministic, higher values are more creative.\",\n        ),\n        IntInput(\n            name=\"n\",\n            display_name=\"N\",\n            info=\"Number of chat completions to generate for each prompt. \"\n            \"Note that the API may not return the full n completions if duplicates are generated.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"top_k\",\n            display_name=\"Top K\",\n            info=\"Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"tool_model_enabled\",\n            display_name=\"Tool Model Enabled\",\n            info=\"Whether to use the tool model.\",\n            value=False,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        try:\n            from langchain_google_genai import ChatGoogleGenerativeAI\n        except ImportError as e:\n            msg = \"The 'langchain_google_genai' package is required to use the Google Generative AI model.\"\n            raise ImportError(msg) from e\n\n        google_api_key = self.api_key\n        model = self.model_name\n        max_output_tokens = self.max_output_tokens\n        temperature = self.temperature\n        top_k = self.top_k\n        top_p = self.top_p\n        n = self.n\n\n        return ChatGoogleGenerativeAI(\n            model=model,\n            max_output_tokens=max_output_tokens or None,\n            temperature=temperature,\n            top_k=top_k or None,\n            top_p=top_p or None,\n            n=n or 1,\n            google_api_key=SecretStr(google_api_key).get_secret_value(),\n        )\n\n    def get_models(self, tool_model_enabled: bool | None = None) -> list[str]:\n        try:\n            import google.generativeai as genai\n\n            genai.configure(api_key=self.api_key)\n            model_ids = [\n                model.name.replace(\"models/\", \"\")\n                for model in genai.list_models()\n                if \"generateContent\" in model.supported_generation_methods\n            ]\n            model_ids.sort(reverse=True)\n        except (ImportError, ValueError) as e:\n            logger.exception(f\"Error getting model names: {e}\")\n            model_ids = GOOGLE_GENERATIVE_AI_MODELS\n        if tool_model_enabled:\n            try:\n                from langchain_google_genai.chat_models import ChatGoogleGenerativeAI\n            except ImportError as e:\n                msg = \"langchain_google_genai is not installed.\"\n                raise ImportError(msg) from e\n            for model in model_ids:\n                model_with_tool = ChatGoogleGenerativeAI(\n                    model=self.model_name,\n                    google_api_key=self.api_key,\n                )\n                if not self.supports_tool_calling(model_with_tool):\n                    model_ids.remove(model)\n        return model_ids\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name in {\"base_url\", \"model_name\", \"tool_model_enabled\", \"api_key\"} and field_value:\n            try:\n                if len(self.api_key) == 0:\n                    ids = GOOGLE_GENERATIVE_AI_MODELS\n                else:\n                    try:\n                        ids = self.get_models(tool_model_enabled=self.tool_model_enabled)\n                    except (ImportError, ValueError, requests.exceptions.RequestException) as e:\n                        logger.exception(f\"Error getting model names: {e}\")\n                        ids = GOOGLE_GENERATIVE_AI_MODELS\n                build_config[\"model_name\"][\"options\"] = ids\n                build_config[\"model_name\"][\"value\"] = ids[0]\n            except Exception as e:\n                msg = f\"Error getting model names: {e}\"\n                raise ValueError(msg) from e\n        return build_config\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_output_tokens": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Max Output Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_output_tokens",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model",
                "dynamic": false,
                "info": "The name of the model to use.",
                "name": "model_name",
                "options": [
                  "learnlm-2.0-flash-experimental",
                  "learnlm-1.5-pro-experimental",
                  "gemma-3-4b-it",
                  "gemma-3-27b-it",
                  "gemma-3-1b-it",
                  "gemma-3-12b-it",
                  "gemini-pro-vision",
                  "gemini-exp-1206",
                  "gemini-2.5-pro-preview-03-25",
                  "gemini-2.5-pro-exp-03-25",
                  "gemini-2.5-flash-preview-04-17",
                  "gemini-2.0-pro-exp-02-05",
                  "gemini-2.0-pro-exp",
                  "gemini-2.0-flash-thinking-exp-1219",
                  "gemini-2.0-flash-thinking-exp-01-21",
                  "gemini-2.0-flash-thinking-exp",
                  "gemini-2.0-flash-lite-preview-02-05",
                  "gemini-2.0-flash-lite-preview",
                  "gemini-2.0-flash-lite-001",
                  "gemini-2.0-flash-lite",
                  "gemini-2.0-flash-exp-image-generation",
                  "gemini-2.0-flash-exp",
                  "gemini-2.0-flash-001",
                  "gemini-2.0-flash",
                  "gemini-1.5-pro-latest",
                  "gemini-1.5-pro-002",
                  "gemini-1.5-pro-001",
                  "gemini-1.5-pro",
                  "gemini-1.5-flash-latest",
                  "gemini-1.5-flash-8b-latest",
                  "gemini-1.5-flash-8b-exp-0924",
                  "gemini-1.5-flash-8b-exp-0827",
                  "gemini-1.5-flash-8b-001",
                  "gemini-1.5-flash-8b",
                  "gemini-1.5-flash-002",
                  "gemini-1.5-flash-001-tuning",
                  "gemini-1.5-flash-001",
                  "gemini-1.5-flash",
                  "gemini-1.0-pro-vision-latest"
                ],
                "options_metadata": [],
                "placeholder": "",
                "refresh_button": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "gemini-1.5-flash"
              },
              "n": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "N",
                "dynamic": false,
                "info": "Number of chat completions to generate for each prompt. Note that the API may not return the full n completions if duplicates are generated.",
                "list": false,
                "list_add_label": "Add More",
                "name": "n",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "System message to pass to the model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are a Retrieval-Augmented Generation (RAG) answer generation agent for a multi-agent educational chatbot designed to assist students with Grade 11 History.\n\nYou will receive two inputs:\n- A contextual passage retrieved from a textbook.\n- A student’s question related to that context.\n\nYour role is to generate a clear, factual, and concise answer using only the information found within the provided context. Do not use any outside knowledge, and do not attempt to fabricate or guess answers. If the context does not contain enough information to answer the question accurately, respond with:\n\n\"The provided context does not contain enough information to answer this question.\"\n\nIn addition to the answer, you must include the corresponding section title and page number as provided by the system.\n\n*Guidelines*:\n- Base the answer strictly on the context provided.\n- If relevant information is not present in the context, explicitly say so.\n- Never invent facts or speculate.\n- Keep language clear, educational, easy to understand and suitable for a Grade 11 student.\n- After the answer, clearly list the section and page number like this:  \nSection : (section goes here)\nPage No : (page number goes here)\n\nYour goal is to simulate a knowledgeable, trustworthy assistant that helps students understand history based solely on textbook content."
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Controls randomness. Lower values are more deterministic, higher values are more creative.",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 2,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              },
              "tool_model_enabled": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Tool Model Enabled",
                "dynamic": false,
                "info": "Whether to use the tool model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "tool_model_enabled",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "top_k": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Top K",
                "dynamic": false,
                "info": "Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_k",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "top_p": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Top P",
                "dynamic": false,
                "info": "The maximum cumulative probability of tokens to consider when sampling.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_p",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "GoogleGenerativeAIModel"
        },
        "id": "GoogleGenerativeAIModel-C84qd",
        "measured": {
          "height": 734,
          "width": 320
        },
        "position": {
          "x": 7330.005570044397,
          "y": 811.9523815273906
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt-bcOy9",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "question",
                "answerfromrag",
                "websearchresultsfromgivenwebsites"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt",
            "documentation": "",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "prompts",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt Message",
                "hidden": false,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": null,
            "template": {
              "_type": "Component",
              "answerfromrag": {
                "advanced": false,
                "display_name": "answerfromrag",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "answerfromrag",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "question": {
                "advanced": false,
                "display_name": "question",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "question",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "You are an intelligent answering agent in a multi-agent system. You are provided with the following inputs:\n\n- **{question}**: The user’s question.  \n- **{answerfromrag}**: A response generated by a Retrieval-Augmented Generation (RAG) agent using textbook or internal sources.  \n- **{websearchresultsfromgivenwebsites}**: Additional information retrieved from trusted web sources.\n\nYour task is to synthesize all the provided content and generate the best possible answer to the question. Use the answer from the RAG agent as your base, and verify, supplement, or correct it using the web search results. Your response must be grounded in the evidence provided. Since this is for a Grade 11 student, please make sure the answers are easy to understand.\n\nPresent the final output in the following format:\n\nFinal Answer\n\nSection: (If available from RAG or search result, specify e.g., \"Chapter 3 - Ancient Civilizations\". Otherwise, leave blank.)\nPage: (If page number is available from the RAG or source, include it. Otherwise, leave blank.)\nSources: (List the URLs of the websites used in the answer.)\n\n\nOnly use content from the RAG answer or the web search results. Do not make up facts. Be clear, concise, and focused on answering the question accurately."
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "websearchresultsfromgivenwebsites": {
                "advanced": false,
                "display_name": "websearchresultsfromgivenwebsites",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "websearchresultsfromgivenwebsites",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt"
        },
        "id": "Prompt-bcOy9",
        "measured": {
          "height": 574,
          "width": 320
        },
        "position": {
          "x": 7381.514748680469,
          "y": 1709.1949296021023
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GoogleGenerativeAIModel-oXoJ7",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generate text using Google Generative AI.",
            "display_name": "Google Generative AI",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_output_tokens",
              "model_name",
              "api_key",
              "top_p",
              "temperature",
              "n",
              "top_k",
              "tool_model_enabled"
            ],
            "frozen": false,
            "icon": "GoogleGenerativeAI",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": false,
                "method": "text_response",
                "name": "text_output",
                "options": null,
                "required_inputs": [],
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "hidden": null,
                "method": "build_model",
                "name": "model_output",
                "options": null,
                "required_inputs": [
                  "api_key"
                ],
                "selected": "LanguageModel",
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Google API Key",
                "dynamic": false,
                "info": "The Google API Key to use for the Google Generative AI.",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nimport requests\nfrom loguru import logger\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.google_generative_ai_constants import GOOGLE_GENERATIVE_AI_MODELS\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import DropdownInput, FloatInput, IntInput, SecretStrInput, SliderInput\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.schema import dotdict\n\n\nclass GoogleGenerativeAIComponent(LCModelComponent):\n    display_name = \"Google Generative AI\"\n    description = \"Generate text using Google Generative AI.\"\n    icon = \"GoogleGenerativeAI\"\n    name = \"GoogleGenerativeAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_output_tokens\", display_name=\"Max Output Tokens\", info=\"The maximum number of tokens to generate.\"\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model\",\n            info=\"The name of the model to use.\",\n            options=GOOGLE_GENERATIVE_AI_MODELS,\n            value=\"gemini-1.5-pro\",\n            refresh_button=True,\n            combobox=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Google API Key\",\n            info=\"The Google API Key to use for the Google Generative AI.\",\n            required=True,\n            real_time_refresh=True,\n        ),\n        FloatInput(\n            name=\"top_p\",\n            display_name=\"Top P\",\n            info=\"The maximum cumulative probability of tokens to consider when sampling.\",\n            advanced=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            range_spec=RangeSpec(min=0, max=2, step=0.01),\n            info=\"Controls randomness. Lower values are more deterministic, higher values are more creative.\",\n        ),\n        IntInput(\n            name=\"n\",\n            display_name=\"N\",\n            info=\"Number of chat completions to generate for each prompt. \"\n            \"Note that the API may not return the full n completions if duplicates are generated.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"top_k\",\n            display_name=\"Top K\",\n            info=\"Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"tool_model_enabled\",\n            display_name=\"Tool Model Enabled\",\n            info=\"Whether to use the tool model.\",\n            value=False,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        try:\n            from langchain_google_genai import ChatGoogleGenerativeAI\n        except ImportError as e:\n            msg = \"The 'langchain_google_genai' package is required to use the Google Generative AI model.\"\n            raise ImportError(msg) from e\n\n        google_api_key = self.api_key\n        model = self.model_name\n        max_output_tokens = self.max_output_tokens\n        temperature = self.temperature\n        top_k = self.top_k\n        top_p = self.top_p\n        n = self.n\n\n        return ChatGoogleGenerativeAI(\n            model=model,\n            max_output_tokens=max_output_tokens or None,\n            temperature=temperature,\n            top_k=top_k or None,\n            top_p=top_p or None,\n            n=n or 1,\n            google_api_key=SecretStr(google_api_key).get_secret_value(),\n        )\n\n    def get_models(self, tool_model_enabled: bool | None = None) -> list[str]:\n        try:\n            import google.generativeai as genai\n\n            genai.configure(api_key=self.api_key)\n            model_ids = [\n                model.name.replace(\"models/\", \"\")\n                for model in genai.list_models()\n                if \"generateContent\" in model.supported_generation_methods\n            ]\n            model_ids.sort(reverse=True)\n        except (ImportError, ValueError) as e:\n            logger.exception(f\"Error getting model names: {e}\")\n            model_ids = GOOGLE_GENERATIVE_AI_MODELS\n        if tool_model_enabled:\n            try:\n                from langchain_google_genai.chat_models import ChatGoogleGenerativeAI\n            except ImportError as e:\n                msg = \"langchain_google_genai is not installed.\"\n                raise ImportError(msg) from e\n            for model in model_ids:\n                model_with_tool = ChatGoogleGenerativeAI(\n                    model=self.model_name,\n                    google_api_key=self.api_key,\n                )\n                if not self.supports_tool_calling(model_with_tool):\n                    model_ids.remove(model)\n        return model_ids\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name in {\"base_url\", \"model_name\", \"tool_model_enabled\", \"api_key\"} and field_value:\n            try:\n                if len(self.api_key) == 0:\n                    ids = GOOGLE_GENERATIVE_AI_MODELS\n                else:\n                    try:\n                        ids = self.get_models(tool_model_enabled=self.tool_model_enabled)\n                    except (ImportError, ValueError, requests.exceptions.RequestException) as e:\n                        logger.exception(f\"Error getting model names: {e}\")\n                        ids = GOOGLE_GENERATIVE_AI_MODELS\n                build_config[\"model_name\"][\"options\"] = ids\n                build_config[\"model_name\"][\"value\"] = ids[0]\n            except Exception as e:\n                msg = f\"Error getting model names: {e}\"\n                raise ValueError(msg) from e\n        return build_config\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_output_tokens": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Max Output Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_output_tokens",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model",
                "dynamic": false,
                "info": "The name of the model to use.",
                "name": "model_name",
                "options": [
                  "learnlm-2.0-flash-experimental",
                  "learnlm-1.5-pro-experimental",
                  "gemma-3-4b-it",
                  "gemma-3-27b-it",
                  "gemma-3-1b-it",
                  "gemma-3-12b-it",
                  "gemini-pro-vision",
                  "gemini-exp-1206",
                  "gemini-2.5-pro-preview-03-25",
                  "gemini-2.5-pro-exp-03-25",
                  "gemini-2.5-flash-preview-04-17",
                  "gemini-2.0-pro-exp-02-05",
                  "gemini-2.0-pro-exp",
                  "gemini-2.0-flash-thinking-exp-1219",
                  "gemini-2.0-flash-thinking-exp-01-21",
                  "gemini-2.0-flash-thinking-exp",
                  "gemini-2.0-flash-lite-preview-02-05",
                  "gemini-2.0-flash-lite-preview",
                  "gemini-2.0-flash-lite-001",
                  "gemini-2.0-flash-lite",
                  "gemini-2.0-flash-exp-image-generation",
                  "gemini-2.0-flash-exp",
                  "gemini-2.0-flash-001",
                  "gemini-2.0-flash",
                  "gemini-1.5-pro-latest",
                  "gemini-1.5-pro-002",
                  "gemini-1.5-pro-001",
                  "gemini-1.5-pro",
                  "gemini-1.5-flash-latest",
                  "gemini-1.5-flash-8b-latest",
                  "gemini-1.5-flash-8b-exp-0924",
                  "gemini-1.5-flash-8b-exp-0827",
                  "gemini-1.5-flash-8b-001",
                  "gemini-1.5-flash-8b",
                  "gemini-1.5-flash-002",
                  "gemini-1.5-flash-001-tuning",
                  "gemini-1.5-flash-001",
                  "gemini-1.5-flash",
                  "gemini-1.0-pro-vision-latest"
                ],
                "options_metadata": [],
                "placeholder": "",
                "refresh_button": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "gemini-1.5-flash"
              },
              "n": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "N",
                "dynamic": false,
                "info": "Number of chat completions to generate for each prompt. Note that the API may not return the full n completions if duplicates are generated.",
                "list": false,
                "list_add_label": "Add More",
                "name": "n",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "System message to pass to the model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are a synthesis agent in a multi-agent AI system designed to provide accurate and concise answers to user questions using multiple sources. For every question, you are provided with:\n\n- **{question}** – the user's original query  \n- **{answerfromrag}** – an initial response generated by a Retrieval-Augmented Generation (RAG) agent using textbook or internal academic sources  \n- **{websearchresultsfromgivenwebsites}** – supplemental information retrieved from trusted web sources  \n\nYour role is to critically evaluate the RAG-generated answer and enhance it by cross-referencing it with the web search results. You must:\n\n1. Use the RAG answer as the foundation of your response.  \n2. Correct any inaccuracies using evidence from the web results.  \n3. Add relevant context or missing details using either source.  \n4. Ensure that your final answer is directly supported by at least one of the provided inputs.\n5. Since this is for a Grade 11 student, please make sure the answers are easy to understand.\n\nYour final response must follow this format:\n\n(Final Answer goes here)\n\n**Section:** (If mentioned in RAG or web sources, include the relevant section title. Otherwise, leave blank.)  \n**Page:** (If a page number is mentioned in RAG or web sources, include it. Otherwise, leave blank.)  \n**Sources:** (List only the URLs of the web sources referenced in your answer.)  \n\n\nDo **not** use information not found in the provided inputs. Do **not** assume or fabricate details. Keep your answer concise, factual, and focused on addressing the user's question."
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Controls randomness. Lower values are more deterministic, higher values are more creative.",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 2,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              },
              "tool_model_enabled": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Tool Model Enabled",
                "dynamic": false,
                "info": "Whether to use the tool model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "tool_model_enabled",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "top_k": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Top K",
                "dynamic": false,
                "info": "Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_k",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "top_p": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Top P",
                "dynamic": false,
                "info": "The maximum cumulative probability of tokens to consider when sampling.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_p",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "GoogleGenerativeAIModel"
        },
        "id": "GoogleGenerativeAIModel-oXoJ7",
        "measured": {
          "height": 734,
          "width": 320
        },
        "position": {
          "x": 7828.048315414901,
          "y": 1590.3718564270723
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GoogleGenerativeAIModel-rh6y4",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generate text using Google Generative AI.",
            "display_name": "Google Generative AI",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_output_tokens",
              "model_name",
              "api_key",
              "top_p",
              "temperature",
              "n",
              "top_k",
              "tool_model_enabled"
            ],
            "frozen": false,
            "icon": "GoogleGenerativeAI",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": false,
                "method": "text_response",
                "name": "text_output",
                "options": null,
                "required_inputs": [],
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "hidden": null,
                "method": "build_model",
                "name": "model_output",
                "options": null,
                "required_inputs": [
                  "api_key"
                ],
                "selected": "LanguageModel",
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Google API Key",
                "dynamic": false,
                "info": "The Google API Key to use for the Google Generative AI.",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nimport requests\nfrom loguru import logger\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.google_generative_ai_constants import GOOGLE_GENERATIVE_AI_MODELS\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import DropdownInput, FloatInput, IntInput, SecretStrInput, SliderInput\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.schema import dotdict\n\n\nclass GoogleGenerativeAIComponent(LCModelComponent):\n    display_name = \"Google Generative AI\"\n    description = \"Generate text using Google Generative AI.\"\n    icon = \"GoogleGenerativeAI\"\n    name = \"GoogleGenerativeAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_output_tokens\", display_name=\"Max Output Tokens\", info=\"The maximum number of tokens to generate.\"\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model\",\n            info=\"The name of the model to use.\",\n            options=GOOGLE_GENERATIVE_AI_MODELS,\n            value=\"gemini-1.5-pro\",\n            refresh_button=True,\n            combobox=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Google API Key\",\n            info=\"The Google API Key to use for the Google Generative AI.\",\n            required=True,\n            real_time_refresh=True,\n        ),\n        FloatInput(\n            name=\"top_p\",\n            display_name=\"Top P\",\n            info=\"The maximum cumulative probability of tokens to consider when sampling.\",\n            advanced=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            range_spec=RangeSpec(min=0, max=2, step=0.01),\n            info=\"Controls randomness. Lower values are more deterministic, higher values are more creative.\",\n        ),\n        IntInput(\n            name=\"n\",\n            display_name=\"N\",\n            info=\"Number of chat completions to generate for each prompt. \"\n            \"Note that the API may not return the full n completions if duplicates are generated.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"top_k\",\n            display_name=\"Top K\",\n            info=\"Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"tool_model_enabled\",\n            display_name=\"Tool Model Enabled\",\n            info=\"Whether to use the tool model.\",\n            value=False,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        try:\n            from langchain_google_genai import ChatGoogleGenerativeAI\n        except ImportError as e:\n            msg = \"The 'langchain_google_genai' package is required to use the Google Generative AI model.\"\n            raise ImportError(msg) from e\n\n        google_api_key = self.api_key\n        model = self.model_name\n        max_output_tokens = self.max_output_tokens\n        temperature = self.temperature\n        top_k = self.top_k\n        top_p = self.top_p\n        n = self.n\n\n        return ChatGoogleGenerativeAI(\n            model=model,\n            max_output_tokens=max_output_tokens or None,\n            temperature=temperature,\n            top_k=top_k or None,\n            top_p=top_p or None,\n            n=n or 1,\n            google_api_key=SecretStr(google_api_key).get_secret_value(),\n        )\n\n    def get_models(self, tool_model_enabled: bool | None = None) -> list[str]:\n        try:\n            import google.generativeai as genai\n\n            genai.configure(api_key=self.api_key)\n            model_ids = [\n                model.name.replace(\"models/\", \"\")\n                for model in genai.list_models()\n                if \"generateContent\" in model.supported_generation_methods\n            ]\n            model_ids.sort(reverse=True)\n        except (ImportError, ValueError) as e:\n            logger.exception(f\"Error getting model names: {e}\")\n            model_ids = GOOGLE_GENERATIVE_AI_MODELS\n        if tool_model_enabled:\n            try:\n                from langchain_google_genai.chat_models import ChatGoogleGenerativeAI\n            except ImportError as e:\n                msg = \"langchain_google_genai is not installed.\"\n                raise ImportError(msg) from e\n            for model in model_ids:\n                model_with_tool = ChatGoogleGenerativeAI(\n                    model=self.model_name,\n                    google_api_key=self.api_key,\n                )\n                if not self.supports_tool_calling(model_with_tool):\n                    model_ids.remove(model)\n        return model_ids\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name in {\"base_url\", \"model_name\", \"tool_model_enabled\", \"api_key\"} and field_value:\n            try:\n                if len(self.api_key) == 0:\n                    ids = GOOGLE_GENERATIVE_AI_MODELS\n                else:\n                    try:\n                        ids = self.get_models(tool_model_enabled=self.tool_model_enabled)\n                    except (ImportError, ValueError, requests.exceptions.RequestException) as e:\n                        logger.exception(f\"Error getting model names: {e}\")\n                        ids = GOOGLE_GENERATIVE_AI_MODELS\n                build_config[\"model_name\"][\"options\"] = ids\n                build_config[\"model_name\"][\"value\"] = ids[0]\n            except Exception as e:\n                msg = f\"Error getting model names: {e}\"\n                raise ValueError(msg) from e\n        return build_config\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_output_tokens": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Max Output Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_output_tokens",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model",
                "dynamic": false,
                "info": "The name of the model to use.",
                "name": "model_name",
                "options": [
                  "learnlm-2.0-flash-experimental",
                  "learnlm-1.5-pro-experimental",
                  "gemma-3-4b-it",
                  "gemma-3-27b-it",
                  "gemma-3-1b-it",
                  "gemma-3-12b-it",
                  "gemini-pro-vision",
                  "gemini-exp-1206",
                  "gemini-2.5-pro-preview-03-25",
                  "gemini-2.5-pro-exp-03-25",
                  "gemini-2.5-flash-preview-04-17",
                  "gemini-2.0-pro-exp-02-05",
                  "gemini-2.0-pro-exp",
                  "gemini-2.0-flash-thinking-exp-1219",
                  "gemini-2.0-flash-thinking-exp-01-21",
                  "gemini-2.0-flash-thinking-exp",
                  "gemini-2.0-flash-lite-preview-02-05",
                  "gemini-2.0-flash-lite-preview",
                  "gemini-2.0-flash-lite-001",
                  "gemini-2.0-flash-lite",
                  "gemini-2.0-flash-exp-image-generation",
                  "gemini-2.0-flash-exp",
                  "gemini-2.0-flash-001",
                  "gemini-2.0-flash",
                  "gemini-1.5-pro-latest",
                  "gemini-1.5-pro-002",
                  "gemini-1.5-pro-001",
                  "gemini-1.5-pro",
                  "gemini-1.5-flash-latest",
                  "gemini-1.5-flash-8b-latest",
                  "gemini-1.5-flash-8b-exp-0924",
                  "gemini-1.5-flash-8b-exp-0827",
                  "gemini-1.5-flash-8b-001",
                  "gemini-1.5-flash-8b",
                  "gemini-1.5-flash-002",
                  "gemini-1.5-flash-001-tuning",
                  "gemini-1.5-flash-001",
                  "gemini-1.5-flash",
                  "gemini-1.0-pro-vision-latest"
                ],
                "options_metadata": [],
                "placeholder": "",
                "refresh_button": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "gemini-1.5-flash"
              },
              "n": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "N",
                "dynamic": false,
                "info": "Number of chat completions to generate for each prompt. Note that the API may not return the full n completions if duplicates are generated.",
                "list": false,
                "list_add_label": "Add More",
                "name": "n",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "System message to pass to the model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are the final AI agent in a multi-agent educational chat system, helping a Grade 11 student understand academic topics. You will craft the final message in the conversation using the following inputs:\n\n•⁠ ⁠{vector}: Verified factual content retrieved via Retrieval-Augmented Generation (RAG), including section names and page numbers.\n•⁠ ⁠{web}: Reliable web search results with proper sources.\n•⁠ ⁠{question}: The original question asked by the student.\n•⁠ ⁠{answer}: The draft answer proposed by earlier agents, including any references.\n•⁠ ⁠{memory}: The last 10 exchanges between the student and AI, to help match the student's tone, style, and prior understanding.\n\nYour task is to generate a warm, clear, and accurate final response for the student, following these steps:\n\n1.⁠ ⁠Fact-check the answer using only the information from vector and web.\n\nIf any part of the answer is unclear, incorrect, or overly complex, revise it using only verified information.\n\nEnsure all claims are directly supported by the retrieved or sourced content. Do not make up or infer facts beyond what is provided.\n\n2.⁠ ⁠Simplify and personalize the explanation:\n\nAdapt the tone to match the student's style and vibe based on memory (e.g., casual, curious, confused, excited).\n\nUse simple analogies or examples if needed, but keep the language grade-appropriate.\n\nAvoid technical jargon unless it has already been introduced to the student earlier in memory.\n\n3.⁠ ⁠Handle missing or incomplete information responsibly:\n\nIf you cannot answer the question fully based on the available vector and web, explain what is known and politely acknowledge the limitation. Never guess or invent content.\n\n4.⁠ ⁠Include references:\n\nClearly mention the sources, such as book section/page numbers (from vector) or URLs/domains (from web), so the student can explore further if curious.\n\nNow, generate the final response for the student based on all inputs. Be encouraging, accurate, and thoughtful — like a trusted study buddy who really knows their stuff.\n\nImportant\nDon't greet after every single message.\nClearly state all the relevant references after the message.\n\nTextbook Section:\nPages:\nSources:"
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Controls randomness. Lower values are more deterministic, higher values are more creative.",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 2,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              },
              "tool_model_enabled": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Tool Model Enabled",
                "dynamic": false,
                "info": "Whether to use the tool model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "tool_model_enabled",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "top_k": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Top K",
                "dynamic": false,
                "info": "Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_k",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "top_p": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Top P",
                "dynamic": false,
                "info": "The maximum cumulative probability of tokens to consider when sampling.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_p",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "GoogleGenerativeAIModel"
        },
        "dragging": false,
        "id": "GoogleGenerativeAIModel-rh6y4",
        "measured": {
          "height": 734,
          "width": 320
        },
        "position": {
          "x": 8975.581649377807,
          "y": 1665.8120965423677
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "BatchRunComponent-k9142",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": true,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Runs an LLM over each row of a DataFrame's column. If no column is set, the entire row is passed.",
            "display_name": "Batch Run",
            "documentation": "",
            "edited": false,
            "field_order": [
              "model",
              "system_message",
              "df",
              "column_name",
              "output_column_name",
              "enable_metadata"
            ],
            "frozen": false,
            "icon": "List",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": false,
                "method": "run_batch",
                "name": "batch_results",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, cast\n\nimport toml  # type: ignore[import-untyped]\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, HandleInput, MessageTextInput, MultilineInput, Output\nfrom langflow.schema import DataFrame\n\nif TYPE_CHECKING:\n    from langchain_core.runnables import Runnable\n\n\nclass BatchRunComponent(Component):\n    display_name = \"Batch Run\"\n    description = \"Runs an LLM over each row of a DataFrame's column. If no column is set, the entire row is passed.\"\n    icon = \"List\"\n    beta = True\n\n    inputs = [\n        HandleInput(\n            name=\"model\",\n            display_name=\"Language Model\",\n            info=\"Connect the 'Language Model' output from your LLM component here.\",\n            input_types=[\"LanguageModel\"],\n            required=True,\n        ),\n        MultilineInput(\n            name=\"system_message\",\n            display_name=\"Instructions\",\n            info=\"Multi-line system instruction for all rows in the DataFrame.\",\n            required=False,\n        ),\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The DataFrame whose column (specified by 'column_name') we'll treat as text messages.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=(\n                \"The name of the DataFrame column to treat as text messages. \"\n                \"If empty, all columns will be formatted in TOML.\"\n            ),\n            required=False,\n            advanced=False,\n        ),\n        MessageTextInput(\n            name=\"output_column_name\",\n            display_name=\"Output Column Name\",\n            info=\"Name of the column where the model's response will be stored.\",\n            value=\"model_response\",\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"enable_metadata\",\n            display_name=\"Enable Metadata\",\n            info=\"If True, add metadata to the output DataFrame.\",\n            value=False,\n            required=False,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"batch_results\",\n            method=\"run_batch\",\n            info=\"A DataFrame with all original columns plus the model's response column.\",\n        ),\n    ]\n\n    def _format_row_as_toml(self, row: dict[str, Any]) -> str:\n        \"\"\"Convert a dictionary (row) into a TOML-formatted string.\"\"\"\n        formatted_dict = {str(col): {\"value\": str(val)} for col, val in row.items()}\n        return toml.dumps(formatted_dict)\n\n    def _create_base_row(\n        self, original_row: dict[str, Any], model_response: str = \"\", batch_index: int = -1\n    ) -> dict[str, Any]:\n        \"\"\"Create a base row with original columns and additional metadata.\"\"\"\n        row = original_row.copy()\n        row[self.output_column_name] = model_response\n        row[\"batch_index\"] = batch_index\n        return row\n\n    def _add_metadata(\n        self, row: dict[str, Any], *, success: bool = True, system_msg: str = \"\", error: str | None = None\n    ) -> None:\n        \"\"\"Add metadata to a row if enabled.\"\"\"\n        if not self.enable_metadata:\n            return\n\n        if success:\n            row[\"metadata\"] = {\n                \"has_system_message\": bool(system_msg),\n                \"input_length\": len(row.get(\"text_input\", \"\")),\n                \"response_length\": len(row[self.output_column_name]),\n                \"processing_status\": \"success\",\n            }\n        else:\n            row[\"metadata\"] = {\n                \"error\": error,\n                \"processing_status\": \"failed\",\n            }\n\n    async def run_batch(self) -> DataFrame:\n        \"\"\"Process each row in df[column_name] with the language model asynchronously.\n\n        Returns:\n            DataFrame: A new DataFrame containing:\n                - All original columns\n                - The model's response column (customizable name)\n                - 'batch_index' column for processing order\n                - 'metadata' (optional)\n\n        Raises:\n            ValueError: If the specified column is not found in the DataFrame\n            TypeError: If the model is not compatible or input types are wrong\n        \"\"\"\n        model: Runnable = self.model\n        system_msg = self.system_message or \"\"\n        df: DataFrame = self.df\n        col_name = self.column_name or \"\"\n\n        # Validate inputs first\n        if not isinstance(df, DataFrame):\n            msg = f\"Expected DataFrame input, got {type(df)}\"\n            raise TypeError(msg)\n\n        if col_name and col_name not in df.columns:\n            msg = f\"Column '{col_name}' not found in the DataFrame. Available columns: {', '.join(df.columns)}\"\n            raise ValueError(msg)\n\n        try:\n            # Determine text input for each row\n            if col_name:\n                user_texts = df[col_name].astype(str).tolist()\n            else:\n                user_texts = [\n                    self._format_row_as_toml(cast(dict[str, Any], row)) for row in df.to_dict(orient=\"records\")\n                ]\n\n            total_rows = len(user_texts)\n            logger.info(f\"Processing {total_rows} rows with batch run\")\n\n            # Prepare the batch of conversations\n            conversations = [\n                [{\"role\": \"system\", \"content\": system_msg}, {\"role\": \"user\", \"content\": text}]\n                if system_msg\n                else [{\"role\": \"user\", \"content\": text}]\n                for text in user_texts\n            ]\n\n            # Configure the model with project info and callbacks\n            model = model.with_config(\n                {\n                    \"run_name\": self.display_name,\n                    \"project_name\": self.get_project_name(),\n                    \"callbacks\": self.get_langchain_callbacks(),\n                }\n            )\n            # Process batches and track progress\n            responses_with_idx = list(\n                zip(\n                    range(len(conversations)),\n                    await model.abatch(list(conversations)),\n                    strict=True,\n                )\n            )\n\n            # Sort by index to maintain order\n            responses_with_idx.sort(key=lambda x: x[0])\n\n            # Build the final data with enhanced metadata\n            rows: list[dict[str, Any]] = []\n            for idx, (original_row, response) in enumerate(\n                zip(df.to_dict(orient=\"records\"), responses_with_idx, strict=False)\n            ):\n                response_text = response[1].content if hasattr(response[1], \"content\") else str(response[1])\n                row = self._create_base_row(\n                    cast(dict[str, Any], original_row), model_response=response_text, batch_index=idx\n                )\n                self._add_metadata(row, success=True, system_msg=system_msg)\n                rows.append(row)\n\n                # Log progress\n                if (idx + 1) % max(1, total_rows // 10) == 0:\n                    logger.info(f\"Processed {idx + 1}/{total_rows} rows\")\n\n            logger.info(\"Batch processing completed successfully\")\n            return DataFrame(rows)\n\n        except (KeyError, AttributeError) as e:\n            # Handle data structure and attribute access errors\n            logger.error(f\"Data processing error: {e!s}\")\n            error_row = self._create_base_row({col: \"\" for col in df.columns}, model_response=\"\", batch_index=-1)\n            self._add_metadata(error_row, success=False, error=str(e))\n            return DataFrame([error_row])\n"
              },
              "column_name": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Column Name",
                "dynamic": false,
                "info": "The name of the DataFrame column to treat as text messages. If empty, all columns will be formatted in TOML.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The DataFrame whose column (specified by 'column_name') we'll treat as text messages.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "enable_metadata": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Enable Metadata",
                "dynamic": false,
                "info": "If True, add metadata to the output DataFrame.",
                "list": false,
                "list_add_label": "Add More",
                "name": "enable_metadata",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "model": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Language Model",
                "dynamic": false,
                "info": "Connect the 'Language Model' output from your LLM component here.",
                "input_types": [
                  "LanguageModel"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "model",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "output_column_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Output Column Name",
                "dynamic": false,
                "info": "Name of the column where the model's response will be stored.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "output_column_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "model_response"
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Instructions",
                "dynamic": false,
                "info": "Multi-line system instruction for all rows in the DataFrame.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are a research assistant designed to extract relevant information from search results.\n\nFor each input, you will receive a user question along with metadata and content such as title, description, source, and full text. Your job is to identify and return only the most important and relevant parts that directly answer or relate to the question.\n\nBe concise, objective, and ignore irrelevant or promotional content. Focus on facts, claims, data, or insights that help address the question.\n\n• Present the relevant information in a clear format.\n• Include the title and source to give context.\n• If no useful information is found, respond with: \"No relevant information found."
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "BatchRunComponent"
        },
        "dragging": false,
        "id": "BatchRunComponent-k9142",
        "measured": {
          "height": 438,
          "width": 320
        },
        "position": {
          "x": 1999.9146852701842,
          "y": 1965.4740598061703
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GoogleGenerativeAIModel-QPEqu",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generate text using Google Generative AI.",
            "display_name": "Google Generative AI",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_output_tokens",
              "model_name",
              "api_key",
              "top_p",
              "temperature",
              "n",
              "top_k",
              "tool_model_enabled"
            ],
            "frozen": false,
            "icon": "GoogleGenerativeAI",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": null,
                "method": "text_response",
                "name": "text_output",
                "options": null,
                "required_inputs": [],
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "hidden": false,
                "method": "build_model",
                "name": "model_output",
                "options": null,
                "required_inputs": [
                  "api_key"
                ],
                "selected": "LanguageModel",
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Google API Key",
                "dynamic": false,
                "info": "The Google API Key to use for the Google Generative AI.",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nimport requests\nfrom loguru import logger\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.google_generative_ai_constants import GOOGLE_GENERATIVE_AI_MODELS\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import DropdownInput, FloatInput, IntInput, SecretStrInput, SliderInput\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.schema import dotdict\n\n\nclass GoogleGenerativeAIComponent(LCModelComponent):\n    display_name = \"Google Generative AI\"\n    description = \"Generate text using Google Generative AI.\"\n    icon = \"GoogleGenerativeAI\"\n    name = \"GoogleGenerativeAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_output_tokens\", display_name=\"Max Output Tokens\", info=\"The maximum number of tokens to generate.\"\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model\",\n            info=\"The name of the model to use.\",\n            options=GOOGLE_GENERATIVE_AI_MODELS,\n            value=\"gemini-1.5-pro\",\n            refresh_button=True,\n            combobox=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Google API Key\",\n            info=\"The Google API Key to use for the Google Generative AI.\",\n            required=True,\n            real_time_refresh=True,\n        ),\n        FloatInput(\n            name=\"top_p\",\n            display_name=\"Top P\",\n            info=\"The maximum cumulative probability of tokens to consider when sampling.\",\n            advanced=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            range_spec=RangeSpec(min=0, max=2, step=0.01),\n            info=\"Controls randomness. Lower values are more deterministic, higher values are more creative.\",\n        ),\n        IntInput(\n            name=\"n\",\n            display_name=\"N\",\n            info=\"Number of chat completions to generate for each prompt. \"\n            \"Note that the API may not return the full n completions if duplicates are generated.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"top_k\",\n            display_name=\"Top K\",\n            info=\"Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"tool_model_enabled\",\n            display_name=\"Tool Model Enabled\",\n            info=\"Whether to use the tool model.\",\n            value=False,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        try:\n            from langchain_google_genai import ChatGoogleGenerativeAI\n        except ImportError as e:\n            msg = \"The 'langchain_google_genai' package is required to use the Google Generative AI model.\"\n            raise ImportError(msg) from e\n\n        google_api_key = self.api_key\n        model = self.model_name\n        max_output_tokens = self.max_output_tokens\n        temperature = self.temperature\n        top_k = self.top_k\n        top_p = self.top_p\n        n = self.n\n\n        return ChatGoogleGenerativeAI(\n            model=model,\n            max_output_tokens=max_output_tokens or None,\n            temperature=temperature,\n            top_k=top_k or None,\n            top_p=top_p or None,\n            n=n or 1,\n            google_api_key=SecretStr(google_api_key).get_secret_value(),\n        )\n\n    def get_models(self, tool_model_enabled: bool | None = None) -> list[str]:\n        try:\n            import google.generativeai as genai\n\n            genai.configure(api_key=self.api_key)\n            model_ids = [\n                model.name.replace(\"models/\", \"\")\n                for model in genai.list_models()\n                if \"generateContent\" in model.supported_generation_methods\n            ]\n            model_ids.sort(reverse=True)\n        except (ImportError, ValueError) as e:\n            logger.exception(f\"Error getting model names: {e}\")\n            model_ids = GOOGLE_GENERATIVE_AI_MODELS\n        if tool_model_enabled:\n            try:\n                from langchain_google_genai.chat_models import ChatGoogleGenerativeAI\n            except ImportError as e:\n                msg = \"langchain_google_genai is not installed.\"\n                raise ImportError(msg) from e\n            for model in model_ids:\n                model_with_tool = ChatGoogleGenerativeAI(\n                    model=self.model_name,\n                    google_api_key=self.api_key,\n                )\n                if not self.supports_tool_calling(model_with_tool):\n                    model_ids.remove(model)\n        return model_ids\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name in {\"base_url\", \"model_name\", \"tool_model_enabled\", \"api_key\"} and field_value:\n            try:\n                if len(self.api_key) == 0:\n                    ids = GOOGLE_GENERATIVE_AI_MODELS\n                else:\n                    try:\n                        ids = self.get_models(tool_model_enabled=self.tool_model_enabled)\n                    except (ImportError, ValueError, requests.exceptions.RequestException) as e:\n                        logger.exception(f\"Error getting model names: {e}\")\n                        ids = GOOGLE_GENERATIVE_AI_MODELS\n                build_config[\"model_name\"][\"options\"] = ids\n                build_config[\"model_name\"][\"value\"] = ids[0]\n            except Exception as e:\n                msg = f\"Error getting model names: {e}\"\n                raise ValueError(msg) from e\n        return build_config\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_output_tokens": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Max Output Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_output_tokens",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model",
                "dynamic": false,
                "info": "The name of the model to use.",
                "name": "model_name",
                "options": [
                  "learnlm-2.0-flash-experimental",
                  "learnlm-1.5-pro-experimental",
                  "gemma-3-4b-it",
                  "gemma-3-27b-it",
                  "gemma-3-1b-it",
                  "gemma-3-12b-it",
                  "gemini-pro-vision",
                  "gemini-exp-1206",
                  "gemini-2.5-pro-preview-03-25",
                  "gemini-2.5-pro-exp-03-25",
                  "gemini-2.5-flash-preview-04-17",
                  "gemini-2.0-pro-exp-02-05",
                  "gemini-2.0-pro-exp",
                  "gemini-2.0-flash-thinking-exp-1219",
                  "gemini-2.0-flash-thinking-exp-01-21",
                  "gemini-2.0-flash-thinking-exp",
                  "gemini-2.0-flash-lite-preview-02-05",
                  "gemini-2.0-flash-lite-preview",
                  "gemini-2.0-flash-lite-001",
                  "gemini-2.0-flash-lite",
                  "gemini-2.0-flash-exp-image-generation",
                  "gemini-2.0-flash-exp",
                  "gemini-2.0-flash-001",
                  "gemini-2.0-flash",
                  "gemini-1.5-pro-latest",
                  "gemini-1.5-pro-002",
                  "gemini-1.5-pro-001",
                  "gemini-1.5-pro",
                  "gemini-1.5-flash-latest",
                  "gemini-1.5-flash-8b-latest",
                  "gemini-1.5-flash-8b-exp-0924",
                  "gemini-1.5-flash-8b-exp-0827",
                  "gemini-1.5-flash-8b-001",
                  "gemini-1.5-flash-8b",
                  "gemini-1.5-flash-002",
                  "gemini-1.5-flash-001-tuning",
                  "gemini-1.5-flash-001",
                  "gemini-1.5-flash",
                  "gemini-1.0-pro-vision-latest"
                ],
                "options_metadata": [],
                "placeholder": "",
                "refresh_button": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "learnlm-2.0-flash-experimental"
              },
              "n": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "N",
                "dynamic": false,
                "info": "Number of chat completions to generate for each prompt. Note that the API may not return the full n completions if duplicates are generated.",
                "list": false,
                "list_add_label": "Add More",
                "name": "n",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "System message to pass to the model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are an intelligent assistant that helps extract relevant information from search results. For each input, your goal is to highlight only the parts that directly answer or relate to the original user question. Ignore irrelevant details. Be concise, factual, and clear. Provide the detailed summary and the Source.\n\n#Guidelines\n- Do not invent anything.\n- Always output the Sources (Website Link).\n- Always include the all necessary details for the question even if it means the summarization is large.\n- Output size doesnt matter as long as it includes all the relevant information regarding the question.\n- Be concise, factual and clear."
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Controls randomness. Lower values are more deterministic, higher values are more creative.",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 2,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              },
              "tool_model_enabled": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Tool Model Enabled",
                "dynamic": false,
                "info": "Whether to use the tool model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "tool_model_enabled",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "top_k": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Top K",
                "dynamic": false,
                "info": "Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_k",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "top_p": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Top P",
                "dynamic": false,
                "info": "The maximum cumulative probability of tokens to consider when sampling.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_p",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "GoogleGenerativeAIModel"
        },
        "id": "GoogleGenerativeAIModel-QPEqu",
        "measured": {
          "height": 734,
          "width": 320
        },
        "position": {
          "x": 1516.9262682972212,
          "y": 1448.1989262477077
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt-X0W24",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "question"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt",
            "documentation": "",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "prompts",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt Message",
                "hidden": false,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": null,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "question": {
                "advanced": false,
                "display_name": "question",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "question",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "You are a research assistant designed to extract relevant information from search results.\n\nFor each input, you will receive a user question along with metadata and content such as title, description, source (website URL), and full text. Your job is to identify and return only the most important and relevant parts that directly answer or relate to the question. Do not answer the question. Your job is to only provide the context that is needed for the answer.\n\nBe concise, objective, and ignore irrelevant or promotional content. Focus on facts, claims, data, or insights that help address the question.\n\n• Present the relevant information in a clear format.\n• Include the title and the source website URL to give proper context.\n• Clearly show the URL so the user knows where the information came from.\n• If no useful information is found, respond with: \"No relevant information found.\"\n\nOriginal Question:\n{question}"
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt"
        },
        "id": "Prompt-X0W24",
        "measured": {
          "height": 411,
          "width": 320
        },
        "position": {
          "x": 1116.5285773343667,
          "y": 1521.4607397190284
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt-LoGYf",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "input"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt",
            "documentation": "",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "prompts",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt Message",
                "hidden": false,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": null,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "input": {
                "advanced": false,
                "display_name": "input",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "input",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "You are a search engine optimization expert. Your task is to generate effective search queries.\n\nAnalyze the following user input and create 2 concise phrases that a person would type into Google to find relevant information. Do not make up anything; generate clear, factual, and concise answers. I need these phrases to be highly optimized search phrases.\n\nReturn your response strictly as a JSON object in the following format, and do not include any explanations, comments, or additional text:\n\n[\n    \"query1\": \"First query here.\"\n    \"query2\": \"Second query here.\"\n]\n\nOriginal Question: {input}\n\nOnly return the JSON response."
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt"
        },
        "id": "Prompt-LoGYf",
        "measured": {
          "height": 411,
          "width": 320
        },
        "position": {
          "x": -974.7239413991338,
          "y": 1863.2833311044762
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GoogleGenerativeAIModel-6HIUq",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generate text using Google Generative AI.",
            "display_name": "Google Generative AI",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_output_tokens",
              "model_name",
              "api_key",
              "top_p",
              "temperature",
              "n",
              "top_k",
              "tool_model_enabled"
            ],
            "frozen": false,
            "icon": "GoogleGenerativeAI",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": false,
                "method": "text_response",
                "name": "text_output",
                "options": null,
                "required_inputs": [],
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "hidden": null,
                "method": "build_model",
                "name": "model_output",
                "options": null,
                "required_inputs": [
                  "api_key"
                ],
                "selected": "LanguageModel",
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Google API Key",
                "dynamic": false,
                "info": "The Google API Key to use for the Google Generative AI.",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nimport requests\nfrom loguru import logger\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.google_generative_ai_constants import GOOGLE_GENERATIVE_AI_MODELS\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import DropdownInput, FloatInput, IntInput, SecretStrInput, SliderInput\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.schema import dotdict\n\n\nclass GoogleGenerativeAIComponent(LCModelComponent):\n    display_name = \"Google Generative AI\"\n    description = \"Generate text using Google Generative AI.\"\n    icon = \"GoogleGenerativeAI\"\n    name = \"GoogleGenerativeAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_output_tokens\", display_name=\"Max Output Tokens\", info=\"The maximum number of tokens to generate.\"\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model\",\n            info=\"The name of the model to use.\",\n            options=GOOGLE_GENERATIVE_AI_MODELS,\n            value=\"gemini-1.5-pro\",\n            refresh_button=True,\n            combobox=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Google API Key\",\n            info=\"The Google API Key to use for the Google Generative AI.\",\n            required=True,\n            real_time_refresh=True,\n        ),\n        FloatInput(\n            name=\"top_p\",\n            display_name=\"Top P\",\n            info=\"The maximum cumulative probability of tokens to consider when sampling.\",\n            advanced=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            range_spec=RangeSpec(min=0, max=2, step=0.01),\n            info=\"Controls randomness. Lower values are more deterministic, higher values are more creative.\",\n        ),\n        IntInput(\n            name=\"n\",\n            display_name=\"N\",\n            info=\"Number of chat completions to generate for each prompt. \"\n            \"Note that the API may not return the full n completions if duplicates are generated.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"top_k\",\n            display_name=\"Top K\",\n            info=\"Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"tool_model_enabled\",\n            display_name=\"Tool Model Enabled\",\n            info=\"Whether to use the tool model.\",\n            value=False,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        try:\n            from langchain_google_genai import ChatGoogleGenerativeAI\n        except ImportError as e:\n            msg = \"The 'langchain_google_genai' package is required to use the Google Generative AI model.\"\n            raise ImportError(msg) from e\n\n        google_api_key = self.api_key\n        model = self.model_name\n        max_output_tokens = self.max_output_tokens\n        temperature = self.temperature\n        top_k = self.top_k\n        top_p = self.top_p\n        n = self.n\n\n        return ChatGoogleGenerativeAI(\n            model=model,\n            max_output_tokens=max_output_tokens or None,\n            temperature=temperature,\n            top_k=top_k or None,\n            top_p=top_p or None,\n            n=n or 1,\n            google_api_key=SecretStr(google_api_key).get_secret_value(),\n        )\n\n    def get_models(self, tool_model_enabled: bool | None = None) -> list[str]:\n        try:\n            import google.generativeai as genai\n\n            genai.configure(api_key=self.api_key)\n            model_ids = [\n                model.name.replace(\"models/\", \"\")\n                for model in genai.list_models()\n                if \"generateContent\" in model.supported_generation_methods\n            ]\n            model_ids.sort(reverse=True)\n        except (ImportError, ValueError) as e:\n            logger.exception(f\"Error getting model names: {e}\")\n            model_ids = GOOGLE_GENERATIVE_AI_MODELS\n        if tool_model_enabled:\n            try:\n                from langchain_google_genai.chat_models import ChatGoogleGenerativeAI\n            except ImportError as e:\n                msg = \"langchain_google_genai is not installed.\"\n                raise ImportError(msg) from e\n            for model in model_ids:\n                model_with_tool = ChatGoogleGenerativeAI(\n                    model=self.model_name,\n                    google_api_key=self.api_key,\n                )\n                if not self.supports_tool_calling(model_with_tool):\n                    model_ids.remove(model)\n        return model_ids\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name in {\"base_url\", \"model_name\", \"tool_model_enabled\", \"api_key\"} and field_value:\n            try:\n                if len(self.api_key) == 0:\n                    ids = GOOGLE_GENERATIVE_AI_MODELS\n                else:\n                    try:\n                        ids = self.get_models(tool_model_enabled=self.tool_model_enabled)\n                    except (ImportError, ValueError, requests.exceptions.RequestException) as e:\n                        logger.exception(f\"Error getting model names: {e}\")\n                        ids = GOOGLE_GENERATIVE_AI_MODELS\n                build_config[\"model_name\"][\"options\"] = ids\n                build_config[\"model_name\"][\"value\"] = ids[0]\n            except Exception as e:\n                msg = f\"Error getting model names: {e}\"\n                raise ValueError(msg) from e\n        return build_config\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_output_tokens": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Max Output Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_output_tokens",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model",
                "dynamic": false,
                "info": "The name of the model to use.",
                "name": "model_name",
                "options": [
                  "learnlm-2.0-flash-experimental",
                  "learnlm-1.5-pro-experimental",
                  "gemma-3-4b-it",
                  "gemma-3-27b-it",
                  "gemma-3-1b-it",
                  "gemma-3-12b-it",
                  "gemini-pro-vision",
                  "gemini-exp-1206",
                  "gemini-2.5-pro-preview-03-25",
                  "gemini-2.5-pro-exp-03-25",
                  "gemini-2.5-flash-preview-04-17",
                  "gemini-2.0-pro-exp-02-05",
                  "gemini-2.0-pro-exp",
                  "gemini-2.0-flash-thinking-exp-1219",
                  "gemini-2.0-flash-thinking-exp-01-21",
                  "gemini-2.0-flash-thinking-exp",
                  "gemini-2.0-flash-lite-preview-02-05",
                  "gemini-2.0-flash-lite-preview",
                  "gemini-2.0-flash-lite-001",
                  "gemini-2.0-flash-lite",
                  "gemini-2.0-flash-exp-image-generation",
                  "gemini-2.0-flash-exp",
                  "gemini-2.0-flash-001",
                  "gemini-2.0-flash",
                  "gemini-1.5-pro-latest",
                  "gemini-1.5-pro-002",
                  "gemini-1.5-pro-001",
                  "gemini-1.5-pro",
                  "gemini-1.5-flash-latest",
                  "gemini-1.5-flash-8b-latest",
                  "gemini-1.5-flash-8b-exp-0924",
                  "gemini-1.5-flash-8b-exp-0827",
                  "gemini-1.5-flash-8b-001",
                  "gemini-1.5-flash-8b",
                  "gemini-1.5-flash-002",
                  "gemini-1.5-flash-001-tuning",
                  "gemini-1.5-flash-001",
                  "gemini-1.5-flash",
                  "gemini-1.0-pro-vision-latest"
                ],
                "options_metadata": [],
                "placeholder": "",
                "refresh_button": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "gemini-1.5-flash"
              },
              "n": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "N",
                "dynamic": false,
                "info": "Number of chat completions to generate for each prompt. Note that the API may not return the full n completions if duplicates are generated.",
                "list": false,
                "list_add_label": "Add More",
                "name": "n",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "System message to pass to the model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are a search engine optimization expert. Your task is to generate effective search queries based on the user's input. Analyze the input carefully and produce **2 concise, fact-based, and highly optimized search phrases**. Do **not invent or assume** any missing details—only use the information provided. \n\n\nStructure your output strictly in the following JSON format:\n\n {\n    \"query1\": \"First query here.\"\n    \"query2\": \"Second query here.\"\n  }\n\nDo not include any explanation, commentary, or extraneous text—only return the JSON object."
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Controls randomness. Lower values are more deterministic, higher values are more creative.",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 2,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              },
              "tool_model_enabled": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Tool Model Enabled",
                "dynamic": false,
                "info": "Whether to use the tool model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "tool_model_enabled",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "top_k": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Top K",
                "dynamic": false,
                "info": "Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_k",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "top_p": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Top P",
                "dynamic": false,
                "info": "The maximum cumulative probability of tokens to consider when sampling.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_p",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "GoogleGenerativeAIModel"
        },
        "id": "GoogleGenerativeAIModel-6HIUq",
        "measured": {
          "height": 734,
          "width": 320
        },
        "position": {
          "x": -577.8448691295107,
          "y": 1881.142559532924
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "JSONtoData-bdh5B",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "category": "data",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Convert a JSON file, JSON from a file path, or a JSON string to a Data object or a list of Data objects",
            "display_name": "Load JSON",
            "documentation": "",
            "edited": false,
            "field_order": [
              "json_file",
              "json_path",
              "json_string"
            ],
            "frozen": false,
            "icon": "braces",
            "key": "JSONtoData",
            "legacy": true,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": false,
                "method": "convert_json_to_data",
                "name": "data",
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.07433131107431833,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom pathlib import Path\n\nfrom json_repair import repair_json\n\nfrom langflow.custom import Component\nfrom langflow.io import FileInput, MessageTextInput, MultilineInput, Output\nfrom langflow.schema import Data\n\n\nclass JSONToDataComponent(Component):\n    display_name = \"Load JSON\"\n    description = (\n        \"Convert a JSON file, JSON from a file path, or a JSON string to a Data object or a list of Data objects\"\n    )\n    icon = \"braces\"\n    name = \"JSONtoData\"\n    legacy = True\n\n    inputs = [\n        FileInput(\n            name=\"json_file\",\n            display_name=\"JSON File\",\n            file_types=[\"json\"],\n            info=\"Upload a JSON file to convert to a Data object or list of Data objects\",\n        ),\n        MessageTextInput(\n            name=\"json_path\",\n            display_name=\"JSON File Path\",\n            info=\"Provide the path to the JSON file as pure text\",\n        ),\n        MultilineInput(\n            name=\"json_string\",\n            display_name=\"JSON String\",\n            info=\"Enter a valid JSON string (object or array) to convert to a Data object or list of Data objects\",\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"data\", display_name=\"Data\", method=\"convert_json_to_data\"),\n    ]\n\n    def convert_json_to_data(self) -> Data | list[Data]:\n        if sum(bool(field) for field in [self.json_file, self.json_path, self.json_string]) != 1:\n            msg = \"Please provide exactly one of: JSON file, file path, or JSON string.\"\n            self.status = msg\n            raise ValueError(msg)\n\n        json_data = None\n\n        try:\n            if self.json_file:\n                resolved_path = self.resolve_path(self.json_file)\n                file_path = Path(resolved_path)\n                if file_path.suffix.lower() != \".json\":\n                    self.status = \"The provided file must be a JSON file.\"\n                else:\n                    json_data = file_path.read_text(encoding=\"utf-8\")\n\n            elif self.json_path:\n                file_path = Path(self.json_path)\n                if file_path.suffix.lower() != \".json\":\n                    self.status = \"The provided file must be a JSON file.\"\n                else:\n                    json_data = file_path.read_text(encoding=\"utf-8\")\n\n            else:\n                json_data = self.json_string\n\n            if json_data:\n                # Try to parse the JSON string\n                try:\n                    parsed_data = json.loads(json_data)\n                except json.JSONDecodeError:\n                    # If JSON parsing fails, try to repair the JSON string\n                    repaired_json_string = repair_json(json_data)\n                    parsed_data = json.loads(repaired_json_string)\n\n                # Check if the parsed data is a list\n                if isinstance(parsed_data, list):\n                    result = [Data(data=item) for item in parsed_data]\n                else:\n                    result = Data(data=parsed_data)\n                self.status = result\n                return result\n\n        except (json.JSONDecodeError, SyntaxError, ValueError) as e:\n            error_message = f\"Invalid JSON or Python literal: {e}\"\n            self.status = error_message\n            raise ValueError(error_message) from e\n\n        except Exception as e:\n            error_message = f\"An error occurred: {e}\"\n            self.status = error_message\n            raise ValueError(error_message) from e\n\n        # An error occurred\n        raise ValueError(self.status)\n"
              },
              "json_file": {
                "_input_type": "FileInput",
                "advanced": false,
                "display_name": "JSON File",
                "dynamic": false,
                "fileTypes": [
                  "json"
                ],
                "file_path": "",
                "info": "Upload a JSON file to convert to a Data object or list of Data objects",
                "list": false,
                "list_add_label": "Add More",
                "name": "json_file",
                "placeholder": "",
                "required": false,
                "show": true,
                "temp_file": false,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "json_path": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "JSON File Path",
                "dynamic": false,
                "info": "Provide the path to the JSON file as pure text",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "json_path",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "json_string": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "JSON String",
                "dynamic": false,
                "info": "Enter a valid JSON string (object or array) to convert to a Data object or list of Data objects",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "json_string",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "JSONtoData"
        },
        "id": "JSONtoData-bdh5B",
        "measured": {
          "height": 442,
          "width": 320
        },
        "position": {
          "x": -201.6720184552969,
          "y": 2084.686267737081
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-Jq0lR",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Format a DataFrame or Data object into text using a template. Enable 'Stringify' to convert input into a readable string instead.",
            "display_name": "Parser",
            "documentation": "",
            "edited": true,
            "field_order": [
              "mode",
              "pattern",
              "input_data",
              "sep"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Text3",
                "hidden": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Text3\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{query1}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "id": "ParserComponent-Jq0lR",
        "measured": {
          "height": 392,
          "width": 320
        },
        "position": {
          "x": 178.70484320289324,
          "y": 2032.2192127415224
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GoogleSearchAPICore-fbA6H",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Call Google Search API with two queries and return combined results as a DataFrame.",
            "display_name": "Google Search API with Dual Queries",
            "documentation": "",
            "edited": true,
            "field_order": [
              "google_api_key",
              "google_cse_id",
              "input_value_1",
              "input_value_2",
              "k_per_query"
            ],
            "frozen": false,
            "icon": "Google",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Combined Results",
                "hidden": false,
                "method": "search_google_dual",
                "name": "results",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langchain_google_community import GoogleSearchAPIWrapper\r\nfrom langflow.custom import Component\r\nfrom langflow.io import IntInput, MultilineInput, Output, SecretStrInput\r\nfrom langflow.schema import DataFrame\r\nclass GoogleSearchAPICore(Component):\r\n    display_name = \"Google Search API with Dual Queries\"\r\n    description = \"Call Google Search API with two queries and return combined results as a DataFrame.\"\r\n    icon = \"Google\"\r\n    inputs = [\r\n        SecretStrInput(\r\n            name=\"google_api_key\",\r\n            display_name=\"Google API Key\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"google_cse_id\",\r\n            display_name=\"Google CSE ID\",\r\n            required=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"input_value_1\",\r\n            display_name=\"First Search Query\",\r\n            tool_mode=True,\r\n            required=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"input_value_2\",\r\n            display_name=\"Second Search Query\",\r\n            tool_mode=True,\r\n            required=True,\r\n        ),\r\n        IntInput(\r\n            name=\"k_per_query\",\r\n            display_name=\"Number of results per query\",\r\n            value=4,\r\n            required=True,\r\n        ),\r\n    ]\r\n    outputs = [\r\n        Output(\r\n            display_name=\"Combined Results\",\r\n            name=\"results\",\r\n            type_=DataFrame,\r\n            method=\"search_google_dual\",\r\n        ),\r\n    ]\r\n    def search_google_dual(self) -> DataFrame:\r\n        \"\"\"Search Google using two provided queries and combine results.\"\"\"\r\n        if not self.google_api_key:\r\n            return DataFrame([{\"error\": \"Invalid Google API Key\"}])\r\n        if not self.google_cse_id:\r\n            return DataFrame([{\"error\": \"Invalid Google CSE ID\"}])\r\n        \r\n        try:\r\n            wrapper = GoogleSearchAPIWrapper(\r\n                google_api_key=self.google_api_key, \r\n                google_cse_id=self.google_cse_id, \r\n                k=self.k_per_query\r\n            )\r\n            \r\n            # Execute first search\r\n            results_1 = wrapper.results(query=self.input_value_1, num_results=self.k_per_query)\r\n            \r\n            # Execute second search\r\n            results_2 = wrapper.results(query=self.input_value_2, num_results=self.k_per_query)\r\n            \r\n            # Add source query information to each result\r\n            for result in results_1:\r\n                result['source_query'] = 'query_1'\r\n            \r\n            for result in results_2:\r\n                result['source_query'] = 'query_2'\r\n            \r\n            # Combine results\r\n            combined_results = results_1 + results_2\r\n            \r\n            return DataFrame(combined_results)\r\n            \r\n        except (ValueError, KeyError) as e:\r\n            return DataFrame([{\"error\": f\"Invalid configuration: {e!s}\"}])\r\n        except ConnectionError as e:\r\n            return DataFrame([{\"error\": f\"Connection error: {e!s}\"}])\r\n        except RuntimeError as e:\r\n            return DataFrame([{\"error\": f\"Error occurred while searching: {e!s}\"}])\r\n    \r\n    def build(self):\r\n        return self.search_google_dual"
              },
              "google_api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Google API Key",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": true,
                "name": "google_api_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "google_cse_id": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Google CSE ID",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "load_from_db": true,
                "name": "google_cse_id",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "input_value_1": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "First Search Query",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value_1",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "input_value_2": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Second Search Query",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value_2",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "k_per_query": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Number of results per query",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "k_per_query",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 3
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "GoogleSearchAPICore"
        },
        "id": "GoogleSearchAPICore-fbA6H",
        "measured": {
          "height": 576,
          "width": 320
        },
        "position": {
          "x": 645.6930172072198,
          "y": 2506.4730525042432
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-XCXGA",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Format a DataFrame or Data object into text using a template. Enable 'Stringify' to convert input into a readable string instead.",
            "display_name": "Parser",
            "documentation": "",
            "edited": true,
            "field_order": [
              "mode",
              "pattern",
              "input_data",
              "sep"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Text3",
                "hidden": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Text3\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{query2}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "id": "ParserComponent-XCXGA",
        "measured": {
          "height": 392,
          "width": 320
        },
        "position": {
          "x": 203.49088675670646,
          "y": 2476.8733573494283
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "DataFrameOperationsComponent-r917l",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Perform various operations on a DataFrame.",
            "display_name": "DataFrame Operations",
            "documentation": "",
            "edited": false,
            "field_order": [
              "df",
              "operation",
              "column_name",
              "filter_value",
              "ascending",
              "new_column_name",
              "new_column_value",
              "columns_to_select",
              "num_rows",
              "replace_value",
              "replacement_value"
            ],
            "frozen": false,
            "icon": "table",
            "key": "DataFrameOperationsComponent",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": false,
                "method": "perform_operation",
                "name": "output",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.007568328950209746,
            "template": {
              "_type": "Component",
              "ascending": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "column_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Index == 0"
              },
              "new_column_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 5
              },
              "operation": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Tail"
              },
              "replace_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "DataFrameOperationsComponent"
        },
        "id": "DataFrameOperationsComponent-r917l",
        "measured": {
          "height": 354,
          "width": 320
        },
        "position": {
          "x": 1538.1306297442397,
          "y": 3247.358315252387
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "DataFrameOperationsComponent-NJBFS",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Perform various operations on a DataFrame.",
            "display_name": "DataFrame Operations",
            "documentation": "",
            "edited": false,
            "field_order": [
              "df",
              "operation",
              "column_name",
              "filter_value",
              "ascending",
              "new_column_name",
              "new_column_value",
              "columns_to_select",
              "num_rows",
              "replace_value",
              "replacement_value"
            ],
            "frozen": false,
            "icon": "table",
            "key": "DataFrameOperationsComponent",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": false,
                "method": "perform_operation",
                "name": "output",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.007568328950209746,
            "template": {
              "_type": "Component",
              "ascending": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "column_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Index == 0"
              },
              "new_column_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 4
              },
              "operation": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Tail"
              },
              "replace_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "DataFrameOperationsComponent"
        },
        "id": "DataFrameOperationsComponent-NJBFS",
        "measured": {
          "height": 354,
          "width": 320
        },
        "position": {
          "x": 1916.0122988026733,
          "y": 3626.101693848577
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "MergeDataComponent-uMDUE",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Combines data using different operations",
            "display_name": "Combine Data",
            "documentation": "",
            "edited": false,
            "field_order": [
              "data_inputs",
              "operation"
            ],
            "frozen": false,
            "icon": "merge",
            "key": "MergeDataComponent",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": false,
                "method": "combine_data",
                "name": "combined_data",
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.00034514373933585633,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from enum import Enum\nfrom typing import cast\n\nfrom loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, DropdownInput, Output\nfrom langflow.schema import DataFrame\n\n\nclass DataOperation(str, Enum):\n    CONCATENATE = \"Concatenate\"\n    APPEND = \"Append\"\n    MERGE = \"Merge\"\n    JOIN = \"Join\"\n\n\nclass MergeDataComponent(Component):\n    display_name = \"Combine Data\"\n    description = \"Combines data using different operations\"\n    icon = \"merge\"\n    MIN_INPUTS_REQUIRED = 2\n\n    inputs = [\n        DataInput(name=\"data_inputs\", display_name=\"Data Inputs\", info=\"Data to combine\", is_list=True, required=True),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation Type\",\n            options=[op.value for op in DataOperation],\n            value=DataOperation.CONCATENATE.value,\n        ),\n    ]\n    outputs = [Output(display_name=\"DataFrame\", name=\"combined_data\", method=\"combine_data\")]\n\n    def combine_data(self) -> DataFrame:\n        if not self.data_inputs or len(self.data_inputs) < self.MIN_INPUTS_REQUIRED:\n            empty_dataframe = DataFrame()\n            self.status = empty_dataframe\n            return empty_dataframe\n\n        operation = DataOperation(self.operation)\n        try:\n            combined_dataframe = self._process_operation(operation)\n            self.status = combined_dataframe\n        except Exception as e:\n            logger.error(f\"Error during operation {operation}: {e!s}\")\n            raise\n        else:\n            return combined_dataframe\n\n    def _process_operation(self, operation: DataOperation) -> DataFrame:\n        if operation == DataOperation.CONCATENATE:\n            combined_data: dict[str, str | object] = {}\n            for data_input in self.data_inputs:\n                for key, value in data_input.data.items():\n                    if key in combined_data:\n                        if isinstance(combined_data[key], str) and isinstance(value, str):\n                            combined_data[key] = f\"{combined_data[key]}\\n{value}\"\n                        else:\n                            combined_data[key] = value\n                    else:\n                        combined_data[key] = value\n            return DataFrame([combined_data])\n\n        if operation == DataOperation.APPEND:\n            rows = [data_input.data for data_input in self.data_inputs]\n            return DataFrame(rows)\n\n        if operation == DataOperation.MERGE:\n            result_data: dict[str, str | list[str] | object] = {}\n            for data_input in self.data_inputs:\n                for key, value in data_input.data.items():\n                    if key in result_data and isinstance(value, str):\n                        if isinstance(result_data[key], list):\n                            cast(\"list[str]\", result_data[key]).append(value)\n                        else:\n                            result_data[key] = [result_data[key], value]\n                    else:\n                        result_data[key] = value\n            return DataFrame([result_data])\n\n        if operation == DataOperation.JOIN:\n            combined_data = {}\n            for idx, data_input in enumerate(self.data_inputs, 1):\n                for key, value in data_input.data.items():\n                    new_key = f\"{key}_doc{idx}\" if idx > 1 else key\n                    combined_data[new_key] = value\n            return DataFrame([combined_data])\n\n        return DataFrame()\n"
              },
              "data_inputs": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Data Inputs",
                "dynamic": false,
                "info": "Data to combine",
                "input_types": [
                  "Data"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "data_inputs",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "operation": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation Type",
                "dynamic": false,
                "info": "",
                "name": "operation",
                "options": [
                  "Concatenate",
                  "Append",
                  "Merge",
                  "Join"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Append"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "MergeDataComponent"
        },
        "id": "MergeDataComponent-uMDUE",
        "measured": {
          "height": 272,
          "width": 320
        },
        "position": {
          "x": 3146.8606749636374,
          "y": 2828.111957284044
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GroupNode-ivTAh",
          "node": {
            "description": "Retrieve Data from the First Link in the DataFrame.",
            "display_name": "Web Scrape",
            "documentation": "",
            "flow": {
              "data": {
                "edges": [
                  {
                    "animated": false,
                    "className": "",
                    "data": {
                      "sourceHandle": {
                        "dataType": "DataFrameOperationsComponent",
                        "id": "DataFrameOperationsComponent-AhdBA",
                        "name": "output",
                        "output_types": [
                          "DataFrame"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "input_data",
                        "id": "ParserComponent-FvC0j",
                        "inputTypes": [
                          "DataFrame",
                          "Data"
                        ],
                        "type": "other"
                      }
                    },
                    "id": "reactflow__edge-DataFrameOperationsComponent-AhdBA{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-AhdBAœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-FvC0j{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-FvC0jœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
                    "selected": false,
                    "source": "DataFrameOperationsComponent-AhdBA",
                    "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-AhdBAœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
                    "target": "ParserComponent-FvC0j",
                    "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-FvC0jœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
                  },
                  {
                    "animated": false,
                    "className": "",
                    "data": {
                      "sourceHandle": {
                        "dataType": "ParserComponent",
                        "id": "ParserComponent-FvC0j",
                        "name": "parsed_text",
                        "output_types": [
                          "Message"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "urls",
                        "id": "URLComponent-gYVEz",
                        "inputTypes": [
                          "Message"
                        ],
                        "type": "str"
                      }
                    },
                    "id": "reactflow__edge-ParserComponent-FvC0j{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-FvC0jœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-URLComponent-gYVEz{œfieldNameœ:œurlsœ,œidœ:œURLComponent-gYVEzœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
                    "selected": false,
                    "source": "ParserComponent-FvC0j",
                    "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-FvC0jœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
                    "target": "URLComponent-gYVEz",
                    "targetHandle": "{œfieldNameœ:œurlsœ,œidœ:œURLComponent-gYVEzœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
                  }
                ],
                "nodes": [
                  {
                    "data": {
                      "id": "URLComponent-gYVEz",
                      "node": {
                        "base_classes": [
                          "Data"
                        ],
                        "beta": false,
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Load and parse child links from a root URL recursively",
                        "display_name": "URL",
                        "documentation": "",
                        "edited": true,
                        "field_order": [
                          "urls",
                          "max_depth",
                          "prevent_outside",
                          "use_async",
                          "format"
                        ],
                        "frozen": false,
                        "icon": "layout-template",
                        "legacy": false,
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Data",
                            "hidden": null,
                            "method": "fetch_content",
                            "name": "data",
                            "options": null,
                            "required_inputs": null,
                            "selected": "Data",
                            "tool_mode": true,
                            "types": [
                              "Data"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import logging\nimport re\n\nfrom bs4 import BeautifulSoup\nfrom langchain_community.document_loaders import RecursiveUrlLoader\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\n\nlogger = logging.getLogger(__name__)\n\n\nclass URLComponent(Component):\n    \"\"\"A component that loads and parses child links from a root URL recursively.\"\"\"\n\n    display_name = \"URL\"\n    description = \"Load and parse child links from a root URL recursively\"\n    icon = \"layout-template\"\n    name = \"URLComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs to crawl recursively, by clicking the '+' button.\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n        ),\n        IntInput(\n            name=\"max_depth\",\n            display_name=\"Max Depth\",\n            info=(\n                \"Controls how many 'clicks' away from the initial page the crawler will go:\\n\"\n                \"- depth 1: only the initial page\\n\"\n                \"- depth 2: initial page + all pages linked directly from it\\n\"\n                \"- depth 3: initial page + direct links + links found on those direct link pages\\n\"\n                \"Note: This is about link traversal, not URL path depth.\"\n            ),\n            value=1,\n            required=False,\n        ),\n        BoolInput(\n            name=\"prevent_outside\",\n            display_name=\"Prevent Outside\",\n            info=(\n                \"If enabled, only crawls URLs within the same domain as the root URL. \"\n                \"This helps prevent the crawler from going to external websites.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_async\",\n            display_name=\"Use Async\",\n            info=(\n                \"If enabled, uses asynchronous loading which can be significantly faster \"\n                \"but might use more system resources.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.\",\n            options=[\"Text\", \"HTML\"],\n            value=\"Text\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\")\n    ]\n\n    def validate_url(self, string: str) -> bool:\n        \"\"\"Validates if the given string matches URL pattern.\"\"\"\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n            re.IGNORECASE,\n        )\n        return bool(url_regex.match(string))\n\n    def ensure_url(self, url: str) -> str:\n        \"\"\"Ensures the given string is a valid URL.\"\"\"\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"http://\" + url\n\n        if not self.validate_url(url):\n            error_msg = \"Invalid URL - \" + url\n            raise ValueError(error_msg)\n\n        return url\n\n    def fetch_content(self) -> list[Data]:\n        \"\"\"Load documents from the URLs.\"\"\"\n        all_docs = []\n        data = []\n        try:\n            urls = list({self.ensure_url(url.strip()) for url in self.urls if url.strip()})\n\n            no_urls_msg = \"No valid URLs provided.\"\n            if not urls:\n                raise ValueError(no_urls_msg)\n\n            for processed_url in urls:\n                msg = f\"Loading documents from {processed_url}\"\n                logger.info(msg)\n\n                extractor = (lambda x: x) if self.format == \"HTML\" else (lambda x: BeautifulSoup(x, \"lxml\").get_text())\n                loader = RecursiveUrlLoader(\n                    url=processed_url,\n                    max_depth=self.max_depth,\n                    prevent_outside=self.prevent_outside,\n                    use_async=self.use_async,\n                    extractor=extractor,\n                )\n\n                docs = loader.load()\n                msg = f\"Found {len(docs)} documents from {processed_url}\"\n                logger.info(msg)\n                all_docs.extend(docs)\n\n            data = [Data(text=doc.page_content, **doc.metadata) for doc in all_docs]\n            self.status = data\n\n        except Exception as e:\n            msg = f\"Error loading documents: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        \"\"\"Load documents and return their text content.\"\"\"\n        data = self.fetch_content()\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the documents to a DataFrame.\"\"\"\n        data_frame = DataFrame(self.fetch_content())\n        self.status = data_frame\n        return data_frame\n"
                          },
                          "format": {
                            "_input_type": "DropdownInput",
                            "advanced": true,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Output Format",
                            "dynamic": false,
                            "info": "Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.",
                            "name": "format",
                            "options": [
                              "Text",
                              "HTML"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Text"
                          },
                          "max_depth": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Max Depth",
                            "dynamic": false,
                            "info": "Controls how many 'clicks' away from the initial page the crawler will go:\n- depth 1: only the initial page\n- depth 2: initial page + all pages linked directly from it\n- depth 3: initial page + direct links + links found on those direct link pages\nNote: This is about link traversal, not URL path depth.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "max_depth",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "prevent_outside": {
                            "_input_type": "BoolInput",
                            "advanced": true,
                            "display_name": "Prevent Outside",
                            "dynamic": false,
                            "info": "If enabled, only crawls URLs within the same domain as the root URL. This helps prevent the crawler from going to external websites.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "prevent_outside",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "urls": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "URLs",
                            "dynamic": false,
                            "info": "Enter one or more URLs to crawl recursively, by clicking the '+' button.",
                            "input_types": [
                              "Message"
                            ],
                            "list": true,
                            "list_add_label": "Add URL",
                            "load_from_db": false,
                            "name": "urls",
                            "placeholder": "Enter a URL...",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": true,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": [
                              ""
                            ]
                          },
                          "use_async": {
                            "_input_type": "BoolInput",
                            "advanced": true,
                            "display_name": "Use Async",
                            "dynamic": false,
                            "info": "If enabled, uses asynchronous loading which can be significantly faster but might use more system resources.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "use_async",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "URLComponent"
                    },
                    "dragging": false,
                    "id": "URLComponent-gYVEz",
                    "measured": {
                      "height": 339,
                      "width": 320
                    },
                    "position": {
                      "x": -2772.5136404101927,
                      "y": -1174.6675319412188
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "ParserComponent-FvC0j",
                      "node": {
                        "base_classes": [
                          "Message"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Format a DataFrame or Data object into text using a template. Enable 'Stringify' to convert input into a readable string instead.",
                        "display_name": "Parser",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "mode",
                          "pattern",
                          "input_data",
                          "sep"
                        ],
                        "frozen": false,
                        "icon": "braces",
                        "key": "ParserComponent",
                        "legacy": false,
                        "lf_version": "1.3.4",
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Parsed Text",
                            "hidden": false,
                            "method": "parse_combined_text",
                            "name": "parsed_text",
                            "selected": "Message",
                            "tool_mode": true,
                            "types": [
                              "Message"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.5915955070868325,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "display_name": "code",
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
                          },
                          "input_data": {
                            "_input_type": "HandleInput",
                            "advanced": false,
                            "display_name": "Data or DataFrame",
                            "dynamic": false,
                            "info": "Accepts either a DataFrame or a Data object.",
                            "input_types": [
                              "DataFrame",
                              "Data"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "input_data",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "mode": {
                            "_input_type": "TabInput",
                            "advanced": false,
                            "display_name": "Mode",
                            "dynamic": false,
                            "info": "Convert into raw string instead of using a template.",
                            "name": "mode",
                            "options": [
                              "Parser",
                              "Stringify"
                            ],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "tab",
                            "value": "Parser"
                          },
                          "pattern": {
                            "_input_type": "MultilineInput",
                            "advanced": false,
                            "copy_field": false,
                            "display_name": "Template",
                            "dynamic": true,
                            "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "multiline": true,
                            "name": "pattern",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "{link}"
                          },
                          "sep": {
                            "_input_type": "MessageTextInput",
                            "advanced": true,
                            "display_name": "Separator",
                            "dynamic": false,
                            "info": "String used to separate rows/items.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "sep",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "\n"
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "ParserComponent"
                    },
                    "dragging": false,
                    "id": "ParserComponent-FvC0j",
                    "measured": {
                      "height": 394,
                      "width": 320
                    },
                    "position": {
                      "x": -3130.5182379903636,
                      "y": -1177.8294094772866
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "DataFrameOperationsComponent-AhdBA",
                      "node": {
                        "base_classes": [
                          "DataFrame"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Perform various operations on a DataFrame.",
                        "display_name": "DataFrame Operations",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "df",
                          "operation",
                          "column_name",
                          "filter_value",
                          "ascending",
                          "new_column_name",
                          "new_column_value",
                          "columns_to_select",
                          "num_rows",
                          "replace_value",
                          "replacement_value"
                        ],
                        "frozen": false,
                        "icon": "table",
                        "key": "DataFrameOperationsComponent",
                        "legacy": false,
                        "lf_version": "1.3.4",
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "DataFrame",
                            "hidden": false,
                            "method": "perform_operation",
                            "name": "output",
                            "options": null,
                            "required_inputs": null,
                            "selected": "DataFrame",
                            "tool_mode": true,
                            "types": [
                              "DataFrame"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.007568328950209746,
                        "template": {
                          "_type": "Component",
                          "ascending": {
                            "_input_type": "BoolInput",
                            "advanced": false,
                            "display_name": "Sort Ascending",
                            "dynamic": true,
                            "info": "Whether to sort in ascending order.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "ascending",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "code": {
                            "advanced": true,
                            "display_name": "code",
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
                          },
                          "column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Column Name",
                            "dynamic": true,
                            "info": "The column name to use for the operation.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "columns_to_select": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Columns to Select",
                            "dynamic": true,
                            "info": "",
                            "list": true,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "columns_to_select",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "df": {
                            "_input_type": "DataFrameInput",
                            "advanced": false,
                            "display_name": "DataFrame",
                            "dynamic": false,
                            "info": "The input DataFrame to operate on.",
                            "input_types": [
                              "DataFrame"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "df",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "filter_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Filter Value",
                            "dynamic": true,
                            "info": "The value to filter rows by.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "filter_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Index == 0"
                          },
                          "new_column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "New Column Name",
                            "dynamic": true,
                            "info": "The new column name when renaming or adding a column.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "new_column_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "New Column Value",
                            "dynamic": true,
                            "info": "The value to populate the new column with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "num_rows": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Number of Rows",
                            "dynamic": true,
                            "info": "Number of rows to return (for head/tail).",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "num_rows",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "operation": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Operation",
                            "dynamic": false,
                            "info": "Select the DataFrame operation to perform.",
                            "name": "operation",
                            "options": [
                              "Add Column",
                              "Drop Column",
                              "Filter",
                              "Head",
                              "Rename Column",
                              "Replace Value",
                              "Select Columns",
                              "Sort",
                              "Tail"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Head"
                          },
                          "replace_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Value to Replace",
                            "dynamic": true,
                            "info": "The value to replace in the column.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replace_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "replacement_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Replacement Value",
                            "dynamic": true,
                            "info": "The value to replace with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replacement_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "DataFrameOperationsComponent"
                    },
                    "dragging": false,
                    "id": "DataFrameOperationsComponent-AhdBA",
                    "measured": {
                      "height": 356,
                      "width": 320
                    },
                    "position": {
                      "x": -3492.9153486981004,
                      "y": -1187.502143226657
                    },
                    "selected": true,
                    "type": "genericNode"
                  }
                ],
                "viewport": {
                  "x": 0,
                  "y": 0,
                  "zoom": 1
                }
              },
              "description": "",
              "id": "uGesM",
              "is_component": false,
              "name": "Desperate Newton"
            },
            "frozen": false,
            "lf_version": "1.3.4",
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": false,
                "method": "fetch_content",
                "name": "URLComponent-QfCxw_data",
                "options": null,
                "proxy": {
                  "id": "URLComponent-gYVEz",
                  "name": "data",
                  "nodeDisplayName": "URL"
                },
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "template": {
              "ascending_DataFrameOperationsComponent-KY06e": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "proxy": {
                  "field": "ascending",
                  "id": "DataFrameOperationsComponent-AhdBA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code_DataFrameOperationsComponent-KY06e": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "DataFrameOperationsComponent-AhdBA"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "code_ParserComponent-DwSnw": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "ParserComponent-FvC0j"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "code_URLComponent-QfCxw": {
                "advanced": true,
                "display_name": "Code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "URLComponent-gYVEz"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import logging\nimport re\n\nfrom bs4 import BeautifulSoup\nfrom langchain_community.document_loaders import RecursiveUrlLoader\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\n\nlogger = logging.getLogger(__name__)\n\n\nclass URLComponent(Component):\n    \"\"\"A component that loads and parses child links from a root URL recursively.\"\"\"\n\n    display_name = \"URL\"\n    description = \"Load and parse child links from a root URL recursively\"\n    icon = \"layout-template\"\n    name = \"URLComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs to crawl recursively, by clicking the '+' button.\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n        ),\n        IntInput(\n            name=\"max_depth\",\n            display_name=\"Max Depth\",\n            info=(\n                \"Controls how many 'clicks' away from the initial page the crawler will go:\\n\"\n                \"- depth 1: only the initial page\\n\"\n                \"- depth 2: initial page + all pages linked directly from it\\n\"\n                \"- depth 3: initial page + direct links + links found on those direct link pages\\n\"\n                \"Note: This is about link traversal, not URL path depth.\"\n            ),\n            value=1,\n            required=False,\n        ),\n        BoolInput(\n            name=\"prevent_outside\",\n            display_name=\"Prevent Outside\",\n            info=(\n                \"If enabled, only crawls URLs within the same domain as the root URL. \"\n                \"This helps prevent the crawler from going to external websites.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_async\",\n            display_name=\"Use Async\",\n            info=(\n                \"If enabled, uses asynchronous loading which can be significantly faster \"\n                \"but might use more system resources.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.\",\n            options=[\"Text\", \"HTML\"],\n            value=\"Text\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\")\n    ]\n\n    def validate_url(self, string: str) -> bool:\n        \"\"\"Validates if the given string matches URL pattern.\"\"\"\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n            re.IGNORECASE,\n        )\n        return bool(url_regex.match(string))\n\n    def ensure_url(self, url: str) -> str:\n        \"\"\"Ensures the given string is a valid URL.\"\"\"\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"http://\" + url\n\n        if not self.validate_url(url):\n            error_msg = \"Invalid URL - \" + url\n            raise ValueError(error_msg)\n\n        return url\n\n    def fetch_content(self) -> list[Data]:\n        \"\"\"Load documents from the URLs.\"\"\"\n        all_docs = []\n        data = []\n        try:\n            urls = list({self.ensure_url(url.strip()) for url in self.urls if url.strip()})\n\n            no_urls_msg = \"No valid URLs provided.\"\n            if not urls:\n                raise ValueError(no_urls_msg)\n\n            for processed_url in urls:\n                msg = f\"Loading documents from {processed_url}\"\n                logger.info(msg)\n\n                extractor = (lambda x: x) if self.format == \"HTML\" else (lambda x: BeautifulSoup(x, \"lxml\").get_text())\n                loader = RecursiveUrlLoader(\n                    url=processed_url,\n                    max_depth=self.max_depth,\n                    prevent_outside=self.prevent_outside,\n                    use_async=self.use_async,\n                    extractor=extractor,\n                )\n\n                docs = loader.load()\n                msg = f\"Found {len(docs)} documents from {processed_url}\"\n                logger.info(msg)\n                all_docs.extend(docs)\n\n            data = [Data(text=doc.page_content, **doc.metadata) for doc in all_docs]\n            self.status = data\n\n        except Exception as e:\n            msg = f\"Error loading documents: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        \"\"\"Load documents and return their text content.\"\"\"\n        data = self.fetch_content()\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the documents to a DataFrame.\"\"\"\n        data_frame = DataFrame(self.fetch_content())\n        self.status = data_frame\n        return data_frame\n"
              },
              "column_name_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "proxy": {
                  "field": "column_name",
                  "id": "DataFrameOperationsComponent-AhdBA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "proxy": {
                  "field": "columns_to_select",
                  "id": "DataFrameOperationsComponent-AhdBA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df_DataFrameOperationsComponent-KY06e": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "proxy": {
                  "field": "df",
                  "id": "DataFrameOperationsComponent-AhdBA"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "proxy": {
                  "field": "filter_value",
                  "id": "DataFrameOperationsComponent-AhdBA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Index == 0"
              },
              "format_URLComponent-QfCxw": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Output Format",
                "dynamic": false,
                "info": "Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.",
                "name": "format",
                "options": [
                  "Text",
                  "HTML"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "format",
                  "id": "URLComponent-gYVEz"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Text"
              },
              "max_depth_URLComponent-QfCxw": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Depth",
                "dynamic": false,
                "info": "Controls how many 'clicks' away from the initial page the crawler will go:\n- depth 1: only the initial page\n- depth 2: initial page + all pages linked directly from it\n- depth 3: initial page + direct links + links found on those direct link pages\nNote: This is about link traversal, not URL path depth.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_depth",
                "placeholder": "",
                "proxy": {
                  "field": "max_depth",
                  "id": "URLComponent-gYVEz"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "mode_ParserComponent-DwSnw": {
                "_input_type": "TabInput",
                "advanced": true,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "proxy": {
                  "field": "mode",
                  "id": "ParserComponent-FvC0j"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "new_column_name_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_name",
                  "id": "DataFrameOperationsComponent-AhdBA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_value",
                  "id": "DataFrameOperationsComponent-AhdBA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows_DataFrameOperationsComponent-KY06e": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "proxy": {
                  "field": "num_rows",
                  "id": "DataFrameOperationsComponent-AhdBA"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "operation_DataFrameOperationsComponent-KY06e": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "operation",
                  "id": "DataFrameOperationsComponent-AhdBA"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Head"
              },
              "pattern_ParserComponent-DwSnw": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "proxy": {
                  "field": "pattern",
                  "id": "ParserComponent-FvC0j"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{link}"
              },
              "prevent_outside_URLComponent-QfCxw": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Prevent Outside",
                "dynamic": false,
                "info": "If enabled, only crawls URLs within the same domain as the root URL. This helps prevent the crawler from going to external websites.",
                "list": false,
                "list_add_label": "Add More",
                "name": "prevent_outside",
                "placeholder": "",
                "proxy": {
                  "field": "prevent_outside",
                  "id": "URLComponent-gYVEz"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "replace_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "proxy": {
                  "field": "replace_value",
                  "id": "DataFrameOperationsComponent-AhdBA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "proxy": {
                  "field": "replacement_value",
                  "id": "DataFrameOperationsComponent-AhdBA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sep_ParserComponent-DwSnw": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "proxy": {
                  "field": "sep",
                  "id": "ParserComponent-FvC0j"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              },
              "use_async_URLComponent-QfCxw": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Async",
                "dynamic": false,
                "info": "If enabled, uses asynchronous loading which can be significantly faster but might use more system resources.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_async",
                "placeholder": "",
                "proxy": {
                  "field": "use_async",
                  "id": "URLComponent-gYVEz"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            }
          },
          "type": "GroupNode"
        },
        "id": "GroupNode-ivTAh",
        "measured": {
          "height": 211,
          "width": 320
        },
        "position": {
          "x": 2447.416556393951,
          "y": 3553.2513204097863
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GroupNode-3CFAR",
          "node": {
            "description": "Retrieve Data from the First Link in the DataFrame.",
            "display_name": "Web Scrape",
            "documentation": "",
            "flow": {
              "data": {
                "edges": [
                  {
                    "animated": false,
                    "className": "",
                    "data": {
                      "sourceHandle": {
                        "dataType": "DataFrameOperationsComponent",
                        "id": "DataFrameOperationsComponent-VOeUF",
                        "name": "output",
                        "output_types": [
                          "DataFrame"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "input_data",
                        "id": "ParserComponent-aivcG",
                        "inputTypes": [
                          "DataFrame",
                          "Data"
                        ],
                        "type": "other"
                      }
                    },
                    "id": "reactflow__edge-DataFrameOperationsComponent-VOeUF{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-VOeUFœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-aivcG{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-aivcGœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
                    "selected": false,
                    "source": "DataFrameOperationsComponent-VOeUF",
                    "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-VOeUFœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
                    "target": "ParserComponent-aivcG",
                    "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-aivcGœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
                  },
                  {
                    "animated": false,
                    "className": "",
                    "data": {
                      "sourceHandle": {
                        "dataType": "ParserComponent",
                        "id": "ParserComponent-aivcG",
                        "name": "parsed_text",
                        "output_types": [
                          "Message"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "urls",
                        "id": "URLComponent-zpsh5",
                        "inputTypes": [
                          "Message"
                        ],
                        "type": "str"
                      }
                    },
                    "id": "reactflow__edge-ParserComponent-aivcG{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-aivcGœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-URLComponent-zpsh5{œfieldNameœ:œurlsœ,œidœ:œURLComponent-zpsh5œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
                    "selected": false,
                    "source": "ParserComponent-aivcG",
                    "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-aivcGœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
                    "target": "URLComponent-zpsh5",
                    "targetHandle": "{œfieldNameœ:œurlsœ,œidœ:œURLComponent-zpsh5œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
                  }
                ],
                "nodes": [
                  {
                    "data": {
                      "id": "URLComponent-zpsh5",
                      "node": {
                        "base_classes": [
                          "Data"
                        ],
                        "beta": false,
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Load and parse child links from a root URL recursively",
                        "display_name": "URL",
                        "documentation": "",
                        "edited": true,
                        "field_order": [
                          "urls",
                          "max_depth",
                          "prevent_outside",
                          "use_async",
                          "format"
                        ],
                        "frozen": false,
                        "icon": "layout-template",
                        "legacy": false,
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Data",
                            "hidden": null,
                            "method": "fetch_content",
                            "name": "data",
                            "options": null,
                            "required_inputs": null,
                            "selected": "Data",
                            "tool_mode": true,
                            "types": [
                              "Data"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import logging\nimport re\n\nfrom bs4 import BeautifulSoup\nfrom langchain_community.document_loaders import RecursiveUrlLoader\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\n\nlogger = logging.getLogger(__name__)\n\n\nclass URLComponent(Component):\n    \"\"\"A component that loads and parses child links from a root URL recursively.\"\"\"\n\n    display_name = \"URL\"\n    description = \"Load and parse child links from a root URL recursively\"\n    icon = \"layout-template\"\n    name = \"URLComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs to crawl recursively, by clicking the '+' button.\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n        ),\n        IntInput(\n            name=\"max_depth\",\n            display_name=\"Max Depth\",\n            info=(\n                \"Controls how many 'clicks' away from the initial page the crawler will go:\\n\"\n                \"- depth 1: only the initial page\\n\"\n                \"- depth 2: initial page + all pages linked directly from it\\n\"\n                \"- depth 3: initial page + direct links + links found on those direct link pages\\n\"\n                \"Note: This is about link traversal, not URL path depth.\"\n            ),\n            value=1,\n            required=False,\n        ),\n        BoolInput(\n            name=\"prevent_outside\",\n            display_name=\"Prevent Outside\",\n            info=(\n                \"If enabled, only crawls URLs within the same domain as the root URL. \"\n                \"This helps prevent the crawler from going to external websites.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_async\",\n            display_name=\"Use Async\",\n            info=(\n                \"If enabled, uses asynchronous loading which can be significantly faster \"\n                \"but might use more system resources.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.\",\n            options=[\"Text\", \"HTML\"],\n            value=\"Text\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\")\n    ]\n\n    def validate_url(self, string: str) -> bool:\n        \"\"\"Validates if the given string matches URL pattern.\"\"\"\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n            re.IGNORECASE,\n        )\n        return bool(url_regex.match(string))\n\n    def ensure_url(self, url: str) -> str:\n        \"\"\"Ensures the given string is a valid URL.\"\"\"\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"http://\" + url\n\n        if not self.validate_url(url):\n            error_msg = \"Invalid URL - \" + url\n            raise ValueError(error_msg)\n\n        return url\n\n    def fetch_content(self) -> list[Data]:\n        \"\"\"Load documents from the URLs.\"\"\"\n        all_docs = []\n        data = []\n        try:\n            urls = list({self.ensure_url(url.strip()) for url in self.urls if url.strip()})\n\n            no_urls_msg = \"No valid URLs provided.\"\n            if not urls:\n                raise ValueError(no_urls_msg)\n\n            for processed_url in urls:\n                msg = f\"Loading documents from {processed_url}\"\n                logger.info(msg)\n\n                extractor = (lambda x: x) if self.format == \"HTML\" else (lambda x: BeautifulSoup(x, \"lxml\").get_text())\n                loader = RecursiveUrlLoader(\n                    url=processed_url,\n                    max_depth=self.max_depth,\n                    prevent_outside=self.prevent_outside,\n                    use_async=self.use_async,\n                    extractor=extractor,\n                )\n\n                docs = loader.load()\n                msg = f\"Found {len(docs)} documents from {processed_url}\"\n                logger.info(msg)\n                all_docs.extend(docs)\n\n            data = [Data(text=doc.page_content, **doc.metadata) for doc in all_docs]\n            self.status = data\n\n        except Exception as e:\n            msg = f\"Error loading documents: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        \"\"\"Load documents and return their text content.\"\"\"\n        data = self.fetch_content()\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the documents to a DataFrame.\"\"\"\n        data_frame = DataFrame(self.fetch_content())\n        self.status = data_frame\n        return data_frame\n"
                          },
                          "format": {
                            "_input_type": "DropdownInput",
                            "advanced": true,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Output Format",
                            "dynamic": false,
                            "info": "Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.",
                            "name": "format",
                            "options": [
                              "Text",
                              "HTML"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Text"
                          },
                          "max_depth": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Max Depth",
                            "dynamic": false,
                            "info": "Controls how many 'clicks' away from the initial page the crawler will go:\n- depth 1: only the initial page\n- depth 2: initial page + all pages linked directly from it\n- depth 3: initial page + direct links + links found on those direct link pages\nNote: This is about link traversal, not URL path depth.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "max_depth",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "prevent_outside": {
                            "_input_type": "BoolInput",
                            "advanced": true,
                            "display_name": "Prevent Outside",
                            "dynamic": false,
                            "info": "If enabled, only crawls URLs within the same domain as the root URL. This helps prevent the crawler from going to external websites.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "prevent_outside",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "urls": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "URLs",
                            "dynamic": false,
                            "info": "Enter one or more URLs to crawl recursively, by clicking the '+' button.",
                            "input_types": [
                              "Message"
                            ],
                            "list": true,
                            "list_add_label": "Add URL",
                            "load_from_db": false,
                            "name": "urls",
                            "placeholder": "Enter a URL...",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": true,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": [
                              ""
                            ]
                          },
                          "use_async": {
                            "_input_type": "BoolInput",
                            "advanced": true,
                            "display_name": "Use Async",
                            "dynamic": false,
                            "info": "If enabled, uses asynchronous loading which can be significantly faster but might use more system resources.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "use_async",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "URLComponent"
                    },
                    "dragging": false,
                    "id": "URLComponent-zpsh5",
                    "measured": {
                      "height": 339,
                      "width": 320
                    },
                    "position": {
                      "x": -2772.5136404101927,
                      "y": -1174.6675319412188
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "ParserComponent-aivcG",
                      "node": {
                        "base_classes": [
                          "Message"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Format a DataFrame or Data object into text using a template. Enable 'Stringify' to convert input into a readable string instead.",
                        "display_name": "Parser",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "mode",
                          "pattern",
                          "input_data",
                          "sep"
                        ],
                        "frozen": false,
                        "icon": "braces",
                        "key": "ParserComponent",
                        "legacy": false,
                        "lf_version": "1.3.4",
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Parsed Text",
                            "hidden": false,
                            "method": "parse_combined_text",
                            "name": "parsed_text",
                            "selected": "Message",
                            "tool_mode": true,
                            "types": [
                              "Message"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.5915955070868325,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "display_name": "code",
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
                          },
                          "input_data": {
                            "_input_type": "HandleInput",
                            "advanced": false,
                            "display_name": "Data or DataFrame",
                            "dynamic": false,
                            "info": "Accepts either a DataFrame or a Data object.",
                            "input_types": [
                              "DataFrame",
                              "Data"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "input_data",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "mode": {
                            "_input_type": "TabInput",
                            "advanced": false,
                            "display_name": "Mode",
                            "dynamic": false,
                            "info": "Convert into raw string instead of using a template.",
                            "name": "mode",
                            "options": [
                              "Parser",
                              "Stringify"
                            ],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "tab",
                            "value": "Parser"
                          },
                          "pattern": {
                            "_input_type": "MultilineInput",
                            "advanced": false,
                            "copy_field": false,
                            "display_name": "Template",
                            "dynamic": true,
                            "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "multiline": true,
                            "name": "pattern",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "{link}"
                          },
                          "sep": {
                            "_input_type": "MessageTextInput",
                            "advanced": true,
                            "display_name": "Separator",
                            "dynamic": false,
                            "info": "String used to separate rows/items.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "sep",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "\n"
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "ParserComponent"
                    },
                    "dragging": false,
                    "id": "ParserComponent-aivcG",
                    "measured": {
                      "height": 394,
                      "width": 320
                    },
                    "position": {
                      "x": -3130.5182379903636,
                      "y": -1177.8294094772866
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "DataFrameOperationsComponent-VOeUF",
                      "node": {
                        "base_classes": [
                          "DataFrame"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Perform various operations on a DataFrame.",
                        "display_name": "DataFrame Operations",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "df",
                          "operation",
                          "column_name",
                          "filter_value",
                          "ascending",
                          "new_column_name",
                          "new_column_value",
                          "columns_to_select",
                          "num_rows",
                          "replace_value",
                          "replacement_value"
                        ],
                        "frozen": false,
                        "icon": "table",
                        "key": "DataFrameOperationsComponent",
                        "legacy": false,
                        "lf_version": "1.3.4",
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "DataFrame",
                            "hidden": false,
                            "method": "perform_operation",
                            "name": "output",
                            "options": null,
                            "required_inputs": null,
                            "selected": "DataFrame",
                            "tool_mode": true,
                            "types": [
                              "DataFrame"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.007568328950209746,
                        "template": {
                          "_type": "Component",
                          "ascending": {
                            "_input_type": "BoolInput",
                            "advanced": false,
                            "display_name": "Sort Ascending",
                            "dynamic": true,
                            "info": "Whether to sort in ascending order.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "ascending",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "code": {
                            "advanced": true,
                            "display_name": "code",
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
                          },
                          "column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Column Name",
                            "dynamic": true,
                            "info": "The column name to use for the operation.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "columns_to_select": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Columns to Select",
                            "dynamic": true,
                            "info": "",
                            "list": true,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "columns_to_select",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "df": {
                            "_input_type": "DataFrameInput",
                            "advanced": false,
                            "display_name": "DataFrame",
                            "dynamic": false,
                            "info": "The input DataFrame to operate on.",
                            "input_types": [
                              "DataFrame"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "df",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "filter_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Filter Value",
                            "dynamic": true,
                            "info": "The value to filter rows by.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "filter_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Index == 0"
                          },
                          "new_column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "New Column Name",
                            "dynamic": true,
                            "info": "The new column name when renaming or adding a column.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "new_column_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "New Column Value",
                            "dynamic": true,
                            "info": "The value to populate the new column with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "num_rows": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Number of Rows",
                            "dynamic": true,
                            "info": "Number of rows to return (for head/tail).",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "num_rows",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "operation": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Operation",
                            "dynamic": false,
                            "info": "Select the DataFrame operation to perform.",
                            "name": "operation",
                            "options": [
                              "Add Column",
                              "Drop Column",
                              "Filter",
                              "Head",
                              "Rename Column",
                              "Replace Value",
                              "Select Columns",
                              "Sort",
                              "Tail"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Head"
                          },
                          "replace_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Value to Replace",
                            "dynamic": true,
                            "info": "The value to replace in the column.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replace_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "replacement_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Replacement Value",
                            "dynamic": true,
                            "info": "The value to replace with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replacement_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "DataFrameOperationsComponent"
                    },
                    "dragging": false,
                    "id": "DataFrameOperationsComponent-VOeUF",
                    "measured": {
                      "height": 356,
                      "width": 320
                    },
                    "position": {
                      "x": -3492.9153486981004,
                      "y": -1187.502143226657
                    },
                    "selected": true,
                    "type": "genericNode"
                  }
                ],
                "viewport": {
                  "x": 0,
                  "y": 0,
                  "zoom": 1
                }
              },
              "description": "",
              "id": "uGesM",
              "is_component": false,
              "name": "Desperate Newton"
            },
            "frozen": false,
            "lf_version": "1.3.4",
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": false,
                "method": "fetch_content",
                "name": "URLComponent-QfCxw_data",
                "options": null,
                "proxy": {
                  "id": "URLComponent-zpsh5",
                  "name": "data",
                  "nodeDisplayName": "URL"
                },
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "template": {
              "ascending_DataFrameOperationsComponent-KY06e": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "proxy": {
                  "field": "ascending",
                  "id": "DataFrameOperationsComponent-VOeUF"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code_DataFrameOperationsComponent-KY06e": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "DataFrameOperationsComponent-VOeUF"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "code_ParserComponent-DwSnw": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "ParserComponent-aivcG"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "code_URLComponent-QfCxw": {
                "advanced": true,
                "display_name": "Code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "URLComponent-zpsh5"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import logging\nimport re\n\nfrom bs4 import BeautifulSoup\nfrom langchain_community.document_loaders import RecursiveUrlLoader\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\n\nlogger = logging.getLogger(__name__)\n\n\nclass URLComponent(Component):\n    \"\"\"A component that loads and parses child links from a root URL recursively.\"\"\"\n\n    display_name = \"URL\"\n    description = \"Load and parse child links from a root URL recursively\"\n    icon = \"layout-template\"\n    name = \"URLComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs to crawl recursively, by clicking the '+' button.\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n        ),\n        IntInput(\n            name=\"max_depth\",\n            display_name=\"Max Depth\",\n            info=(\n                \"Controls how many 'clicks' away from the initial page the crawler will go:\\n\"\n                \"- depth 1: only the initial page\\n\"\n                \"- depth 2: initial page + all pages linked directly from it\\n\"\n                \"- depth 3: initial page + direct links + links found on those direct link pages\\n\"\n                \"Note: This is about link traversal, not URL path depth.\"\n            ),\n            value=1,\n            required=False,\n        ),\n        BoolInput(\n            name=\"prevent_outside\",\n            display_name=\"Prevent Outside\",\n            info=(\n                \"If enabled, only crawls URLs within the same domain as the root URL. \"\n                \"This helps prevent the crawler from going to external websites.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_async\",\n            display_name=\"Use Async\",\n            info=(\n                \"If enabled, uses asynchronous loading which can be significantly faster \"\n                \"but might use more system resources.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.\",\n            options=[\"Text\", \"HTML\"],\n            value=\"Text\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\")\n    ]\n\n    def validate_url(self, string: str) -> bool:\n        \"\"\"Validates if the given string matches URL pattern.\"\"\"\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n            re.IGNORECASE,\n        )\n        return bool(url_regex.match(string))\n\n    def ensure_url(self, url: str) -> str:\n        \"\"\"Ensures the given string is a valid URL.\"\"\"\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"http://\" + url\n\n        if not self.validate_url(url):\n            error_msg = \"Invalid URL - \" + url\n            raise ValueError(error_msg)\n\n        return url\n\n    def fetch_content(self) -> list[Data]:\n        \"\"\"Load documents from the URLs.\"\"\"\n        all_docs = []\n        data = []\n        try:\n            urls = list({self.ensure_url(url.strip()) for url in self.urls if url.strip()})\n\n            no_urls_msg = \"No valid URLs provided.\"\n            if not urls:\n                raise ValueError(no_urls_msg)\n\n            for processed_url in urls:\n                msg = f\"Loading documents from {processed_url}\"\n                logger.info(msg)\n\n                extractor = (lambda x: x) if self.format == \"HTML\" else (lambda x: BeautifulSoup(x, \"lxml\").get_text())\n                loader = RecursiveUrlLoader(\n                    url=processed_url,\n                    max_depth=self.max_depth,\n                    prevent_outside=self.prevent_outside,\n                    use_async=self.use_async,\n                    extractor=extractor,\n                )\n\n                docs = loader.load()\n                msg = f\"Found {len(docs)} documents from {processed_url}\"\n                logger.info(msg)\n                all_docs.extend(docs)\n\n            data = [Data(text=doc.page_content, **doc.metadata) for doc in all_docs]\n            self.status = data\n\n        except Exception as e:\n            msg = f\"Error loading documents: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        \"\"\"Load documents and return their text content.\"\"\"\n        data = self.fetch_content()\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the documents to a DataFrame.\"\"\"\n        data_frame = DataFrame(self.fetch_content())\n        self.status = data_frame\n        return data_frame\n"
              },
              "column_name_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "proxy": {
                  "field": "column_name",
                  "id": "DataFrameOperationsComponent-VOeUF"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "proxy": {
                  "field": "columns_to_select",
                  "id": "DataFrameOperationsComponent-VOeUF"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df_DataFrameOperationsComponent-KY06e": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "proxy": {
                  "field": "df",
                  "id": "DataFrameOperationsComponent-VOeUF"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "proxy": {
                  "field": "filter_value",
                  "id": "DataFrameOperationsComponent-VOeUF"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Index == 0"
              },
              "format_URLComponent-QfCxw": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Output Format",
                "dynamic": false,
                "info": "Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.",
                "name": "format",
                "options": [
                  "Text",
                  "HTML"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "format",
                  "id": "URLComponent-zpsh5"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Text"
              },
              "max_depth_URLComponent-QfCxw": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Depth",
                "dynamic": false,
                "info": "Controls how many 'clicks' away from the initial page the crawler will go:\n- depth 1: only the initial page\n- depth 2: initial page + all pages linked directly from it\n- depth 3: initial page + direct links + links found on those direct link pages\nNote: This is about link traversal, not URL path depth.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_depth",
                "placeholder": "",
                "proxy": {
                  "field": "max_depth",
                  "id": "URLComponent-zpsh5"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "mode_ParserComponent-DwSnw": {
                "_input_type": "TabInput",
                "advanced": true,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "proxy": {
                  "field": "mode",
                  "id": "ParserComponent-aivcG"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "new_column_name_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_name",
                  "id": "DataFrameOperationsComponent-VOeUF"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_value",
                  "id": "DataFrameOperationsComponent-VOeUF"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows_DataFrameOperationsComponent-KY06e": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "proxy": {
                  "field": "num_rows",
                  "id": "DataFrameOperationsComponent-VOeUF"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "operation_DataFrameOperationsComponent-KY06e": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "operation",
                  "id": "DataFrameOperationsComponent-VOeUF"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Head"
              },
              "pattern_ParserComponent-DwSnw": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "proxy": {
                  "field": "pattern",
                  "id": "ParserComponent-aivcG"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{link}"
              },
              "prevent_outside_URLComponent-QfCxw": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Prevent Outside",
                "dynamic": false,
                "info": "If enabled, only crawls URLs within the same domain as the root URL. This helps prevent the crawler from going to external websites.",
                "list": false,
                "list_add_label": "Add More",
                "name": "prevent_outside",
                "placeholder": "",
                "proxy": {
                  "field": "prevent_outside",
                  "id": "URLComponent-zpsh5"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "replace_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "proxy": {
                  "field": "replace_value",
                  "id": "DataFrameOperationsComponent-VOeUF"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "proxy": {
                  "field": "replacement_value",
                  "id": "DataFrameOperationsComponent-VOeUF"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sep_ParserComponent-DwSnw": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "proxy": {
                  "field": "sep",
                  "id": "ParserComponent-aivcG"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              },
              "use_async_URLComponent-QfCxw": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Async",
                "dynamic": false,
                "info": "If enabled, uses asynchronous loading which can be significantly faster but might use more system resources.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_async",
                "placeholder": "",
                "proxy": {
                  "field": "use_async",
                  "id": "URLComponent-zpsh5"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            }
          },
          "type": "GroupNode"
        },
        "id": "GroupNode-3CFAR",
        "measured": {
          "height": 211,
          "width": 320
        },
        "position": {
          "x": 2108.1992667815093,
          "y": 3208.913150177894
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GroupNode-E2Cn9",
          "node": {
            "description": "Retrieve Data from the First Link in the DataFrame.",
            "display_name": "Web Scrape",
            "documentation": "",
            "flow": {
              "data": {
                "edges": [
                  {
                    "animated": false,
                    "className": "",
                    "data": {
                      "sourceHandle": {
                        "dataType": "DataFrameOperationsComponent",
                        "id": "DataFrameOperationsComponent-hzUrd",
                        "name": "output",
                        "output_types": [
                          "DataFrame"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "input_data",
                        "id": "ParserComponent-EA2Va",
                        "inputTypes": [
                          "DataFrame",
                          "Data"
                        ],
                        "type": "other"
                      }
                    },
                    "id": "reactflow__edge-DataFrameOperationsComponent-hzUrd{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-hzUrdœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-EA2Va{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-EA2Vaœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
                    "selected": false,
                    "source": "DataFrameOperationsComponent-hzUrd",
                    "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-hzUrdœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
                    "target": "ParserComponent-EA2Va",
                    "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-EA2Vaœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
                  },
                  {
                    "animated": false,
                    "className": "",
                    "data": {
                      "sourceHandle": {
                        "dataType": "ParserComponent",
                        "id": "ParserComponent-EA2Va",
                        "name": "parsed_text",
                        "output_types": [
                          "Message"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "urls",
                        "id": "URLComponent-v20vj",
                        "inputTypes": [
                          "Message"
                        ],
                        "type": "str"
                      }
                    },
                    "id": "reactflow__edge-ParserComponent-EA2Va{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-EA2Vaœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-URLComponent-v20vj{œfieldNameœ:œurlsœ,œidœ:œURLComponent-v20vjœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
                    "selected": false,
                    "source": "ParserComponent-EA2Va",
                    "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-EA2Vaœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
                    "target": "URLComponent-v20vj",
                    "targetHandle": "{œfieldNameœ:œurlsœ,œidœ:œURLComponent-v20vjœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
                  }
                ],
                "nodes": [
                  {
                    "data": {
                      "id": "URLComponent-v20vj",
                      "node": {
                        "base_classes": [
                          "Data"
                        ],
                        "beta": false,
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Load and parse child links from a root URL recursively",
                        "display_name": "URL",
                        "documentation": "",
                        "edited": true,
                        "field_order": [
                          "urls",
                          "max_depth",
                          "prevent_outside",
                          "use_async",
                          "format"
                        ],
                        "frozen": false,
                        "icon": "layout-template",
                        "legacy": false,
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Data",
                            "hidden": null,
                            "method": "fetch_content",
                            "name": "data",
                            "options": null,
                            "required_inputs": null,
                            "selected": "Data",
                            "tool_mode": true,
                            "types": [
                              "Data"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import logging\nimport re\n\nfrom bs4 import BeautifulSoup\nfrom langchain_community.document_loaders import RecursiveUrlLoader\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\n\nlogger = logging.getLogger(__name__)\n\n\nclass URLComponent(Component):\n    \"\"\"A component that loads and parses child links from a root URL recursively.\"\"\"\n\n    display_name = \"URL\"\n    description = \"Load and parse child links from a root URL recursively\"\n    icon = \"layout-template\"\n    name = \"URLComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs to crawl recursively, by clicking the '+' button.\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n        ),\n        IntInput(\n            name=\"max_depth\",\n            display_name=\"Max Depth\",\n            info=(\n                \"Controls how many 'clicks' away from the initial page the crawler will go:\\n\"\n                \"- depth 1: only the initial page\\n\"\n                \"- depth 2: initial page + all pages linked directly from it\\n\"\n                \"- depth 3: initial page + direct links + links found on those direct link pages\\n\"\n                \"Note: This is about link traversal, not URL path depth.\"\n            ),\n            value=1,\n            required=False,\n        ),\n        BoolInput(\n            name=\"prevent_outside\",\n            display_name=\"Prevent Outside\",\n            info=(\n                \"If enabled, only crawls URLs within the same domain as the root URL. \"\n                \"This helps prevent the crawler from going to external websites.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_async\",\n            display_name=\"Use Async\",\n            info=(\n                \"If enabled, uses asynchronous loading which can be significantly faster \"\n                \"but might use more system resources.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.\",\n            options=[\"Text\", \"HTML\"],\n            value=\"Text\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\")\n    ]\n\n    def validate_url(self, string: str) -> bool:\n        \"\"\"Validates if the given string matches URL pattern.\"\"\"\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n            re.IGNORECASE,\n        )\n        return bool(url_regex.match(string))\n\n    def ensure_url(self, url: str) -> str:\n        \"\"\"Ensures the given string is a valid URL.\"\"\"\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"http://\" + url\n\n        if not self.validate_url(url):\n            error_msg = \"Invalid URL - \" + url\n            raise ValueError(error_msg)\n\n        return url\n\n    def fetch_content(self) -> list[Data]:\n        \"\"\"Load documents from the URLs.\"\"\"\n        all_docs = []\n        data = []\n        try:\n            urls = list({self.ensure_url(url.strip()) for url in self.urls if url.strip()})\n\n            no_urls_msg = \"No valid URLs provided.\"\n            if not urls:\n                raise ValueError(no_urls_msg)\n\n            for processed_url in urls:\n                msg = f\"Loading documents from {processed_url}\"\n                logger.info(msg)\n\n                extractor = (lambda x: x) if self.format == \"HTML\" else (lambda x: BeautifulSoup(x, \"lxml\").get_text())\n                loader = RecursiveUrlLoader(\n                    url=processed_url,\n                    max_depth=self.max_depth,\n                    prevent_outside=self.prevent_outside,\n                    use_async=self.use_async,\n                    extractor=extractor,\n                )\n\n                docs = loader.load()\n                msg = f\"Found {len(docs)} documents from {processed_url}\"\n                logger.info(msg)\n                all_docs.extend(docs)\n\n            data = [Data(text=doc.page_content, **doc.metadata) for doc in all_docs]\n            self.status = data\n\n        except Exception as e:\n            msg = f\"Error loading documents: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        \"\"\"Load documents and return their text content.\"\"\"\n        data = self.fetch_content()\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the documents to a DataFrame.\"\"\"\n        data_frame = DataFrame(self.fetch_content())\n        self.status = data_frame\n        return data_frame\n"
                          },
                          "format": {
                            "_input_type": "DropdownInput",
                            "advanced": true,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Output Format",
                            "dynamic": false,
                            "info": "Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.",
                            "name": "format",
                            "options": [
                              "Text",
                              "HTML"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Text"
                          },
                          "max_depth": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Max Depth",
                            "dynamic": false,
                            "info": "Controls how many 'clicks' away from the initial page the crawler will go:\n- depth 1: only the initial page\n- depth 2: initial page + all pages linked directly from it\n- depth 3: initial page + direct links + links found on those direct link pages\nNote: This is about link traversal, not URL path depth.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "max_depth",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "prevent_outside": {
                            "_input_type": "BoolInput",
                            "advanced": true,
                            "display_name": "Prevent Outside",
                            "dynamic": false,
                            "info": "If enabled, only crawls URLs within the same domain as the root URL. This helps prevent the crawler from going to external websites.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "prevent_outside",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "urls": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "URLs",
                            "dynamic": false,
                            "info": "Enter one or more URLs to crawl recursively, by clicking the '+' button.",
                            "input_types": [
                              "Message"
                            ],
                            "list": true,
                            "list_add_label": "Add URL",
                            "load_from_db": false,
                            "name": "urls",
                            "placeholder": "Enter a URL...",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": true,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": [
                              ""
                            ]
                          },
                          "use_async": {
                            "_input_type": "BoolInput",
                            "advanced": true,
                            "display_name": "Use Async",
                            "dynamic": false,
                            "info": "If enabled, uses asynchronous loading which can be significantly faster but might use more system resources.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "use_async",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "URLComponent"
                    },
                    "dragging": false,
                    "id": "URLComponent-v20vj",
                    "measured": {
                      "height": 339,
                      "width": 320
                    },
                    "position": {
                      "x": -2772.5136404101927,
                      "y": -1174.6675319412188
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "ParserComponent-EA2Va",
                      "node": {
                        "base_classes": [
                          "Message"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Format a DataFrame or Data object into text using a template. Enable 'Stringify' to convert input into a readable string instead.",
                        "display_name": "Parser",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "mode",
                          "pattern",
                          "input_data",
                          "sep"
                        ],
                        "frozen": false,
                        "icon": "braces",
                        "key": "ParserComponent",
                        "legacy": false,
                        "lf_version": "1.3.4",
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Parsed Text",
                            "hidden": false,
                            "method": "parse_combined_text",
                            "name": "parsed_text",
                            "selected": "Message",
                            "tool_mode": true,
                            "types": [
                              "Message"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.5915955070868325,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "display_name": "code",
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
                          },
                          "input_data": {
                            "_input_type": "HandleInput",
                            "advanced": false,
                            "display_name": "Data or DataFrame",
                            "dynamic": false,
                            "info": "Accepts either a DataFrame or a Data object.",
                            "input_types": [
                              "DataFrame",
                              "Data"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "input_data",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "mode": {
                            "_input_type": "TabInput",
                            "advanced": false,
                            "display_name": "Mode",
                            "dynamic": false,
                            "info": "Convert into raw string instead of using a template.",
                            "name": "mode",
                            "options": [
                              "Parser",
                              "Stringify"
                            ],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "tab",
                            "value": "Parser"
                          },
                          "pattern": {
                            "_input_type": "MultilineInput",
                            "advanced": false,
                            "copy_field": false,
                            "display_name": "Template",
                            "dynamic": true,
                            "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "multiline": true,
                            "name": "pattern",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "{link}"
                          },
                          "sep": {
                            "_input_type": "MessageTextInput",
                            "advanced": true,
                            "display_name": "Separator",
                            "dynamic": false,
                            "info": "String used to separate rows/items.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "sep",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "\n"
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "ParserComponent"
                    },
                    "dragging": false,
                    "id": "ParserComponent-EA2Va",
                    "measured": {
                      "height": 394,
                      "width": 320
                    },
                    "position": {
                      "x": -3130.5182379903636,
                      "y": -1177.8294094772866
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "DataFrameOperationsComponent-hzUrd",
                      "node": {
                        "base_classes": [
                          "DataFrame"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Perform various operations on a DataFrame.",
                        "display_name": "DataFrame Operations",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "df",
                          "operation",
                          "column_name",
                          "filter_value",
                          "ascending",
                          "new_column_name",
                          "new_column_value",
                          "columns_to_select",
                          "num_rows",
                          "replace_value",
                          "replacement_value"
                        ],
                        "frozen": false,
                        "icon": "table",
                        "key": "DataFrameOperationsComponent",
                        "legacy": false,
                        "lf_version": "1.3.4",
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "DataFrame",
                            "hidden": false,
                            "method": "perform_operation",
                            "name": "output",
                            "options": null,
                            "required_inputs": null,
                            "selected": "DataFrame",
                            "tool_mode": true,
                            "types": [
                              "DataFrame"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.007568328950209746,
                        "template": {
                          "_type": "Component",
                          "ascending": {
                            "_input_type": "BoolInput",
                            "advanced": false,
                            "display_name": "Sort Ascending",
                            "dynamic": true,
                            "info": "Whether to sort in ascending order.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "ascending",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "code": {
                            "advanced": true,
                            "display_name": "code",
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
                          },
                          "column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Column Name",
                            "dynamic": true,
                            "info": "The column name to use for the operation.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "columns_to_select": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Columns to Select",
                            "dynamic": true,
                            "info": "",
                            "list": true,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "columns_to_select",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "df": {
                            "_input_type": "DataFrameInput",
                            "advanced": false,
                            "display_name": "DataFrame",
                            "dynamic": false,
                            "info": "The input DataFrame to operate on.",
                            "input_types": [
                              "DataFrame"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "df",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "filter_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Filter Value",
                            "dynamic": true,
                            "info": "The value to filter rows by.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "filter_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Index == 0"
                          },
                          "new_column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "New Column Name",
                            "dynamic": true,
                            "info": "The new column name when renaming or adding a column.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "new_column_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "New Column Value",
                            "dynamic": true,
                            "info": "The value to populate the new column with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "num_rows": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Number of Rows",
                            "dynamic": true,
                            "info": "Number of rows to return (for head/tail).",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "num_rows",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "operation": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Operation",
                            "dynamic": false,
                            "info": "Select the DataFrame operation to perform.",
                            "name": "operation",
                            "options": [
                              "Add Column",
                              "Drop Column",
                              "Filter",
                              "Head",
                              "Rename Column",
                              "Replace Value",
                              "Select Columns",
                              "Sort",
                              "Tail"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Head"
                          },
                          "replace_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Value to Replace",
                            "dynamic": true,
                            "info": "The value to replace in the column.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replace_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "replacement_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Replacement Value",
                            "dynamic": true,
                            "info": "The value to replace with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replacement_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "DataFrameOperationsComponent"
                    },
                    "dragging": false,
                    "id": "DataFrameOperationsComponent-hzUrd",
                    "measured": {
                      "height": 356,
                      "width": 320
                    },
                    "position": {
                      "x": -3492.9153486981004,
                      "y": -1187.502143226657
                    },
                    "selected": true,
                    "type": "genericNode"
                  }
                ],
                "viewport": {
                  "x": 0,
                  "y": 0,
                  "zoom": 1
                }
              },
              "description": "",
              "id": "uGesM",
              "is_component": false,
              "name": "Desperate Newton"
            },
            "frozen": false,
            "lf_version": "1.3.4",
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": false,
                "method": "fetch_content",
                "name": "URLComponent-QfCxw_data",
                "options": null,
                "proxy": {
                  "id": "URLComponent-v20vj",
                  "name": "data",
                  "nodeDisplayName": "URL"
                },
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "template": {
              "ascending_DataFrameOperationsComponent-KY06e": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "proxy": {
                  "field": "ascending",
                  "id": "DataFrameOperationsComponent-hzUrd"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code_DataFrameOperationsComponent-KY06e": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "DataFrameOperationsComponent-hzUrd"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "code_ParserComponent-DwSnw": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "ParserComponent-EA2Va"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "code_URLComponent-QfCxw": {
                "advanced": true,
                "display_name": "Code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "URLComponent-v20vj"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import logging\nimport re\n\nfrom bs4 import BeautifulSoup\nfrom langchain_community.document_loaders import RecursiveUrlLoader\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\n\nlogger = logging.getLogger(__name__)\n\n\nclass URLComponent(Component):\n    \"\"\"A component that loads and parses child links from a root URL recursively.\"\"\"\n\n    display_name = \"URL\"\n    description = \"Load and parse child links from a root URL recursively\"\n    icon = \"layout-template\"\n    name = \"URLComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs to crawl recursively, by clicking the '+' button.\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n        ),\n        IntInput(\n            name=\"max_depth\",\n            display_name=\"Max Depth\",\n            info=(\n                \"Controls how many 'clicks' away from the initial page the crawler will go:\\n\"\n                \"- depth 1: only the initial page\\n\"\n                \"- depth 2: initial page + all pages linked directly from it\\n\"\n                \"- depth 3: initial page + direct links + links found on those direct link pages\\n\"\n                \"Note: This is about link traversal, not URL path depth.\"\n            ),\n            value=1,\n            required=False,\n        ),\n        BoolInput(\n            name=\"prevent_outside\",\n            display_name=\"Prevent Outside\",\n            info=(\n                \"If enabled, only crawls URLs within the same domain as the root URL. \"\n                \"This helps prevent the crawler from going to external websites.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_async\",\n            display_name=\"Use Async\",\n            info=(\n                \"If enabled, uses asynchronous loading which can be significantly faster \"\n                \"but might use more system resources.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.\",\n            options=[\"Text\", \"HTML\"],\n            value=\"Text\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\")\n    ]\n\n    def validate_url(self, string: str) -> bool:\n        \"\"\"Validates if the given string matches URL pattern.\"\"\"\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n            re.IGNORECASE,\n        )\n        return bool(url_regex.match(string))\n\n    def ensure_url(self, url: str) -> str:\n        \"\"\"Ensures the given string is a valid URL.\"\"\"\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"http://\" + url\n\n        if not self.validate_url(url):\n            error_msg = \"Invalid URL - \" + url\n            raise ValueError(error_msg)\n\n        return url\n\n    def fetch_content(self) -> list[Data]:\n        \"\"\"Load documents from the URLs.\"\"\"\n        all_docs = []\n        data = []\n        try:\n            urls = list({self.ensure_url(url.strip()) for url in self.urls if url.strip()})\n\n            no_urls_msg = \"No valid URLs provided.\"\n            if not urls:\n                raise ValueError(no_urls_msg)\n\n            for processed_url in urls:\n                msg = f\"Loading documents from {processed_url}\"\n                logger.info(msg)\n\n                extractor = (lambda x: x) if self.format == \"HTML\" else (lambda x: BeautifulSoup(x, \"lxml\").get_text())\n                loader = RecursiveUrlLoader(\n                    url=processed_url,\n                    max_depth=self.max_depth,\n                    prevent_outside=self.prevent_outside,\n                    use_async=self.use_async,\n                    extractor=extractor,\n                )\n\n                docs = loader.load()\n                msg = f\"Found {len(docs)} documents from {processed_url}\"\n                logger.info(msg)\n                all_docs.extend(docs)\n\n            data = [Data(text=doc.page_content, **doc.metadata) for doc in all_docs]\n            self.status = data\n\n        except Exception as e:\n            msg = f\"Error loading documents: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        \"\"\"Load documents and return their text content.\"\"\"\n        data = self.fetch_content()\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the documents to a DataFrame.\"\"\"\n        data_frame = DataFrame(self.fetch_content())\n        self.status = data_frame\n        return data_frame\n"
              },
              "column_name_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "proxy": {
                  "field": "column_name",
                  "id": "DataFrameOperationsComponent-hzUrd"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "proxy": {
                  "field": "columns_to_select",
                  "id": "DataFrameOperationsComponent-hzUrd"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df_DataFrameOperationsComponent-KY06e": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "proxy": {
                  "field": "df",
                  "id": "DataFrameOperationsComponent-hzUrd"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "proxy": {
                  "field": "filter_value",
                  "id": "DataFrameOperationsComponent-hzUrd"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Index == 0"
              },
              "format_URLComponent-QfCxw": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Output Format",
                "dynamic": false,
                "info": "Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.",
                "name": "format",
                "options": [
                  "Text",
                  "HTML"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "format",
                  "id": "URLComponent-v20vj"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Text"
              },
              "max_depth_URLComponent-QfCxw": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Depth",
                "dynamic": false,
                "info": "Controls how many 'clicks' away from the initial page the crawler will go:\n- depth 1: only the initial page\n- depth 2: initial page + all pages linked directly from it\n- depth 3: initial page + direct links + links found on those direct link pages\nNote: This is about link traversal, not URL path depth.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_depth",
                "placeholder": "",
                "proxy": {
                  "field": "max_depth",
                  "id": "URLComponent-v20vj"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "mode_ParserComponent-DwSnw": {
                "_input_type": "TabInput",
                "advanced": true,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "proxy": {
                  "field": "mode",
                  "id": "ParserComponent-EA2Va"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "new_column_name_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_name",
                  "id": "DataFrameOperationsComponent-hzUrd"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_value",
                  "id": "DataFrameOperationsComponent-hzUrd"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows_DataFrameOperationsComponent-KY06e": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "proxy": {
                  "field": "num_rows",
                  "id": "DataFrameOperationsComponent-hzUrd"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "operation_DataFrameOperationsComponent-KY06e": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "operation",
                  "id": "DataFrameOperationsComponent-hzUrd"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Head"
              },
              "pattern_ParserComponent-DwSnw": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "proxy": {
                  "field": "pattern",
                  "id": "ParserComponent-EA2Va"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{link}"
              },
              "prevent_outside_URLComponent-QfCxw": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Prevent Outside",
                "dynamic": false,
                "info": "If enabled, only crawls URLs within the same domain as the root URL. This helps prevent the crawler from going to external websites.",
                "list": false,
                "list_add_label": "Add More",
                "name": "prevent_outside",
                "placeholder": "",
                "proxy": {
                  "field": "prevent_outside",
                  "id": "URLComponent-v20vj"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "replace_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "proxy": {
                  "field": "replace_value",
                  "id": "DataFrameOperationsComponent-hzUrd"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "proxy": {
                  "field": "replacement_value",
                  "id": "DataFrameOperationsComponent-hzUrd"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sep_ParserComponent-DwSnw": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "proxy": {
                  "field": "sep",
                  "id": "ParserComponent-EA2Va"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              },
              "use_async_URLComponent-QfCxw": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Async",
                "dynamic": false,
                "info": "If enabled, uses asynchronous loading which can be significantly faster but might use more system resources.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_async",
                "placeholder": "",
                "proxy": {
                  "field": "use_async",
                  "id": "URLComponent-v20vj"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            }
          },
          "type": "GroupNode"
        },
        "id": "GroupNode-E2Cn9",
        "measured": {
          "height": 211,
          "width": 320
        },
        "position": {
          "x": 2059.155360608983,
          "y": 2848.3492510446004
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "DataFrameOperationsComponent-XodCC",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Perform various operations on a DataFrame.",
            "display_name": "DataFrame Operations",
            "documentation": "",
            "edited": false,
            "field_order": [
              "df",
              "operation",
              "column_name",
              "filter_value",
              "ascending",
              "new_column_name",
              "new_column_value",
              "columns_to_select",
              "num_rows",
              "replace_value",
              "replacement_value"
            ],
            "frozen": false,
            "icon": "table",
            "key": "DataFrameOperationsComponent",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": false,
                "method": "perform_operation",
                "name": "output",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.007568328950209746,
            "template": {
              "_type": "Component",
              "ascending": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "column_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "source_query"
              },
              "columns_to_select": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 5
              },
              "operation": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Drop Column"
              },
              "replace_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "DataFrameOperationsComponent"
        },
        "id": "DataFrameOperationsComponent-XodCC",
        "measured": {
          "height": 354,
          "width": 320
        },
        "position": {
          "x": 1174.075450226852,
          "y": 2855.951192645908
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "RemoveDuplicates-ygeiv",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Removes duplicate Data objects from a list based on the 'text' column.",
            "display_name": "Remove Duplicates",
            "documentation": "",
            "edited": true,
            "field_order": [
              "data_list"
            ],
            "frozen": false,
            "icon": "filter",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Deduplicated Data List",
                "hidden": false,
                "method": "remove_duplicates",
                "name": "deduplicated_data_list",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import List\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, Output\nfrom langflow.schema import Data\n\nclass RemoveDuplicatesComponent(Component):\n    display_name = \"Remove Duplicates\"\n    description = \"Removes duplicate Data objects from a list based on the 'text' column.\"\n    icon = \"filter\"\n    name = \"RemoveDuplicates\"\n    inputs = [\n        DataInput(\n            name=\"data_list\",\n            display_name=\"Data List\",\n            info=\"List of Data objects to remove duplicates from.\",\n            is_list=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Deduplicated Data List\", name=\"deduplicated_data_list\", method=\"remove_duplicates\"),\n    ]\n\n    def remove_duplicates(self) -> List[Data]:\n        data_list: List[Data] = self.data_list if isinstance(self.data_list, list) else []\n        unique_data_list = []\n        seen_texts = set()\n        for data_item in data_list:\n            if isinstance(data_item, Data) and isinstance(data_item.data, dict):\n                text = data_item.data.get(\"source\")\n                if text is not None and text not in seen_texts:\n                    seen_texts.add(text)\n                    unique_data_list.append(data_item)\n\n        self.status = unique_data_list # f\"Removed {len(data_list) - len(unique_data_list)} duplicates\"\n        return unique_data_list\n"
              },
              "data_list": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Data List",
                "dynamic": false,
                "info": "List of Data objects to remove duplicates from.",
                "input_types": [
                  "Data"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "data_list",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "RemoveDuplicates"
        },
        "id": "RemoveDuplicates-ygeiv",
        "measured": {
          "height": 211,
          "width": 320
        },
        "position": {
          "x": 2680.458596546977,
          "y": 2930.430982288961
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "DataFrameOperationsComponent-mxVNC",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Perform various operations on a DataFrame.",
            "display_name": "DataFrame Operations",
            "documentation": "",
            "edited": false,
            "field_order": [
              "df",
              "operation",
              "column_name",
              "filter_value",
              "ascending",
              "new_column_name",
              "new_column_value",
              "columns_to_select",
              "num_rows",
              "replace_value",
              "replacement_value"
            ],
            "frozen": false,
            "icon": "table",
            "key": "DataFrameOperationsComponent",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": false,
                "method": "perform_operation",
                "name": "output",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.007568328950209746,
            "template": {
              "_type": "Component",
              "ascending": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "column_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Index == 0"
              },
              "new_column_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 3
              },
              "operation": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Tail"
              },
              "replace_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "DataFrameOperationsComponent"
        },
        "id": "DataFrameOperationsComponent-mxVNC",
        "measured": {
          "height": 354,
          "width": 320
        },
        "position": {
          "x": 2340.8509243910876,
          "y": 3992.9136602289905
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GroupNode-0D2IO",
          "node": {
            "description": "Retrieve Data from the First Link in the DataFrame.",
            "display_name": "Web Scrape",
            "documentation": "",
            "flow": {
              "data": {
                "edges": [
                  {
                    "animated": false,
                    "className": "",
                    "data": {
                      "sourceHandle": {
                        "dataType": "DataFrameOperationsComponent",
                        "id": "DataFrameOperationsComponent-6pM1u",
                        "name": "output",
                        "output_types": [
                          "DataFrame"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "input_data",
                        "id": "ParserComponent-vDV30",
                        "inputTypes": [
                          "DataFrame",
                          "Data"
                        ],
                        "type": "other"
                      }
                    },
                    "id": "reactflow__edge-DataFrameOperationsComponent-6pM1u{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-6pM1uœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-vDV30{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-vDV30œ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
                    "selected": false,
                    "source": "DataFrameOperationsComponent-6pM1u",
                    "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-6pM1uœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
                    "target": "ParserComponent-vDV30",
                    "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-vDV30œ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
                  },
                  {
                    "animated": false,
                    "className": "",
                    "data": {
                      "sourceHandle": {
                        "dataType": "ParserComponent",
                        "id": "ParserComponent-vDV30",
                        "name": "parsed_text",
                        "output_types": [
                          "Message"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "urls",
                        "id": "URLComponent-7HbGz",
                        "inputTypes": [
                          "Message"
                        ],
                        "type": "str"
                      }
                    },
                    "id": "reactflow__edge-ParserComponent-vDV30{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-vDV30œ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-URLComponent-7HbGz{œfieldNameœ:œurlsœ,œidœ:œURLComponent-7HbGzœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
                    "selected": false,
                    "source": "ParserComponent-vDV30",
                    "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-vDV30œ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
                    "target": "URLComponent-7HbGz",
                    "targetHandle": "{œfieldNameœ:œurlsœ,œidœ:œURLComponent-7HbGzœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
                  }
                ],
                "nodes": [
                  {
                    "data": {
                      "id": "URLComponent-7HbGz",
                      "node": {
                        "base_classes": [
                          "Data"
                        ],
                        "beta": false,
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Load and parse child links from a root URL recursively",
                        "display_name": "URL",
                        "documentation": "",
                        "edited": true,
                        "field_order": [
                          "urls",
                          "max_depth",
                          "prevent_outside",
                          "use_async",
                          "format"
                        ],
                        "frozen": false,
                        "icon": "layout-template",
                        "legacy": false,
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Data",
                            "hidden": null,
                            "method": "fetch_content",
                            "name": "data",
                            "options": null,
                            "required_inputs": null,
                            "selected": "Data",
                            "tool_mode": true,
                            "types": [
                              "Data"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import logging\nimport re\n\nfrom bs4 import BeautifulSoup\nfrom langchain_community.document_loaders import RecursiveUrlLoader\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\n\nlogger = logging.getLogger(__name__)\n\n\nclass URLComponent(Component):\n    \"\"\"A component that loads and parses child links from a root URL recursively.\"\"\"\n\n    display_name = \"URL\"\n    description = \"Load and parse child links from a root URL recursively\"\n    icon = \"layout-template\"\n    name = \"URLComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs to crawl recursively, by clicking the '+' button.\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n        ),\n        IntInput(\n            name=\"max_depth\",\n            display_name=\"Max Depth\",\n            info=(\n                \"Controls how many 'clicks' away from the initial page the crawler will go:\\n\"\n                \"- depth 1: only the initial page\\n\"\n                \"- depth 2: initial page + all pages linked directly from it\\n\"\n                \"- depth 3: initial page + direct links + links found on those direct link pages\\n\"\n                \"Note: This is about link traversal, not URL path depth.\"\n            ),\n            value=1,\n            required=False,\n        ),\n        BoolInput(\n            name=\"prevent_outside\",\n            display_name=\"Prevent Outside\",\n            info=(\n                \"If enabled, only crawls URLs within the same domain as the root URL. \"\n                \"This helps prevent the crawler from going to external websites.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_async\",\n            display_name=\"Use Async\",\n            info=(\n                \"If enabled, uses asynchronous loading which can be significantly faster \"\n                \"but might use more system resources.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.\",\n            options=[\"Text\", \"HTML\"],\n            value=\"Text\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\")\n    ]\n\n    def validate_url(self, string: str) -> bool:\n        \"\"\"Validates if the given string matches URL pattern.\"\"\"\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n            re.IGNORECASE,\n        )\n        return bool(url_regex.match(string))\n\n    def ensure_url(self, url: str) -> str:\n        \"\"\"Ensures the given string is a valid URL.\"\"\"\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"http://\" + url\n\n        if not self.validate_url(url):\n            error_msg = \"Invalid URL - \" + url\n            raise ValueError(error_msg)\n\n        return url\n\n    def fetch_content(self) -> list[Data]:\n        \"\"\"Load documents from the URLs.\"\"\"\n        all_docs = []\n        data = []\n        try:\n            urls = list({self.ensure_url(url.strip()) for url in self.urls if url.strip()})\n\n            no_urls_msg = \"No valid URLs provided.\"\n            if not urls:\n                raise ValueError(no_urls_msg)\n\n            for processed_url in urls:\n                msg = f\"Loading documents from {processed_url}\"\n                logger.info(msg)\n\n                extractor = (lambda x: x) if self.format == \"HTML\" else (lambda x: BeautifulSoup(x, \"lxml\").get_text())\n                loader = RecursiveUrlLoader(\n                    url=processed_url,\n                    max_depth=self.max_depth,\n                    prevent_outside=self.prevent_outside,\n                    use_async=self.use_async,\n                    extractor=extractor,\n                )\n\n                docs = loader.load()\n                msg = f\"Found {len(docs)} documents from {processed_url}\"\n                logger.info(msg)\n                all_docs.extend(docs)\n\n            data = [Data(text=doc.page_content, **doc.metadata) for doc in all_docs]\n            self.status = data\n\n        except Exception as e:\n            msg = f\"Error loading documents: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        \"\"\"Load documents and return their text content.\"\"\"\n        data = self.fetch_content()\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the documents to a DataFrame.\"\"\"\n        data_frame = DataFrame(self.fetch_content())\n        self.status = data_frame\n        return data_frame\n"
                          },
                          "format": {
                            "_input_type": "DropdownInput",
                            "advanced": true,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Output Format",
                            "dynamic": false,
                            "info": "Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.",
                            "name": "format",
                            "options": [
                              "Text",
                              "HTML"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Text"
                          },
                          "max_depth": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Max Depth",
                            "dynamic": false,
                            "info": "Controls how many 'clicks' away from the initial page the crawler will go:\n- depth 1: only the initial page\n- depth 2: initial page + all pages linked directly from it\n- depth 3: initial page + direct links + links found on those direct link pages\nNote: This is about link traversal, not URL path depth.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "max_depth",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "prevent_outside": {
                            "_input_type": "BoolInput",
                            "advanced": true,
                            "display_name": "Prevent Outside",
                            "dynamic": false,
                            "info": "If enabled, only crawls URLs within the same domain as the root URL. This helps prevent the crawler from going to external websites.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "prevent_outside",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "urls": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "URLs",
                            "dynamic": false,
                            "info": "Enter one or more URLs to crawl recursively, by clicking the '+' button.",
                            "input_types": [
                              "Message"
                            ],
                            "list": true,
                            "list_add_label": "Add URL",
                            "load_from_db": false,
                            "name": "urls",
                            "placeholder": "Enter a URL...",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": true,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": [
                              ""
                            ]
                          },
                          "use_async": {
                            "_input_type": "BoolInput",
                            "advanced": true,
                            "display_name": "Use Async",
                            "dynamic": false,
                            "info": "If enabled, uses asynchronous loading which can be significantly faster but might use more system resources.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "use_async",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "URLComponent"
                    },
                    "dragging": false,
                    "id": "URLComponent-7HbGz",
                    "measured": {
                      "height": 339,
                      "width": 320
                    },
                    "position": {
                      "x": -2772.5136404101927,
                      "y": -1174.6675319412188
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "ParserComponent-vDV30",
                      "node": {
                        "base_classes": [
                          "Message"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Format a DataFrame or Data object into text using a template. Enable 'Stringify' to convert input into a readable string instead.",
                        "display_name": "Parser",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "mode",
                          "pattern",
                          "input_data",
                          "sep"
                        ],
                        "frozen": false,
                        "icon": "braces",
                        "key": "ParserComponent",
                        "legacy": false,
                        "lf_version": "1.3.4",
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Parsed Text",
                            "hidden": false,
                            "method": "parse_combined_text",
                            "name": "parsed_text",
                            "selected": "Message",
                            "tool_mode": true,
                            "types": [
                              "Message"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.5915955070868325,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "display_name": "code",
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
                          },
                          "input_data": {
                            "_input_type": "HandleInput",
                            "advanced": false,
                            "display_name": "Data or DataFrame",
                            "dynamic": false,
                            "info": "Accepts either a DataFrame or a Data object.",
                            "input_types": [
                              "DataFrame",
                              "Data"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "input_data",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "mode": {
                            "_input_type": "TabInput",
                            "advanced": false,
                            "display_name": "Mode",
                            "dynamic": false,
                            "info": "Convert into raw string instead of using a template.",
                            "name": "mode",
                            "options": [
                              "Parser",
                              "Stringify"
                            ],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "tab",
                            "value": "Parser"
                          },
                          "pattern": {
                            "_input_type": "MultilineInput",
                            "advanced": false,
                            "copy_field": false,
                            "display_name": "Template",
                            "dynamic": true,
                            "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "multiline": true,
                            "name": "pattern",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "{link}"
                          },
                          "sep": {
                            "_input_type": "MessageTextInput",
                            "advanced": true,
                            "display_name": "Separator",
                            "dynamic": false,
                            "info": "String used to separate rows/items.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "sep",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "\n"
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "ParserComponent"
                    },
                    "dragging": false,
                    "id": "ParserComponent-vDV30",
                    "measured": {
                      "height": 394,
                      "width": 320
                    },
                    "position": {
                      "x": -3130.5182379903636,
                      "y": -1177.8294094772866
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "DataFrameOperationsComponent-6pM1u",
                      "node": {
                        "base_classes": [
                          "DataFrame"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Perform various operations on a DataFrame.",
                        "display_name": "DataFrame Operations",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "df",
                          "operation",
                          "column_name",
                          "filter_value",
                          "ascending",
                          "new_column_name",
                          "new_column_value",
                          "columns_to_select",
                          "num_rows",
                          "replace_value",
                          "replacement_value"
                        ],
                        "frozen": false,
                        "icon": "table",
                        "key": "DataFrameOperationsComponent",
                        "legacy": false,
                        "lf_version": "1.3.4",
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "DataFrame",
                            "hidden": false,
                            "method": "perform_operation",
                            "name": "output",
                            "options": null,
                            "required_inputs": null,
                            "selected": "DataFrame",
                            "tool_mode": true,
                            "types": [
                              "DataFrame"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.007568328950209746,
                        "template": {
                          "_type": "Component",
                          "ascending": {
                            "_input_type": "BoolInput",
                            "advanced": false,
                            "display_name": "Sort Ascending",
                            "dynamic": true,
                            "info": "Whether to sort in ascending order.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "ascending",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "code": {
                            "advanced": true,
                            "display_name": "code",
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
                          },
                          "column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Column Name",
                            "dynamic": true,
                            "info": "The column name to use for the operation.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "columns_to_select": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Columns to Select",
                            "dynamic": true,
                            "info": "",
                            "list": true,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "columns_to_select",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "df": {
                            "_input_type": "DataFrameInput",
                            "advanced": false,
                            "display_name": "DataFrame",
                            "dynamic": false,
                            "info": "The input DataFrame to operate on.",
                            "input_types": [
                              "DataFrame"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "df",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "filter_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Filter Value",
                            "dynamic": true,
                            "info": "The value to filter rows by.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "filter_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Index == 0"
                          },
                          "new_column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "New Column Name",
                            "dynamic": true,
                            "info": "The new column name when renaming or adding a column.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "new_column_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "New Column Value",
                            "dynamic": true,
                            "info": "The value to populate the new column with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "num_rows": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Number of Rows",
                            "dynamic": true,
                            "info": "Number of rows to return (for head/tail).",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "num_rows",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "operation": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Operation",
                            "dynamic": false,
                            "info": "Select the DataFrame operation to perform.",
                            "name": "operation",
                            "options": [
                              "Add Column",
                              "Drop Column",
                              "Filter",
                              "Head",
                              "Rename Column",
                              "Replace Value",
                              "Select Columns",
                              "Sort",
                              "Tail"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Head"
                          },
                          "replace_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Value to Replace",
                            "dynamic": true,
                            "info": "The value to replace in the column.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replace_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "replacement_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Replacement Value",
                            "dynamic": true,
                            "info": "The value to replace with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replacement_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "DataFrameOperationsComponent"
                    },
                    "dragging": false,
                    "id": "DataFrameOperationsComponent-6pM1u",
                    "measured": {
                      "height": 356,
                      "width": 320
                    },
                    "position": {
                      "x": -3492.9153486981004,
                      "y": -1187.502143226657
                    },
                    "selected": true,
                    "type": "genericNode"
                  }
                ],
                "viewport": {
                  "x": 0,
                  "y": 0,
                  "zoom": 1
                }
              },
              "description": "",
              "id": "uGesM",
              "is_component": false,
              "name": "Desperate Newton"
            },
            "frozen": false,
            "lf_version": "1.3.4",
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": false,
                "method": "fetch_content",
                "name": "URLComponent-QfCxw_data",
                "options": null,
                "proxy": {
                  "id": "URLComponent-7HbGz",
                  "name": "data",
                  "nodeDisplayName": "URL"
                },
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "template": {
              "ascending_DataFrameOperationsComponent-KY06e": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "proxy": {
                  "field": "ascending",
                  "id": "DataFrameOperationsComponent-6pM1u"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code_DataFrameOperationsComponent-KY06e": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "DataFrameOperationsComponent-6pM1u"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "code_ParserComponent-DwSnw": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "ParserComponent-vDV30"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "code_URLComponent-QfCxw": {
                "advanced": true,
                "display_name": "Code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "URLComponent-7HbGz"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import logging\nimport re\n\nfrom bs4 import BeautifulSoup\nfrom langchain_community.document_loaders import RecursiveUrlLoader\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\n\nlogger = logging.getLogger(__name__)\n\n\nclass URLComponent(Component):\n    \"\"\"A component that loads and parses child links from a root URL recursively.\"\"\"\n\n    display_name = \"URL\"\n    description = \"Load and parse child links from a root URL recursively\"\n    icon = \"layout-template\"\n    name = \"URLComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs to crawl recursively, by clicking the '+' button.\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n        ),\n        IntInput(\n            name=\"max_depth\",\n            display_name=\"Max Depth\",\n            info=(\n                \"Controls how many 'clicks' away from the initial page the crawler will go:\\n\"\n                \"- depth 1: only the initial page\\n\"\n                \"- depth 2: initial page + all pages linked directly from it\\n\"\n                \"- depth 3: initial page + direct links + links found on those direct link pages\\n\"\n                \"Note: This is about link traversal, not URL path depth.\"\n            ),\n            value=1,\n            required=False,\n        ),\n        BoolInput(\n            name=\"prevent_outside\",\n            display_name=\"Prevent Outside\",\n            info=(\n                \"If enabled, only crawls URLs within the same domain as the root URL. \"\n                \"This helps prevent the crawler from going to external websites.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_async\",\n            display_name=\"Use Async\",\n            info=(\n                \"If enabled, uses asynchronous loading which can be significantly faster \"\n                \"but might use more system resources.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.\",\n            options=[\"Text\", \"HTML\"],\n            value=\"Text\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\")\n    ]\n\n    def validate_url(self, string: str) -> bool:\n        \"\"\"Validates if the given string matches URL pattern.\"\"\"\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n            re.IGNORECASE,\n        )\n        return bool(url_regex.match(string))\n\n    def ensure_url(self, url: str) -> str:\n        \"\"\"Ensures the given string is a valid URL.\"\"\"\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"http://\" + url\n\n        if not self.validate_url(url):\n            error_msg = \"Invalid URL - \" + url\n            raise ValueError(error_msg)\n\n        return url\n\n    def fetch_content(self) -> list[Data]:\n        \"\"\"Load documents from the URLs.\"\"\"\n        all_docs = []\n        data = []\n        try:\n            urls = list({self.ensure_url(url.strip()) for url in self.urls if url.strip()})\n\n            no_urls_msg = \"No valid URLs provided.\"\n            if not urls:\n                raise ValueError(no_urls_msg)\n\n            for processed_url in urls:\n                msg = f\"Loading documents from {processed_url}\"\n                logger.info(msg)\n\n                extractor = (lambda x: x) if self.format == \"HTML\" else (lambda x: BeautifulSoup(x, \"lxml\").get_text())\n                loader = RecursiveUrlLoader(\n                    url=processed_url,\n                    max_depth=self.max_depth,\n                    prevent_outside=self.prevent_outside,\n                    use_async=self.use_async,\n                    extractor=extractor,\n                )\n\n                docs = loader.load()\n                msg = f\"Found {len(docs)} documents from {processed_url}\"\n                logger.info(msg)\n                all_docs.extend(docs)\n\n            data = [Data(text=doc.page_content, **doc.metadata) for doc in all_docs]\n            self.status = data\n\n        except Exception as e:\n            msg = f\"Error loading documents: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        \"\"\"Load documents and return their text content.\"\"\"\n        data = self.fetch_content()\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the documents to a DataFrame.\"\"\"\n        data_frame = DataFrame(self.fetch_content())\n        self.status = data_frame\n        return data_frame\n"
              },
              "column_name_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "proxy": {
                  "field": "column_name",
                  "id": "DataFrameOperationsComponent-6pM1u"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "proxy": {
                  "field": "columns_to_select",
                  "id": "DataFrameOperationsComponent-6pM1u"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df_DataFrameOperationsComponent-KY06e": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "proxy": {
                  "field": "df",
                  "id": "DataFrameOperationsComponent-6pM1u"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "proxy": {
                  "field": "filter_value",
                  "id": "DataFrameOperationsComponent-6pM1u"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Index == 0"
              },
              "format_URLComponent-QfCxw": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Output Format",
                "dynamic": false,
                "info": "Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.",
                "name": "format",
                "options": [
                  "Text",
                  "HTML"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "format",
                  "id": "URLComponent-7HbGz"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Text"
              },
              "max_depth_URLComponent-QfCxw": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Depth",
                "dynamic": false,
                "info": "Controls how many 'clicks' away from the initial page the crawler will go:\n- depth 1: only the initial page\n- depth 2: initial page + all pages linked directly from it\n- depth 3: initial page + direct links + links found on those direct link pages\nNote: This is about link traversal, not URL path depth.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_depth",
                "placeholder": "",
                "proxy": {
                  "field": "max_depth",
                  "id": "URLComponent-7HbGz"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "mode_ParserComponent-DwSnw": {
                "_input_type": "TabInput",
                "advanced": true,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "proxy": {
                  "field": "mode",
                  "id": "ParserComponent-vDV30"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "new_column_name_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_name",
                  "id": "DataFrameOperationsComponent-6pM1u"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_value",
                  "id": "DataFrameOperationsComponent-6pM1u"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows_DataFrameOperationsComponent-KY06e": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "proxy": {
                  "field": "num_rows",
                  "id": "DataFrameOperationsComponent-6pM1u"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "operation_DataFrameOperationsComponent-KY06e": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "operation",
                  "id": "DataFrameOperationsComponent-6pM1u"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Head"
              },
              "pattern_ParserComponent-DwSnw": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "proxy": {
                  "field": "pattern",
                  "id": "ParserComponent-vDV30"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{link}"
              },
              "prevent_outside_URLComponent-QfCxw": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Prevent Outside",
                "dynamic": false,
                "info": "If enabled, only crawls URLs within the same domain as the root URL. This helps prevent the crawler from going to external websites.",
                "list": false,
                "list_add_label": "Add More",
                "name": "prevent_outside",
                "placeholder": "",
                "proxy": {
                  "field": "prevent_outside",
                  "id": "URLComponent-7HbGz"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "replace_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "proxy": {
                  "field": "replace_value",
                  "id": "DataFrameOperationsComponent-6pM1u"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "proxy": {
                  "field": "replacement_value",
                  "id": "DataFrameOperationsComponent-6pM1u"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sep_ParserComponent-DwSnw": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "proxy": {
                  "field": "sep",
                  "id": "ParserComponent-vDV30"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              },
              "use_async_URLComponent-QfCxw": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Async",
                "dynamic": false,
                "info": "If enabled, uses asynchronous loading which can be significantly faster but might use more system resources.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_async",
                "placeholder": "",
                "proxy": {
                  "field": "use_async",
                  "id": "URLComponent-7HbGz"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            }
          },
          "type": "GroupNode"
        },
        "id": "GroupNode-0D2IO",
        "measured": {
          "height": 211,
          "width": 320
        },
        "position": {
          "x": 2914.1589895855495,
          "y": 3819.3759688448336
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "DataFrameOperationsComponent-hzkRU",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Perform various operations on a DataFrame.",
            "display_name": "DataFrame Operations",
            "documentation": "",
            "edited": false,
            "field_order": [
              "df",
              "operation",
              "column_name",
              "filter_value",
              "ascending",
              "new_column_name",
              "new_column_value",
              "columns_to_select",
              "num_rows",
              "replace_value",
              "replacement_value"
            ],
            "frozen": false,
            "icon": "table",
            "key": "DataFrameOperationsComponent",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": false,
                "method": "perform_operation",
                "name": "output",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.007568328950209746,
            "template": {
              "_type": "Component",
              "ascending": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "column_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Index == 0"
              },
              "new_column_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 2
              },
              "operation": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Tail"
              },
              "replace_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "DataFrameOperationsComponent"
        },
        "id": "DataFrameOperationsComponent-hzkRU",
        "measured": {
          "height": 354,
          "width": 320
        },
        "position": {
          "x": 2448.828575257498,
          "y": 4432.077927331178
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GroupNode-qAkK7",
          "node": {
            "description": "Retrieve Data from the First Link in the DataFrame.",
            "display_name": "Web Scrape",
            "documentation": "",
            "flow": {
              "data": {
                "edges": [
                  {
                    "animated": false,
                    "className": "",
                    "data": {
                      "sourceHandle": {
                        "dataType": "DataFrameOperationsComponent",
                        "id": "DataFrameOperationsComponent-UON6D",
                        "name": "output",
                        "output_types": [
                          "DataFrame"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "input_data",
                        "id": "ParserComponent-vrLy3",
                        "inputTypes": [
                          "DataFrame",
                          "Data"
                        ],
                        "type": "other"
                      }
                    },
                    "id": "reactflow__edge-DataFrameOperationsComponent-UON6D{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-UON6Dœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-vrLy3{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-vrLy3œ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
                    "selected": false,
                    "source": "DataFrameOperationsComponent-UON6D",
                    "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-UON6Dœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
                    "target": "ParserComponent-vrLy3",
                    "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-vrLy3œ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
                  },
                  {
                    "animated": false,
                    "className": "",
                    "data": {
                      "sourceHandle": {
                        "dataType": "ParserComponent",
                        "id": "ParserComponent-vrLy3",
                        "name": "parsed_text",
                        "output_types": [
                          "Message"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "urls",
                        "id": "URLComponent-CkOgI",
                        "inputTypes": [
                          "Message"
                        ],
                        "type": "str"
                      }
                    },
                    "id": "reactflow__edge-ParserComponent-vrLy3{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-vrLy3œ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-URLComponent-CkOgI{œfieldNameœ:œurlsœ,œidœ:œURLComponent-CkOgIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
                    "selected": false,
                    "source": "ParserComponent-vrLy3",
                    "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-vrLy3œ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
                    "target": "URLComponent-CkOgI",
                    "targetHandle": "{œfieldNameœ:œurlsœ,œidœ:œURLComponent-CkOgIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
                  }
                ],
                "nodes": [
                  {
                    "data": {
                      "id": "URLComponent-CkOgI",
                      "node": {
                        "base_classes": [
                          "Data"
                        ],
                        "beta": false,
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Load and parse child links from a root URL recursively",
                        "display_name": "URL",
                        "documentation": "",
                        "edited": true,
                        "field_order": [
                          "urls",
                          "max_depth",
                          "prevent_outside",
                          "use_async",
                          "format"
                        ],
                        "frozen": false,
                        "icon": "layout-template",
                        "legacy": false,
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Data",
                            "hidden": null,
                            "method": "fetch_content",
                            "name": "data",
                            "options": null,
                            "required_inputs": null,
                            "selected": "Data",
                            "tool_mode": true,
                            "types": [
                              "Data"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import logging\nimport re\n\nfrom bs4 import BeautifulSoup\nfrom langchain_community.document_loaders import RecursiveUrlLoader\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\n\nlogger = logging.getLogger(__name__)\n\n\nclass URLComponent(Component):\n    \"\"\"A component that loads and parses child links from a root URL recursively.\"\"\"\n\n    display_name = \"URL\"\n    description = \"Load and parse child links from a root URL recursively\"\n    icon = \"layout-template\"\n    name = \"URLComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs to crawl recursively, by clicking the '+' button.\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n        ),\n        IntInput(\n            name=\"max_depth\",\n            display_name=\"Max Depth\",\n            info=(\n                \"Controls how many 'clicks' away from the initial page the crawler will go:\\n\"\n                \"- depth 1: only the initial page\\n\"\n                \"- depth 2: initial page + all pages linked directly from it\\n\"\n                \"- depth 3: initial page + direct links + links found on those direct link pages\\n\"\n                \"Note: This is about link traversal, not URL path depth.\"\n            ),\n            value=1,\n            required=False,\n        ),\n        BoolInput(\n            name=\"prevent_outside\",\n            display_name=\"Prevent Outside\",\n            info=(\n                \"If enabled, only crawls URLs within the same domain as the root URL. \"\n                \"This helps prevent the crawler from going to external websites.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_async\",\n            display_name=\"Use Async\",\n            info=(\n                \"If enabled, uses asynchronous loading which can be significantly faster \"\n                \"but might use more system resources.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.\",\n            options=[\"Text\", \"HTML\"],\n            value=\"Text\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\")\n    ]\n\n    def validate_url(self, string: str) -> bool:\n        \"\"\"Validates if the given string matches URL pattern.\"\"\"\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n            re.IGNORECASE,\n        )\n        return bool(url_regex.match(string))\n\n    def ensure_url(self, url: str) -> str:\n        \"\"\"Ensures the given string is a valid URL.\"\"\"\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"http://\" + url\n\n        if not self.validate_url(url):\n            error_msg = \"Invalid URL - \" + url\n            raise ValueError(error_msg)\n\n        return url\n\n    def fetch_content(self) -> list[Data]:\n        \"\"\"Load documents from the URLs.\"\"\"\n        all_docs = []\n        data = []\n        try:\n            urls = list({self.ensure_url(url.strip()) for url in self.urls if url.strip()})\n\n            no_urls_msg = \"No valid URLs provided.\"\n            if not urls:\n                raise ValueError(no_urls_msg)\n\n            for processed_url in urls:\n                msg = f\"Loading documents from {processed_url}\"\n                logger.info(msg)\n\n                extractor = (lambda x: x) if self.format == \"HTML\" else (lambda x: BeautifulSoup(x, \"lxml\").get_text())\n                loader = RecursiveUrlLoader(\n                    url=processed_url,\n                    max_depth=self.max_depth,\n                    prevent_outside=self.prevent_outside,\n                    use_async=self.use_async,\n                    extractor=extractor,\n                )\n\n                docs = loader.load()\n                msg = f\"Found {len(docs)} documents from {processed_url}\"\n                logger.info(msg)\n                all_docs.extend(docs)\n\n            data = [Data(text=doc.page_content, **doc.metadata) for doc in all_docs]\n            self.status = data\n\n        except Exception as e:\n            msg = f\"Error loading documents: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        \"\"\"Load documents and return their text content.\"\"\"\n        data = self.fetch_content()\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the documents to a DataFrame.\"\"\"\n        data_frame = DataFrame(self.fetch_content())\n        self.status = data_frame\n        return data_frame\n"
                          },
                          "format": {
                            "_input_type": "DropdownInput",
                            "advanced": true,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Output Format",
                            "dynamic": false,
                            "info": "Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.",
                            "name": "format",
                            "options": [
                              "Text",
                              "HTML"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Text"
                          },
                          "max_depth": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Max Depth",
                            "dynamic": false,
                            "info": "Controls how many 'clicks' away from the initial page the crawler will go:\n- depth 1: only the initial page\n- depth 2: initial page + all pages linked directly from it\n- depth 3: initial page + direct links + links found on those direct link pages\nNote: This is about link traversal, not URL path depth.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "max_depth",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "prevent_outside": {
                            "_input_type": "BoolInput",
                            "advanced": true,
                            "display_name": "Prevent Outside",
                            "dynamic": false,
                            "info": "If enabled, only crawls URLs within the same domain as the root URL. This helps prevent the crawler from going to external websites.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "prevent_outside",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "urls": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "URLs",
                            "dynamic": false,
                            "info": "Enter one or more URLs to crawl recursively, by clicking the '+' button.",
                            "input_types": [
                              "Message"
                            ],
                            "list": true,
                            "list_add_label": "Add URL",
                            "load_from_db": false,
                            "name": "urls",
                            "placeholder": "Enter a URL...",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": true,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": [
                              ""
                            ]
                          },
                          "use_async": {
                            "_input_type": "BoolInput",
                            "advanced": true,
                            "display_name": "Use Async",
                            "dynamic": false,
                            "info": "If enabled, uses asynchronous loading which can be significantly faster but might use more system resources.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "use_async",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "URLComponent"
                    },
                    "dragging": false,
                    "id": "URLComponent-CkOgI",
                    "measured": {
                      "height": 339,
                      "width": 320
                    },
                    "position": {
                      "x": -2772.5136404101927,
                      "y": -1174.6675319412188
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "ParserComponent-vrLy3",
                      "node": {
                        "base_classes": [
                          "Message"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Format a DataFrame or Data object into text using a template. Enable 'Stringify' to convert input into a readable string instead.",
                        "display_name": "Parser",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "mode",
                          "pattern",
                          "input_data",
                          "sep"
                        ],
                        "frozen": false,
                        "icon": "braces",
                        "key": "ParserComponent",
                        "legacy": false,
                        "lf_version": "1.3.4",
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Parsed Text",
                            "hidden": false,
                            "method": "parse_combined_text",
                            "name": "parsed_text",
                            "selected": "Message",
                            "tool_mode": true,
                            "types": [
                              "Message"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.5915955070868325,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "display_name": "code",
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
                          },
                          "input_data": {
                            "_input_type": "HandleInput",
                            "advanced": false,
                            "display_name": "Data or DataFrame",
                            "dynamic": false,
                            "info": "Accepts either a DataFrame or a Data object.",
                            "input_types": [
                              "DataFrame",
                              "Data"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "input_data",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "mode": {
                            "_input_type": "TabInput",
                            "advanced": false,
                            "display_name": "Mode",
                            "dynamic": false,
                            "info": "Convert into raw string instead of using a template.",
                            "name": "mode",
                            "options": [
                              "Parser",
                              "Stringify"
                            ],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "tab",
                            "value": "Parser"
                          },
                          "pattern": {
                            "_input_type": "MultilineInput",
                            "advanced": false,
                            "copy_field": false,
                            "display_name": "Template",
                            "dynamic": true,
                            "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "multiline": true,
                            "name": "pattern",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "{link}"
                          },
                          "sep": {
                            "_input_type": "MessageTextInput",
                            "advanced": true,
                            "display_name": "Separator",
                            "dynamic": false,
                            "info": "String used to separate rows/items.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "sep",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "\n"
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "ParserComponent"
                    },
                    "dragging": false,
                    "id": "ParserComponent-vrLy3",
                    "measured": {
                      "height": 394,
                      "width": 320
                    },
                    "position": {
                      "x": -3130.5182379903636,
                      "y": -1177.8294094772866
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "DataFrameOperationsComponent-UON6D",
                      "node": {
                        "base_classes": [
                          "DataFrame"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Perform various operations on a DataFrame.",
                        "display_name": "DataFrame Operations",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "df",
                          "operation",
                          "column_name",
                          "filter_value",
                          "ascending",
                          "new_column_name",
                          "new_column_value",
                          "columns_to_select",
                          "num_rows",
                          "replace_value",
                          "replacement_value"
                        ],
                        "frozen": false,
                        "icon": "table",
                        "key": "DataFrameOperationsComponent",
                        "legacy": false,
                        "lf_version": "1.3.4",
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "DataFrame",
                            "hidden": false,
                            "method": "perform_operation",
                            "name": "output",
                            "options": null,
                            "required_inputs": null,
                            "selected": "DataFrame",
                            "tool_mode": true,
                            "types": [
                              "DataFrame"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.007568328950209746,
                        "template": {
                          "_type": "Component",
                          "ascending": {
                            "_input_type": "BoolInput",
                            "advanced": false,
                            "display_name": "Sort Ascending",
                            "dynamic": true,
                            "info": "Whether to sort in ascending order.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "ascending",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "code": {
                            "advanced": true,
                            "display_name": "code",
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
                          },
                          "column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Column Name",
                            "dynamic": true,
                            "info": "The column name to use for the operation.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "columns_to_select": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Columns to Select",
                            "dynamic": true,
                            "info": "",
                            "list": true,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "columns_to_select",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "df": {
                            "_input_type": "DataFrameInput",
                            "advanced": false,
                            "display_name": "DataFrame",
                            "dynamic": false,
                            "info": "The input DataFrame to operate on.",
                            "input_types": [
                              "DataFrame"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "df",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "filter_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Filter Value",
                            "dynamic": true,
                            "info": "The value to filter rows by.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "filter_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Index == 0"
                          },
                          "new_column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "New Column Name",
                            "dynamic": true,
                            "info": "The new column name when renaming or adding a column.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "new_column_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "New Column Value",
                            "dynamic": true,
                            "info": "The value to populate the new column with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "num_rows": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Number of Rows",
                            "dynamic": true,
                            "info": "Number of rows to return (for head/tail).",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "num_rows",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "operation": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Operation",
                            "dynamic": false,
                            "info": "Select the DataFrame operation to perform.",
                            "name": "operation",
                            "options": [
                              "Add Column",
                              "Drop Column",
                              "Filter",
                              "Head",
                              "Rename Column",
                              "Replace Value",
                              "Select Columns",
                              "Sort",
                              "Tail"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Head"
                          },
                          "replace_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Value to Replace",
                            "dynamic": true,
                            "info": "The value to replace in the column.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replace_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "replacement_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Replacement Value",
                            "dynamic": true,
                            "info": "The value to replace with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replacement_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "DataFrameOperationsComponent"
                    },
                    "dragging": false,
                    "id": "DataFrameOperationsComponent-UON6D",
                    "measured": {
                      "height": 356,
                      "width": 320
                    },
                    "position": {
                      "x": -3492.9153486981004,
                      "y": -1187.502143226657
                    },
                    "selected": true,
                    "type": "genericNode"
                  }
                ],
                "viewport": {
                  "x": 0,
                  "y": 0,
                  "zoom": 1
                }
              },
              "description": "",
              "id": "uGesM",
              "is_component": false,
              "name": "Desperate Newton"
            },
            "frozen": false,
            "lf_version": "1.3.4",
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": false,
                "method": "fetch_content",
                "name": "URLComponent-QfCxw_data",
                "options": null,
                "proxy": {
                  "id": "URLComponent-CkOgI",
                  "name": "data",
                  "nodeDisplayName": "URL"
                },
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "template": {
              "ascending_DataFrameOperationsComponent-KY06e": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "proxy": {
                  "field": "ascending",
                  "id": "DataFrameOperationsComponent-UON6D"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code_DataFrameOperationsComponent-KY06e": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "DataFrameOperationsComponent-UON6D"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "code_ParserComponent-DwSnw": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "ParserComponent-vrLy3"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "code_URLComponent-QfCxw": {
                "advanced": true,
                "display_name": "Code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "URLComponent-CkOgI"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import logging\nimport re\n\nfrom bs4 import BeautifulSoup\nfrom langchain_community.document_loaders import RecursiveUrlLoader\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\n\nlogger = logging.getLogger(__name__)\n\n\nclass URLComponent(Component):\n    \"\"\"A component that loads and parses child links from a root URL recursively.\"\"\"\n\n    display_name = \"URL\"\n    description = \"Load and parse child links from a root URL recursively\"\n    icon = \"layout-template\"\n    name = \"URLComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs to crawl recursively, by clicking the '+' button.\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n        ),\n        IntInput(\n            name=\"max_depth\",\n            display_name=\"Max Depth\",\n            info=(\n                \"Controls how many 'clicks' away from the initial page the crawler will go:\\n\"\n                \"- depth 1: only the initial page\\n\"\n                \"- depth 2: initial page + all pages linked directly from it\\n\"\n                \"- depth 3: initial page + direct links + links found on those direct link pages\\n\"\n                \"Note: This is about link traversal, not URL path depth.\"\n            ),\n            value=1,\n            required=False,\n        ),\n        BoolInput(\n            name=\"prevent_outside\",\n            display_name=\"Prevent Outside\",\n            info=(\n                \"If enabled, only crawls URLs within the same domain as the root URL. \"\n                \"This helps prevent the crawler from going to external websites.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_async\",\n            display_name=\"Use Async\",\n            info=(\n                \"If enabled, uses asynchronous loading which can be significantly faster \"\n                \"but might use more system resources.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.\",\n            options=[\"Text\", \"HTML\"],\n            value=\"Text\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\")\n    ]\n\n    def validate_url(self, string: str) -> bool:\n        \"\"\"Validates if the given string matches URL pattern.\"\"\"\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n            re.IGNORECASE,\n        )\n        return bool(url_regex.match(string))\n\n    def ensure_url(self, url: str) -> str:\n        \"\"\"Ensures the given string is a valid URL.\"\"\"\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"http://\" + url\n\n        if not self.validate_url(url):\n            error_msg = \"Invalid URL - \" + url\n            raise ValueError(error_msg)\n\n        return url\n\n    def fetch_content(self) -> list[Data]:\n        \"\"\"Load documents from the URLs.\"\"\"\n        all_docs = []\n        data = []\n        try:\n            urls = list({self.ensure_url(url.strip()) for url in self.urls if url.strip()})\n\n            no_urls_msg = \"No valid URLs provided.\"\n            if not urls:\n                raise ValueError(no_urls_msg)\n\n            for processed_url in urls:\n                msg = f\"Loading documents from {processed_url}\"\n                logger.info(msg)\n\n                extractor = (lambda x: x) if self.format == \"HTML\" else (lambda x: BeautifulSoup(x, \"lxml\").get_text())\n                loader = RecursiveUrlLoader(\n                    url=processed_url,\n                    max_depth=self.max_depth,\n                    prevent_outside=self.prevent_outside,\n                    use_async=self.use_async,\n                    extractor=extractor,\n                )\n\n                docs = loader.load()\n                msg = f\"Found {len(docs)} documents from {processed_url}\"\n                logger.info(msg)\n                all_docs.extend(docs)\n\n            data = [Data(text=doc.page_content, **doc.metadata) for doc in all_docs]\n            self.status = data\n\n        except Exception as e:\n            msg = f\"Error loading documents: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        \"\"\"Load documents and return their text content.\"\"\"\n        data = self.fetch_content()\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the documents to a DataFrame.\"\"\"\n        data_frame = DataFrame(self.fetch_content())\n        self.status = data_frame\n        return data_frame\n"
              },
              "column_name_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "proxy": {
                  "field": "column_name",
                  "id": "DataFrameOperationsComponent-UON6D"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "proxy": {
                  "field": "columns_to_select",
                  "id": "DataFrameOperationsComponent-UON6D"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df_DataFrameOperationsComponent-KY06e": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "proxy": {
                  "field": "df",
                  "id": "DataFrameOperationsComponent-UON6D"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "proxy": {
                  "field": "filter_value",
                  "id": "DataFrameOperationsComponent-UON6D"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Index == 0"
              },
              "format_URLComponent-QfCxw": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Output Format",
                "dynamic": false,
                "info": "Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.",
                "name": "format",
                "options": [
                  "Text",
                  "HTML"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "format",
                  "id": "URLComponent-CkOgI"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Text"
              },
              "max_depth_URLComponent-QfCxw": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Depth",
                "dynamic": false,
                "info": "Controls how many 'clicks' away from the initial page the crawler will go:\n- depth 1: only the initial page\n- depth 2: initial page + all pages linked directly from it\n- depth 3: initial page + direct links + links found on those direct link pages\nNote: This is about link traversal, not URL path depth.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_depth",
                "placeholder": "",
                "proxy": {
                  "field": "max_depth",
                  "id": "URLComponent-CkOgI"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "mode_ParserComponent-DwSnw": {
                "_input_type": "TabInput",
                "advanced": true,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "proxy": {
                  "field": "mode",
                  "id": "ParserComponent-vrLy3"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "new_column_name_DataFrameOperationsComponent-KY06e": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_name",
                  "id": "DataFrameOperationsComponent-UON6D"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_value",
                  "id": "DataFrameOperationsComponent-UON6D"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows_DataFrameOperationsComponent-KY06e": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "proxy": {
                  "field": "num_rows",
                  "id": "DataFrameOperationsComponent-UON6D"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "operation_DataFrameOperationsComponent-KY06e": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "operation",
                  "id": "DataFrameOperationsComponent-UON6D"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Head"
              },
              "pattern_ParserComponent-DwSnw": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "proxy": {
                  "field": "pattern",
                  "id": "ParserComponent-vrLy3"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{link}"
              },
              "prevent_outside_URLComponent-QfCxw": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Prevent Outside",
                "dynamic": false,
                "info": "If enabled, only crawls URLs within the same domain as the root URL. This helps prevent the crawler from going to external websites.",
                "list": false,
                "list_add_label": "Add More",
                "name": "prevent_outside",
                "placeholder": "",
                "proxy": {
                  "field": "prevent_outside",
                  "id": "URLComponent-CkOgI"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "replace_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "proxy": {
                  "field": "replace_value",
                  "id": "DataFrameOperationsComponent-UON6D"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value_DataFrameOperationsComponent-KY06e": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "proxy": {
                  "field": "replacement_value",
                  "id": "DataFrameOperationsComponent-UON6D"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sep_ParserComponent-DwSnw": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "proxy": {
                  "field": "sep",
                  "id": "ParserComponent-vrLy3"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              },
              "use_async_URLComponent-QfCxw": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Async",
                "dynamic": false,
                "info": "If enabled, uses asynchronous loading which can be significantly faster but might use more system resources.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_async",
                "placeholder": "",
                "proxy": {
                  "field": "use_async",
                  "id": "URLComponent-CkOgI"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            }
          },
          "type": "GroupNode"
        },
        "id": "GroupNode-qAkK7",
        "measured": {
          "height": 211,
          "width": 320
        },
        "position": {
          "x": 2876.0298616051878,
          "y": 4206.069517834849
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GroupNode-RJLyv",
          "node": {
            "description": "",
            "display_name": "Group",
            "documentation": "",
            "flow": {
              "data": {
                "edges": [
                  {
                    "animated": false,
                    "className": "",
                    "data": {
                      "sourceHandle": {
                        "dataType": "DataFrameOperationsComponent",
                        "id": "DataFrameOperationsComponent-w9bzA",
                        "name": "output",
                        "output_types": [
                          "DataFrame"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "input_data",
                        "id": "ParserComponent-m7PuY",
                        "inputTypes": [
                          "DataFrame",
                          "Data"
                        ],
                        "type": "other"
                      }
                    },
                    "id": "reactflow__edge-DataFrameOperationsComponent-w9bzA{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-w9bzAœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-m7PuY{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-m7PuYœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
                    "selected": false,
                    "source": "DataFrameOperationsComponent-w9bzA",
                    "sourceHandle": "{œdataTypeœ:œDataFrameOperationsComponentœ,œidœ:œDataFrameOperationsComponent-w9bzAœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataFrameœ]}",
                    "target": "ParserComponent-m7PuY",
                    "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-m7PuYœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
                  },
                  {
                    "animated": false,
                    "className": "",
                    "data": {
                      "sourceHandle": {
                        "dataType": "ParserComponent",
                        "id": "ParserComponent-m7PuY",
                        "name": "parsed_text",
                        "output_types": [
                          "Message"
                        ]
                      },
                      "targetHandle": {
                        "fieldName": "urls",
                        "id": "URLComponent-7ulEY",
                        "inputTypes": [
                          "Message"
                        ],
                        "type": "str"
                      }
                    },
                    "id": "reactflow__edge-ParserComponent-m7PuY{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-m7PuYœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-URLComponent-7ulEY{œfieldNameœ:œurlsœ,œidœ:œURLComponent-7ulEYœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
                    "selected": false,
                    "source": "ParserComponent-m7PuY",
                    "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-m7PuYœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
                    "target": "URLComponent-7ulEY",
                    "targetHandle": "{œfieldNameœ:œurlsœ,œidœ:œURLComponent-7ulEYœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
                  }
                ],
                "nodes": [
                  {
                    "data": {
                      "id": "URLComponent-7ulEY",
                      "node": {
                        "base_classes": [
                          "Data"
                        ],
                        "beta": false,
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Load and parse child links from a root URL recursively",
                        "display_name": "URL",
                        "documentation": "",
                        "edited": true,
                        "field_order": [
                          "urls",
                          "max_depth",
                          "prevent_outside",
                          "use_async",
                          "format"
                        ],
                        "frozen": false,
                        "icon": "layout-template",
                        "legacy": false,
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Data",
                            "hidden": null,
                            "method": "fetch_content",
                            "name": "data",
                            "options": null,
                            "required_inputs": null,
                            "selected": "Data",
                            "tool_mode": true,
                            "types": [
                              "Data"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "display_name": "code",
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import logging\nimport re\n\nfrom bs4 import BeautifulSoup\nfrom langchain_community.document_loaders import RecursiveUrlLoader\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\n\nlogger = logging.getLogger(__name__)\n\n\nclass URLComponent(Component):\n    \"\"\"A component that loads and parses child links from a root URL recursively.\"\"\"\n\n    display_name = \"URL\"\n    description = \"Load and parse child links from a root URL recursively\"\n    icon = \"layout-template\"\n    name = \"URLComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs to crawl recursively, by clicking the '+' button.\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n        ),\n        IntInput(\n            name=\"max_depth\",\n            display_name=\"Max Depth\",\n            info=(\n                \"Controls how many 'clicks' away from the initial page the crawler will go:\\n\"\n                \"- depth 1: only the initial page\\n\"\n                \"- depth 2: initial page + all pages linked directly from it\\n\"\n                \"- depth 3: initial page + direct links + links found on those direct link pages\\n\"\n                \"Note: This is about link traversal, not URL path depth.\"\n            ),\n            value=1,\n            required=False,\n        ),\n        BoolInput(\n            name=\"prevent_outside\",\n            display_name=\"Prevent Outside\",\n            info=(\n                \"If enabled, only crawls URLs within the same domain as the root URL. \"\n                \"This helps prevent the crawler from going to external websites.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_async\",\n            display_name=\"Use Async\",\n            info=(\n                \"If enabled, uses asynchronous loading which can be significantly faster \"\n                \"but might use more system resources.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.\",\n            options=[\"Text\", \"HTML\"],\n            value=\"Text\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\")\n    ]\n\n    def validate_url(self, string: str) -> bool:\n        \"\"\"Validates if the given string matches URL pattern.\"\"\"\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n            re.IGNORECASE,\n        )\n        return bool(url_regex.match(string))\n\n    def ensure_url(self, url: str) -> str:\n        \"\"\"Ensures the given string is a valid URL.\"\"\"\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"http://\" + url\n\n        if not self.validate_url(url):\n            error_msg = \"Invalid URL - \" + url\n            raise ValueError(error_msg)\n\n        return url\n\n    def fetch_content(self) -> list[Data]:\n        \"\"\"Load documents from the URLs.\"\"\"\n        all_docs = []\n        data = []\n        try:\n            urls = list({self.ensure_url(url.strip()) for url in self.urls if url.strip()})\n\n            no_urls_msg = \"No valid URLs provided.\"\n            if not urls:\n                raise ValueError(no_urls_msg)\n\n            for processed_url in urls:\n                msg = f\"Loading documents from {processed_url}\"\n                logger.info(msg)\n\n                extractor = (lambda x: x) if self.format == \"HTML\" else (lambda x: BeautifulSoup(x, \"lxml\").get_text())\n                loader = RecursiveUrlLoader(\n                    url=processed_url,\n                    max_depth=self.max_depth,\n                    prevent_outside=self.prevent_outside,\n                    use_async=self.use_async,\n                    extractor=extractor,\n                )\n\n                docs = loader.load()\n                msg = f\"Found {len(docs)} documents from {processed_url}\"\n                logger.info(msg)\n                all_docs.extend(docs)\n\n            data = [Data(text=doc.page_content, **doc.metadata) for doc in all_docs]\n            self.status = data\n\n        except Exception as e:\n            msg = f\"Error loading documents: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        \"\"\"Load documents and return their text content.\"\"\"\n        data = self.fetch_content()\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the documents to a DataFrame.\"\"\"\n        data_frame = DataFrame(self.fetch_content())\n        self.status = data_frame\n        return data_frame\n"
                          },
                          "format": {
                            "_input_type": "DropdownInput",
                            "advanced": true,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Output Format",
                            "dynamic": false,
                            "info": "Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.",
                            "name": "format",
                            "options": [
                              "Text",
                              "HTML"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Text"
                          },
                          "max_depth": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Max Depth",
                            "dynamic": false,
                            "info": "Controls how many 'clicks' away from the initial page the crawler will go:\n- depth 1: only the initial page\n- depth 2: initial page + all pages linked directly from it\n- depth 3: initial page + direct links + links found on those direct link pages\nNote: This is about link traversal, not URL path depth.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "max_depth",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "prevent_outside": {
                            "_input_type": "BoolInput",
                            "advanced": true,
                            "display_name": "Prevent Outside",
                            "dynamic": false,
                            "info": "If enabled, only crawls URLs within the same domain as the root URL. This helps prevent the crawler from going to external websites.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "prevent_outside",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "urls": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "URLs",
                            "dynamic": false,
                            "info": "Enter one or more URLs to crawl recursively, by clicking the '+' button.",
                            "input_types": [
                              "Message"
                            ],
                            "list": true,
                            "list_add_label": "Add URL",
                            "load_from_db": false,
                            "name": "urls",
                            "placeholder": "Enter a URL...",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": true,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": [
                              ""
                            ]
                          },
                          "use_async": {
                            "_input_type": "BoolInput",
                            "advanced": true,
                            "display_name": "Use Async",
                            "dynamic": false,
                            "info": "If enabled, uses asynchronous loading which can be significantly faster but might use more system resources.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "use_async",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "URLComponent"
                    },
                    "dragging": false,
                    "id": "URLComponent-7ulEY",
                    "measured": {
                      "height": 339,
                      "width": 320
                    },
                    "position": {
                      "x": -1725.552309385661,
                      "y": 870.9376037542103
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "ParserComponent-m7PuY",
                      "node": {
                        "base_classes": [
                          "Message"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Format a DataFrame or Data object into text using a template. Enable 'Stringify' to convert input into a readable string instead.",
                        "display_name": "Parser",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "mode",
                          "pattern",
                          "input_data",
                          "sep"
                        ],
                        "frozen": false,
                        "icon": "braces",
                        "key": "ParserComponent",
                        "legacy": false,
                        "lf_version": "1.3.4",
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "Parsed Text",
                            "hidden": false,
                            "method": "parse_combined_text",
                            "name": "parsed_text",
                            "selected": "Message",
                            "tool_mode": true,
                            "types": [
                              "Message"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.5915955070868325,
                        "template": {
                          "_type": "Component",
                          "code": {
                            "advanced": true,
                            "display_name": "code",
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
                          },
                          "input_data": {
                            "_input_type": "HandleInput",
                            "advanced": false,
                            "display_name": "Data or DataFrame",
                            "dynamic": false,
                            "info": "Accepts either a DataFrame or a Data object.",
                            "input_types": [
                              "DataFrame",
                              "Data"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "input_data",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "mode": {
                            "_input_type": "TabInput",
                            "advanced": false,
                            "display_name": "Mode",
                            "dynamic": false,
                            "info": "Convert into raw string instead of using a template.",
                            "name": "mode",
                            "options": [
                              "Parser",
                              "Stringify"
                            ],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "tab",
                            "value": "Parser"
                          },
                          "pattern": {
                            "_input_type": "MultilineInput",
                            "advanced": false,
                            "copy_field": false,
                            "display_name": "Template",
                            "dynamic": true,
                            "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "multiline": true,
                            "name": "pattern",
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "{link}"
                          },
                          "sep": {
                            "_input_type": "MessageTextInput",
                            "advanced": true,
                            "display_name": "Separator",
                            "dynamic": false,
                            "info": "String used to separate rows/items.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "sep",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "\n"
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "ParserComponent"
                    },
                    "dragging": false,
                    "id": "ParserComponent-m7PuY",
                    "measured": {
                      "height": 394,
                      "width": 320
                    },
                    "position": {
                      "x": -2083.556906965832,
                      "y": 867.7757262181425
                    },
                    "selected": true,
                    "type": "genericNode"
                  },
                  {
                    "data": {
                      "id": "DataFrameOperationsComponent-w9bzA",
                      "node": {
                        "base_classes": [
                          "DataFrame"
                        ],
                        "beta": false,
                        "category": "processing",
                        "conditional_paths": [],
                        "custom_fields": {},
                        "description": "Perform various operations on a DataFrame.",
                        "display_name": "DataFrame Operations",
                        "documentation": "",
                        "edited": false,
                        "field_order": [
                          "df",
                          "operation",
                          "column_name",
                          "filter_value",
                          "ascending",
                          "new_column_name",
                          "new_column_value",
                          "columns_to_select",
                          "num_rows",
                          "replace_value",
                          "replacement_value"
                        ],
                        "frozen": false,
                        "icon": "table",
                        "key": "DataFrameOperationsComponent",
                        "legacy": false,
                        "lf_version": "1.3.4",
                        "metadata": {},
                        "minimized": false,
                        "output_types": [],
                        "outputs": [
                          {
                            "allows_loop": false,
                            "cache": true,
                            "display_name": "DataFrame",
                            "hidden": null,
                            "method": "perform_operation",
                            "name": "output",
                            "options": null,
                            "required_inputs": null,
                            "selected": "DataFrame",
                            "tool_mode": true,
                            "types": [
                              "DataFrame"
                            ],
                            "value": "__UNDEFINED__"
                          }
                        ],
                        "pinned": false,
                        "score": 0.007568328950209746,
                        "template": {
                          "_type": "Component",
                          "ascending": {
                            "_input_type": "BoolInput",
                            "advanced": false,
                            "display_name": "Sort Ascending",
                            "dynamic": true,
                            "info": "Whether to sort in ascending order.",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "ascending",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "bool",
                            "value": true
                          },
                          "code": {
                            "advanced": true,
                            "display_name": "code",
                            "dynamic": true,
                            "fileTypes": [],
                            "file_path": "",
                            "info": "",
                            "list": false,
                            "load_from_db": false,
                            "multiline": true,
                            "name": "code",
                            "password": false,
                            "placeholder": "",
                            "required": true,
                            "show": true,
                            "title_case": false,
                            "type": "code",
                            "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
                          },
                          "column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Column Name",
                            "dynamic": true,
                            "info": "The column name to use for the operation.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "columns_to_select": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "Columns to Select",
                            "dynamic": true,
                            "info": "",
                            "list": true,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "columns_to_select",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "df": {
                            "_input_type": "DataFrameInput",
                            "advanced": false,
                            "display_name": "DataFrame",
                            "dynamic": false,
                            "info": "The input DataFrame to operate on.",
                            "input_types": [
                              "DataFrame"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "df",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "other",
                            "value": ""
                          },
                          "filter_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Filter Value",
                            "dynamic": true,
                            "info": "The value to filter rows by.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "filter_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Index == 0"
                          },
                          "new_column_name": {
                            "_input_type": "StrInput",
                            "advanced": false,
                            "display_name": "New Column Name",
                            "dynamic": true,
                            "info": "The new column name when renaming or adding a column.",
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_name",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "new_column_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "New Column Value",
                            "dynamic": true,
                            "info": "The value to populate the new column with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "new_column_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "num_rows": {
                            "_input_type": "IntInput",
                            "advanced": false,
                            "display_name": "Number of Rows",
                            "dynamic": true,
                            "info": "Number of rows to return (for head/tail).",
                            "list": false,
                            "list_add_label": "Add More",
                            "name": "num_rows",
                            "placeholder": "",
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "int",
                            "value": 1
                          },
                          "operation": {
                            "_input_type": "DropdownInput",
                            "advanced": false,
                            "combobox": false,
                            "dialog_inputs": {},
                            "display_name": "Operation",
                            "dynamic": false,
                            "info": "Select the DataFrame operation to perform.",
                            "name": "operation",
                            "options": [
                              "Add Column",
                              "Drop Column",
                              "Filter",
                              "Head",
                              "Rename Column",
                              "Replace Value",
                              "Select Columns",
                              "Sort",
                              "Tail"
                            ],
                            "options_metadata": [],
                            "placeholder": "",
                            "real_time_refresh": true,
                            "required": false,
                            "show": true,
                            "title_case": false,
                            "toggle": false,
                            "tool_mode": false,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": "Tail"
                          },
                          "replace_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Value to Replace",
                            "dynamic": true,
                            "info": "The value to replace in the column.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replace_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          },
                          "replacement_value": {
                            "_input_type": "MessageTextInput",
                            "advanced": false,
                            "display_name": "Replacement Value",
                            "dynamic": true,
                            "info": "The value to replace with.",
                            "input_types": [
                              "Message"
                            ],
                            "list": false,
                            "list_add_label": "Add More",
                            "load_from_db": false,
                            "name": "replacement_value",
                            "placeholder": "",
                            "required": false,
                            "show": false,
                            "title_case": false,
                            "tool_mode": false,
                            "trace_as_input": true,
                            "trace_as_metadata": true,
                            "type": "str",
                            "value": ""
                          }
                        },
                        "tool_mode": false
                      },
                      "showNode": true,
                      "type": "DataFrameOperationsComponent"
                    },
                    "dragging": false,
                    "id": "DataFrameOperationsComponent-w9bzA",
                    "measured": {
                      "height": 356,
                      "width": 320
                    },
                    "position": {
                      "x": -2445.9540176735686,
                      "y": 858.1029924687722
                    },
                    "selected": true,
                    "type": "genericNode"
                  }
                ],
                "viewport": {
                  "x": 0,
                  "y": 0,
                  "zoom": 1
                }
              },
              "description": "",
              "id": "4Ixx0",
              "is_component": false,
              "name": "Upbeat Einstein"
            },
            "frozen": false,
            "lf_version": "1.3.4",
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": false,
                "method": "fetch_content",
                "name": "URLComponent-1pggm_data",
                "options": null,
                "proxy": {
                  "id": "URLComponent-7ulEY",
                  "name": "data",
                  "nodeDisplayName": "URL"
                },
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "template": {
              "ascending_DataFrameOperationsComponent-RPHoF": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Sort Ascending",
                "dynamic": true,
                "info": "Whether to sort in ascending order.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ascending",
                "placeholder": "",
                "proxy": {
                  "field": "ascending",
                  "id": "DataFrameOperationsComponent-w9bzA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code_DataFrameOperationsComponent-RPHoF": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "DataFrameOperationsComponent-w9bzA"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import BoolInput, DataFrameInput, DropdownInput, IntInput, MessageTextInput, Output, StrInput\nfrom langflow.schema import DataFrame\n\n\nclass DataFrameOperationsComponent(Component):\n    display_name = \"DataFrame Operations\"\n    description = \"Perform various operations on a DataFrame.\"\n    icon = \"table\"\n\n    # Available operations\n    OPERATION_CHOICES = [\n        \"Add Column\",\n        \"Drop Column\",\n        \"Filter\",\n        \"Head\",\n        \"Rename Column\",\n        \"Replace Value\",\n        \"Select Columns\",\n        \"Sort\",\n        \"Tail\",\n    ]\n\n    inputs = [\n        DataFrameInput(\n            name=\"df\",\n            display_name=\"DataFrame\",\n            info=\"The input DataFrame to operate on.\",\n        ),\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation\",\n            options=OPERATION_CHOICES,\n            info=\"Select the DataFrame operation to perform.\",\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"column_name\",\n            display_name=\"Column Name\",\n            info=\"The column name to use for the operation.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"filter_value\",\n            display_name=\"Filter Value\",\n            info=\"The value to filter rows by.\",\n            dynamic=True,\n            show=False,\n        ),\n        BoolInput(\n            name=\"ascending\",\n            display_name=\"Sort Ascending\",\n            info=\"Whether to sort in ascending order.\",\n            dynamic=True,\n            show=False,\n            value=True,\n        ),\n        StrInput(\n            name=\"new_column_name\",\n            display_name=\"New Column Name\",\n            info=\"The new column name when renaming or adding a column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"new_column_value\",\n            display_name=\"New Column Value\",\n            info=\"The value to populate the new column with.\",\n            dynamic=True,\n            show=False,\n        ),\n        StrInput(\n            name=\"columns_to_select\",\n            display_name=\"Columns to Select\",\n            dynamic=True,\n            is_list=True,\n            show=False,\n        ),\n        IntInput(\n            name=\"num_rows\",\n            display_name=\"Number of Rows\",\n            info=\"Number of rows to return (for head/tail).\",\n            dynamic=True,\n            show=False,\n            value=5,\n        ),\n        MessageTextInput(\n            name=\"replace_value\",\n            display_name=\"Value to Replace\",\n            info=\"The value to replace in the column.\",\n            dynamic=True,\n            show=False,\n        ),\n        MessageTextInput(\n            name=\"replacement_value\",\n            display_name=\"Replacement Value\",\n            info=\"The value to replace with.\",\n            dynamic=True,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"DataFrame\",\n            name=\"output\",\n            method=\"perform_operation\",\n            info=\"The resulting DataFrame after the operation.\",\n        )\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        # Hide all dynamic fields by default\n        dynamic_fields = [\n            \"column_name\",\n            \"filter_value\",\n            \"ascending\",\n            \"new_column_name\",\n            \"new_column_value\",\n            \"columns_to_select\",\n            \"num_rows\",\n            \"replace_value\",\n            \"replacement_value\",\n        ]\n        for field in dynamic_fields:\n            build_config[field][\"show\"] = False\n\n        # Show relevant fields based on the selected operation\n        if field_name == \"operation\":\n            if field_value == \"Filter\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"filter_value\"][\"show\"] = True\n            elif field_value == \"Sort\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"ascending\"][\"show\"] = True\n            elif field_value == \"Drop Column\":\n                build_config[\"column_name\"][\"show\"] = True\n            elif field_value == \"Rename Column\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"new_column_name\"][\"show\"] = True\n            elif field_value == \"Add Column\":\n                build_config[\"new_column_name\"][\"show\"] = True\n                build_config[\"new_column_value\"][\"show\"] = True\n            elif field_value == \"Select Columns\":\n                build_config[\"columns_to_select\"][\"show\"] = True\n            elif field_value in {\"Head\", \"Tail\"}:\n                build_config[\"num_rows\"][\"show\"] = True\n            elif field_value == \"Replace Value\":\n                build_config[\"column_name\"][\"show\"] = True\n                build_config[\"replace_value\"][\"show\"] = True\n                build_config[\"replacement_value\"][\"show\"] = True\n\n        return build_config\n\n    def perform_operation(self) -> DataFrame:\n        dataframe_copy = self.df.copy()\n        operation = self.operation\n\n        if operation == \"Filter\":\n            return self.filter_rows_by_value(dataframe_copy)\n        if operation == \"Sort\":\n            return self.sort_by_column(dataframe_copy)\n        if operation == \"Drop Column\":\n            return self.drop_column(dataframe_copy)\n        if operation == \"Rename Column\":\n            return self.rename_column(dataframe_copy)\n        if operation == \"Add Column\":\n            return self.add_column(dataframe_copy)\n        if operation == \"Select Columns\":\n            return self.select_columns(dataframe_copy)\n        if operation == \"Head\":\n            return self.head(dataframe_copy)\n        if operation == \"Tail\":\n            return self.tail(dataframe_copy)\n        if operation == \"Replace Value\":\n            return self.replace_values(dataframe_copy)\n        msg = f\"Unsupported operation: {operation}\"\n\n        raise ValueError(msg)\n\n    # Existing methods\n    def filter_rows_by_value(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df[df[self.column_name] == self.filter_value])\n\n    def sort_by_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.sort_values(by=self.column_name, ascending=self.ascending))\n\n    def drop_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.drop(columns=[self.column_name]))\n\n    def rename_column(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.rename(columns={self.column_name: self.new_column_name}))\n\n    def add_column(self, df: DataFrame) -> DataFrame:\n        df[self.new_column_name] = [self.new_column_value] * len(df)\n        return DataFrame(df)\n\n    def select_columns(self, df: DataFrame) -> DataFrame:\n        columns = [col.strip() for col in self.columns_to_select]\n        return DataFrame(df[columns])\n\n    # New methods\n    def head(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.head(self.num_rows))\n\n    def tail(self, df: DataFrame) -> DataFrame:\n        return DataFrame(df.tail(self.num_rows))\n\n    def replace_values(self, df: DataFrame) -> DataFrame:\n        df[self.column_name] = df[self.column_name].replace(self.replace_value, self.replacement_value)\n        return DataFrame(df)\n"
              },
              "code_ParserComponent-IaMv5": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "ParserComponent-m7PuY"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    BoolInput,\n    HandleInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TabInput,\n)\nfrom langflow.schema import Data, DataFrame\nfrom langflow.schema.message import Message\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = (\n        \"Format a DataFrame or Data object into text using a template. \"\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\n    )\n    icon = \"braces\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return json.dumps(data.data)\n            if isinstance(data, DataFrame):\n                if hasattr(self, \"clean_data\") and self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n                return data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\n        else:\n            result = self._safe_convert(self.input_data)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "code_URLComponent-1pggm": {
                "advanced": true,
                "display_name": "code",
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "proxy": {
                  "field": "code",
                  "id": "URLComponent-7ulEY"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import logging\nimport re\n\nfrom bs4 import BeautifulSoup\nfrom langchain_community.document_loaders import RecursiveUrlLoader\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\n\nlogger = logging.getLogger(__name__)\n\n\nclass URLComponent(Component):\n    \"\"\"A component that loads and parses child links from a root URL recursively.\"\"\"\n\n    display_name = \"URL\"\n    description = \"Load and parse child links from a root URL recursively\"\n    icon = \"layout-template\"\n    name = \"URLComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs to crawl recursively, by clicking the '+' button.\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n        ),\n        IntInput(\n            name=\"max_depth\",\n            display_name=\"Max Depth\",\n            info=(\n                \"Controls how many 'clicks' away from the initial page the crawler will go:\\n\"\n                \"- depth 1: only the initial page\\n\"\n                \"- depth 2: initial page + all pages linked directly from it\\n\"\n                \"- depth 3: initial page + direct links + links found on those direct link pages\\n\"\n                \"Note: This is about link traversal, not URL path depth.\"\n            ),\n            value=1,\n            required=False,\n        ),\n        BoolInput(\n            name=\"prevent_outside\",\n            display_name=\"Prevent Outside\",\n            info=(\n                \"If enabled, only crawls URLs within the same domain as the root URL. \"\n                \"This helps prevent the crawler from going to external websites.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_async\",\n            display_name=\"Use Async\",\n            info=(\n                \"If enabled, uses asynchronous loading which can be significantly faster \"\n                \"but might use more system resources.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.\",\n            options=[\"Text\", \"HTML\"],\n            value=\"Text\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"fetch_content\")\n    ]\n\n    def validate_url(self, string: str) -> bool:\n        \"\"\"Validates if the given string matches URL pattern.\"\"\"\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n            re.IGNORECASE,\n        )\n        return bool(url_regex.match(string))\n\n    def ensure_url(self, url: str) -> str:\n        \"\"\"Ensures the given string is a valid URL.\"\"\"\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"http://\" + url\n\n        if not self.validate_url(url):\n            error_msg = \"Invalid URL - \" + url\n            raise ValueError(error_msg)\n\n        return url\n\n    def fetch_content(self) -> list[Data]:\n        \"\"\"Load documents from the URLs.\"\"\"\n        all_docs = []\n        data = []\n        try:\n            urls = list({self.ensure_url(url.strip()) for url in self.urls if url.strip()})\n\n            no_urls_msg = \"No valid URLs provided.\"\n            if not urls:\n                raise ValueError(no_urls_msg)\n\n            for processed_url in urls:\n                msg = f\"Loading documents from {processed_url}\"\n                logger.info(msg)\n\n                extractor = (lambda x: x) if self.format == \"HTML\" else (lambda x: BeautifulSoup(x, \"lxml\").get_text())\n                loader = RecursiveUrlLoader(\n                    url=processed_url,\n                    max_depth=self.max_depth,\n                    prevent_outside=self.prevent_outside,\n                    use_async=self.use_async,\n                    extractor=extractor,\n                )\n\n                docs = loader.load()\n                msg = f\"Found {len(docs)} documents from {processed_url}\"\n                logger.info(msg)\n                all_docs.extend(docs)\n\n            data = [Data(text=doc.page_content, **doc.metadata) for doc in all_docs]\n            self.status = data\n\n        except Exception as e:\n            msg = f\"Error loading documents: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n        self.status = data\n        return data\n\n    def fetch_content_text(self) -> Message:\n        \"\"\"Load documents and return their text content.\"\"\"\n        data = self.fetch_content()\n        result_string = data_to_text(\"{text}\", data)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the documents to a DataFrame.\"\"\"\n        data_frame = DataFrame(self.fetch_content())\n        self.status = data_frame\n        return data_frame\n"
              },
              "column_name_DataFrameOperationsComponent-RPHoF": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Column Name",
                "dynamic": true,
                "info": "The column name to use for the operation.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "column_name",
                "placeholder": "",
                "proxy": {
                  "field": "column_name",
                  "id": "DataFrameOperationsComponent-w9bzA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "columns_to_select_DataFrameOperationsComponent-RPHoF": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Columns to Select",
                "dynamic": true,
                "info": "",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "columns_to_select",
                "placeholder": "",
                "proxy": {
                  "field": "columns_to_select",
                  "id": "DataFrameOperationsComponent-w9bzA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "df_DataFrameOperationsComponent-RPHoF": {
                "_input_type": "DataFrameInput",
                "advanced": false,
                "display_name": "DataFrame",
                "dynamic": false,
                "info": "The input DataFrame to operate on.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "df",
                "placeholder": "",
                "proxy": {
                  "field": "df",
                  "id": "DataFrameOperationsComponent-w9bzA"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "filter_value_DataFrameOperationsComponent-RPHoF": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Filter Value",
                "dynamic": true,
                "info": "The value to filter rows by.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_value",
                "placeholder": "",
                "proxy": {
                  "field": "filter_value",
                  "id": "DataFrameOperationsComponent-w9bzA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Index == 0"
              },
              "format_URLComponent-1pggm": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Output Format",
                "dynamic": false,
                "info": "Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.",
                "name": "format",
                "options": [
                  "Text",
                  "HTML"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "format",
                  "id": "URLComponent-7ulEY"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Text"
              },
              "max_depth_URLComponent-1pggm": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Depth",
                "dynamic": false,
                "info": "Controls how many 'clicks' away from the initial page the crawler will go:\n- depth 1: only the initial page\n- depth 2: initial page + all pages linked directly from it\n- depth 3: initial page + direct links + links found on those direct link pages\nNote: This is about link traversal, not URL path depth.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_depth",
                "placeholder": "",
                "proxy": {
                  "field": "max_depth",
                  "id": "URLComponent-7ulEY"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "mode_ParserComponent-IaMv5": {
                "_input_type": "TabInput",
                "advanced": true,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "proxy": {
                  "field": "mode",
                  "id": "ParserComponent-m7PuY"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "new_column_name_DataFrameOperationsComponent-RPHoF": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "New Column Name",
                "dynamic": true,
                "info": "The new column name when renaming or adding a column.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_name",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_name",
                  "id": "DataFrameOperationsComponent-w9bzA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "new_column_value_DataFrameOperationsComponent-RPHoF": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "New Column Value",
                "dynamic": true,
                "info": "The value to populate the new column with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "new_column_value",
                "placeholder": "",
                "proxy": {
                  "field": "new_column_value",
                  "id": "DataFrameOperationsComponent-w9bzA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "num_rows_DataFrameOperationsComponent-RPHoF": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Rows",
                "dynamic": true,
                "info": "Number of rows to return (for head/tail).",
                "list": false,
                "list_add_label": "Add More",
                "name": "num_rows",
                "placeholder": "",
                "proxy": {
                  "field": "num_rows",
                  "id": "DataFrameOperationsComponent-w9bzA"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "operation_DataFrameOperationsComponent-RPHoF": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation",
                "dynamic": false,
                "info": "Select the DataFrame operation to perform.",
                "name": "operation",
                "options": [
                  "Add Column",
                  "Drop Column",
                  "Filter",
                  "Head",
                  "Rename Column",
                  "Replace Value",
                  "Select Columns",
                  "Sort",
                  "Tail"
                ],
                "options_metadata": [],
                "placeholder": "",
                "proxy": {
                  "field": "operation",
                  "id": "DataFrameOperationsComponent-w9bzA"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Tail"
              },
              "pattern_ParserComponent-IaMv5": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "proxy": {
                  "field": "pattern",
                  "id": "ParserComponent-m7PuY"
                },
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{link}"
              },
              "prevent_outside_URLComponent-1pggm": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Prevent Outside",
                "dynamic": false,
                "info": "If enabled, only crawls URLs within the same domain as the root URL. This helps prevent the crawler from going to external websites.",
                "list": false,
                "list_add_label": "Add More",
                "name": "prevent_outside",
                "placeholder": "",
                "proxy": {
                  "field": "prevent_outside",
                  "id": "URLComponent-7ulEY"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "replace_value_DataFrameOperationsComponent-RPHoF": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Value to Replace",
                "dynamic": true,
                "info": "The value to replace in the column.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replace_value",
                "placeholder": "",
                "proxy": {
                  "field": "replace_value",
                  "id": "DataFrameOperationsComponent-w9bzA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "replacement_value_DataFrameOperationsComponent-RPHoF": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Replacement Value",
                "dynamic": true,
                "info": "The value to replace with.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "replacement_value",
                "placeholder": "",
                "proxy": {
                  "field": "replacement_value",
                  "id": "DataFrameOperationsComponent-w9bzA"
                },
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sep_ParserComponent-IaMv5": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "proxy": {
                  "field": "sep",
                  "id": "ParserComponent-m7PuY"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              },
              "use_async_URLComponent-1pggm": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Async",
                "dynamic": false,
                "info": "If enabled, uses asynchronous loading which can be significantly faster but might use more system resources.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_async",
                "placeholder": "",
                "proxy": {
                  "field": "use_async",
                  "id": "URLComponent-7ulEY"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            }
          },
          "type": "GroupNode"
        },
        "id": "GroupNode-RJLyv",
        "measured": {
          "height": 240,
          "width": 320
        },
        "position": {
          "x": 2988.508537487979,
          "y": 4676.5049377783835
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-HDZ1K",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Format a DataFrame or Data object into text using a template. Enable 'Stringify' to convert input into a readable string instead.",
            "display_name": "Parser",
            "documentation": "",
            "edited": true,
            "field_order": [
              "mode",
              "pattern",
              "input_data",
              "sep",
              "filter_column",
              "filter_text",
              "enable_filtering"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "hidden": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\r\nfrom typing import Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    BoolInput,\r\n    HandleInput,\r\n    MessageTextInput,\r\n    MultilineInput,\r\n    Output,\r\n    TabInput,\r\n)\r\nfrom langflow.schema import Data, DataFrame\r\nfrom langflow.schema.message import Message\r\n\r\n\r\nclass ParserComponent(Component):\r\n    display_name = \"Parser\"\r\n    description = (\r\n        \"Format a DataFrame or Data object into text using a template. \"\r\n        \"Enable 'Stringify' to convert input into a readable string instead.\"\r\n    )\r\n    icon = \"braces\"\r\n\r\n    inputs = [\r\n        TabInput(\r\n            name=\"mode\",\r\n            display_name=\"Mode\",\r\n            options=[\"Parser\", \"Stringify\"],\r\n            value=\"Parser\",\r\n            info=\"Convert into raw string instead of using a template.\",\r\n            real_time_refresh=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"pattern\",\r\n            display_name=\"Template\",\r\n            info=(\r\n                \"Use variables within curly brackets to extract column values for DataFrames \"\r\n                \"or key values for Data.\"\r\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\r\n            ),\r\n            value=\"Text: {text}\",  # Example default\r\n            dynamic=True,\r\n            show=True,\r\n            required=True,\r\n        ),\r\n        HandleInput(\r\n            name=\"input_data\",\r\n            display_name=\"Data or DataFrame\",\r\n            input_types=[\"DataFrame\", \"Data\"],\r\n            info=\"Accepts either a DataFrame or a Data object.\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"sep\",\r\n            display_name=\"Separator\",\r\n            advanced=True,\r\n            value=\"\\n\",\r\n            info=\"String used to separate rows/items.\",\r\n        ),\r\n        MessageTextInput(\r\n            name=\"filter_column\",\r\n            display_name=\"Column to Filter\",\r\n            value=\"model_response\",\r\n            info=\"Column name to filter out rows with 'No relevant information found'\",\r\n            advanced=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"filter_text\",\r\n            display_name=\"Text to Filter Out\",\r\n            value=\"No relevant information found.\",\r\n            info=\"Text to filter out from results\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"enable_filtering\",\r\n            display_name=\"Enable Filtering\",\r\n            info=\"Enable filtering out rows with unwanted text\",\r\n            value=True,\r\n            advanced=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            display_name=\"Parsed Text\",\r\n            name=\"parsed_text\",\r\n            info=\"Formatted text output.\",\r\n            method=\"parse_combined_text\",\r\n        ),\r\n    ]\r\n\r\n    def update_build_config(self, build_config, field_value, field_name=None):\r\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\r\n        if field_name == \"mode\":\r\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\r\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\r\n            if field_value:\r\n                clean_data = BoolInput(\r\n                    name=\"clean_data\",\r\n                    display_name=\"Clean Data\",\r\n                    info=(\r\n                        \"Enable to clean the data by removing empty rows and lines \"\r\n                        \"in each cell of the DataFrame/ Data object.\"\r\n                    ),\r\n                    value=True,\r\n                    advanced=True,\r\n                    required=False,\r\n                )\r\n                build_config[\"clean_data\"] = clean_data.to_dict()\r\n            else:\r\n                build_config.pop(\"clean_data\", None)\r\n\r\n        return build_config\r\n\r\n    def _clean_args(self):\r\n        \"\"\"Prepare arguments based on input type.\"\"\"\r\n        input_data = self.input_data\r\n\r\n        match input_data:\r\n            case list() if all(isinstance(item, Data) for item in input_data):\r\n                msg = \"List of Data objects is not supported.\"\r\n                raise ValueError(msg)\r\n            case DataFrame():\r\n                return input_data, None\r\n            case Data():\r\n                return None, input_data\r\n            case dict() if \"data\" in input_data:\r\n                try:\r\n                    if \"columns\" in input_data:  # Likely a DataFrame\r\n                        return DataFrame.from_dict(input_data), None\r\n                    # Likely a Data object\r\n                    return None, Data(**input_data)\r\n                except (TypeError, ValueError, KeyError) as e:\r\n                    msg = f\"Invalid structured input provided: {e!s}\"\r\n                    raise ValueError(msg) from e\r\n            case _:\r\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\r\n                raise ValueError(msg)\r\n\r\n    def filter_dataframe(self, df):\r\n        \"\"\"Filter out rows where the specified column contains the unwanted text\"\"\"\r\n        if not hasattr(self, \"enable_filtering\") or not self.enable_filtering:\r\n            return df\r\n            \r\n        filter_column = getattr(self, \"filter_column\", \"model_response\")\r\n        filter_text = getattr(self, \"filter_text\", \"No relevant information found.\")\r\n        \r\n        if filter_column in df.columns:\r\n            self.log(f\"Filtering out rows where {filter_column} contains '{filter_text}'\")\r\n            # Only keep rows where the column does NOT contain the filter text\r\n            filtered_df = df[~df[filter_column].astype(str).str.contains(filter_text, na=False)]\r\n            self.log(f\"Filtered out {len(df) - len(filtered_df)} rows\")\r\n            return filtered_df\r\n        else:\r\n            self.log(f\"Warning: Filter column '{filter_column}' not found in DataFrame\")\r\n            return df\r\n\r\n    def parse_combined_text(self) -> Message:\r\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\r\n        # Early return for stringify option\r\n        if self.mode == \"Stringify\":\r\n            return self.convert_to_string()\r\n\r\n        df, data = self._clean_args()\r\n\r\n        lines = []\r\n        if df is not None:\r\n            # Apply filtering to remove unwanted entries\r\n            filtered_df = self.filter_dataframe(df)\r\n            \r\n            for _, row in filtered_df.iterrows():\r\n                formatted_text = self.pattern.format(**row.to_dict())\r\n                lines.append(formatted_text)\r\n        elif data is not None:\r\n            # For Data objects, we could implement similar filtering if needed\r\n            formatted_text = self.pattern.format(**data.data)\r\n            lines.append(formatted_text)\r\n\r\n        combined_text = self.sep.join(lines)\r\n        self.status = combined_text\r\n        return Message(text=combined_text)\r\n\r\n    def _safe_convert(self, data: Any) -> str:\r\n        \"\"\"Safely convert input data to string.\"\"\"\r\n        try:\r\n            if isinstance(data, str):\r\n                return data\r\n            if isinstance(data, Message):\r\n                return data.get_text()\r\n            if isinstance(data, Data):\r\n                return json.dumps(data.data)\r\n            if isinstance(data, DataFrame):\r\n                if hasattr(self, \"enable_filtering\") and self.enable_filtering:\r\n                    # Filter DataFrame before converting to string\r\n                    data = self.filter_dataframe(data)\r\n                \r\n                if hasattr(self, \"clean_data\") and self.clean_data:\r\n                    # Remove empty rows\r\n                    data = data.dropna(how=\"all\")\r\n                    # Remove empty lines in each cell\r\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\r\n                    # Replace multiple newlines with a single newline\r\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\r\n                return data.to_markdown(index=False)\r\n            return str(data)\r\n        except (ValueError, TypeError, AttributeError) as e:\r\n            msg = f\"Error converting data: {e!s}\"\r\n            raise ValueError(msg) from e\r\n\r\n    def convert_to_string(self) -> Message:\r\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\r\n        result = \"\"\r\n        if isinstance(self.input_data, list):\r\n            result = \"\\n\".join([self._safe_convert(item) for item in self.input_data])\r\n        else:\r\n            result = self._safe_convert(self.input_data)\r\n        self.log(f\"Converted to string with length: {len(result)}\")\r\n\r\n        message = Message(text=result)\r\n        self.status = message\r\n        return message"
              },
              "enable_filtering": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Enable Filtering",
                "dynamic": false,
                "info": "Enable filtering out rows with unwanted text",
                "list": false,
                "list_add_label": "Add More",
                "name": "enable_filtering",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "filter_column": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Column to Filter",
                "dynamic": false,
                "info": "Column name to filter out rows with 'No relevant information found'",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_column",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "model_response"
              },
              "filter_text": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text to Filter Out",
                "dynamic": false,
                "info": "Text to filter out from results",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "filter_text",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "No relevant information found."
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{model_response}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-HDZ1K",
        "measured": {
          "height": 392,
          "width": 320
        },
        "position": {
          "x": 3704.396627030832,
          "y": 3826.296308618949
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt-JJiqx",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "vector",
                "web",
                "question",
                "answer",
                "memory"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt",
            "documentation": "",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "prompts",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt Message",
                "hidden": false,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": null,
            "template": {
              "_type": "Component",
              "answer": {
                "advanced": false,
                "display_name": "answer",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "answer",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "memory": {
                "advanced": false,
                "display_name": "memory",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "memory",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "question": {
                "advanced": false,
                "display_name": "question",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "question",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "You are the final AI agent in a multi-agent educational chat system helping a Grade 11 student understand academic topics. Your job is to craft the final response using:\n\n{vector}: Verified content from RAG (with section titles and page numbers)\n\n{web}: Reliable web sources\n\n{question}: The student’s original question\n\n{answer}: Draft response from earlier agents\n\n{memory}: The last 10 exchanges to match the student’s tone and understanding\n\nFollow these steps:\n\nFact-check the draft using only vector and web. Revise unclear or unsupported parts. Do not make up info.\n\nSimplify and personalize: Match the student’s vibe and explain clearly using analogies/examples if helpful. Avoid jargon unless already introduced.\n\nHandle gaps honestly: If the info isn’t enough to fully answer, say what’s known and note the limitation.\n\nInclude sources: Clearly list section/page numbers (vector) or links/domains (web).\n\nBe warm, accurate, and clear — like a smart, supportive study buddy.\n\nImportant\nDon’t greet after every message.\nClearly list all relevant references at the end:\n\nTextbook Section:\nPages:\nSources:"
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "vector": {
                "advanced": false,
                "display_name": "vector",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "vector",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "web": {
                "advanced": false,
                "display_name": "web",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "web",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt"
        },
        "dragging": false,
        "id": "Prompt-JJiqx",
        "measured": {
          "height": 738,
          "width": 320
        },
        "position": {
          "x": 8417.94010466075,
          "y": 1647.208949994536
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Memory-fFchE",
          "node": {
            "base_classes": [
              "Data",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Retrieves stored chat messages from Langflow tables or an external memory.",
            "display_name": "Chat Memory",
            "documentation": "",
            "edited": false,
            "field_order": [
              "memory",
              "sender",
              "sender_name",
              "n_messages",
              "session_id",
              "order",
              "template"
            ],
            "frozen": false,
            "icon": "message-square-more",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "official": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "method": "retrieve_messages",
                "name": "messages",
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": false,
                "method": "retrieve_messages_as_text",
                "name": "messages_text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "method": "as_dataframe",
                "name": "dataframe",
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.inputs import HandleInput\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, MultilineInput, Output\nfrom langflow.memory import aget_messages\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER\n\n\nclass MemoryComponent(Component):\n    display_name = \"Message History\"\n    description = \"Retrieves stored chat messages from Langflow tables or an external memory.\"\n    icon = \"message-square-more\"\n    name = \"Memory\"\n\n    inputs = [\n        HandleInput(\n            name=\"memory\",\n            display_name=\"External Memory\",\n            input_types=[\"Memory\"],\n            info=\"Retrieve messages from an external memory. If empty, it will use the Langflow tables.\",\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER, \"Machine and User\"],\n            value=\"Machine and User\",\n            info=\"Filter by sender type.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Filter by sender name.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Messages\",\n            value=100,\n            info=\"Number of messages to retrieve.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"order\",\n            display_name=\"Order\",\n            options=[\"Ascending\", \"Descending\"],\n            value=\"Ascending\",\n            info=\"Order of the messages.\",\n            advanced=True,\n            tool_mode=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {sender} or any other key in the message data.\",\n            value=\"{sender_name}: {text}\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"messages\", method=\"retrieve_messages\"),\n        Output(display_name=\"Message\", name=\"messages_text\", method=\"retrieve_messages_as_text\"),\n        Output(display_name=\"DataFrame\", name=\"dataframe\", method=\"as_dataframe\"),\n    ]\n\n    async def retrieve_messages(self) -> Data:\n        sender = self.sender\n        sender_name = self.sender_name\n        session_id = self.session_id\n        n_messages = self.n_messages\n        order = \"DESC\" if self.order == \"Descending\" else \"ASC\"\n\n        if sender == \"Machine and User\":\n            sender = None\n\n        if self.memory and not hasattr(self.memory, \"aget_messages\"):\n            memory_name = type(self.memory).__name__\n            err_msg = f\"External Memory object ({memory_name}) must have 'aget_messages' method.\"\n            raise AttributeError(err_msg)\n\n        if self.memory:\n            # override session_id\n            self.memory.session_id = session_id\n\n            stored = await self.memory.aget_messages()\n            # langchain memories are supposed to return messages in ascending order\n            if order == \"DESC\":\n                stored = stored[::-1]\n            if n_messages:\n                stored = stored[:n_messages]\n            stored = [Message.from_lc_message(m) for m in stored]\n            if sender:\n                expected_type = MESSAGE_SENDER_AI if sender == MESSAGE_SENDER_AI else MESSAGE_SENDER_USER\n                stored = [m for m in stored if m.type == expected_type]\n        else:\n            stored = await aget_messages(\n                sender=sender,\n                sender_name=sender_name,\n                session_id=session_id,\n                limit=n_messages,\n                order=order,\n            )\n        self.status = stored\n        return stored\n\n    async def retrieve_messages_as_text(self) -> Message:\n        stored_text = data_to_text(self.template, await self.retrieve_messages())\n        self.status = stored_text\n        return Message(text=stored_text)\n\n    async def as_dataframe(self) -> DataFrame:\n        \"\"\"Convert the retrieved messages into a DataFrame.\n\n        Returns:\n            DataFrame: A DataFrame containing the message data.\n        \"\"\"\n        messages = await self.retrieve_messages()\n        return DataFrame(messages)\n"
              },
              "memory": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "External Memory",
                "dynamic": false,
                "info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
                "input_types": [
                  "Memory"
                ],
                "list": false,
                "name": "memory",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "n_messages": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Number of Messages",
                "dynamic": false,
                "info": "Number of messages to retrieve.",
                "list": false,
                "name": "n_messages",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 10
              },
              "order": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "display_name": "Order",
                "dynamic": false,
                "info": "Order of the messages.",
                "name": "order",
                "options": [
                  "Ascending",
                  "Descending"
                ],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Ascending"
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Filter by sender type.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User",
                  "Machine and User"
                ],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine and User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Filter by sender name.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "display_name": "Template",
                "dynamic": false,
                "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{sender_name}: {text}"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Memory"
        },
        "dragging": false,
        "id": "Memory-fFchE",
        "measured": {
          "height": 470,
          "width": 320
        },
        "position": {
          "x": 7908.001112128425,
          "y": 931.725873404447
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-Kr85Q",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": null,
                "method": "message_response",
                "name": "message",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean the data",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            info=\"Whether to clean the data\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                if data.get_text() is None:\n                    msg = \"Empty Data object\"\n                    raise ValueError(msg)\n                return data.get_text()\n            if isinstance(data, DataFrame):\n                if self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n\n                # Replace pipe characters to avoid markdown table issues\n                processed_data = data.replace(r\"\\|\", r\"\\\\|\", regex=True)\n\n                processed_data = processed_data.map(\n                    lambda x: str(x).replace(\"\\n\", \"<br/>\") if isinstance(x, str) else x\n                )\n\n                return processed_data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            return \"\\n\".join([self._safe_convert(item) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return self._safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "History Helper"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ChatOutput"
        },
        "id": "ChatOutput-Kr85Q",
        "measured": {
          "height": 355,
          "width": 320
        },
        "position": {
          "x": 9687.073898789115,
          "y": 1799.1629090314698
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Agent-oyi9s",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Define the agent's instructions, then enter a task to complete using tools.",
            "display_name": "Agent",
            "documentation": "",
            "edited": false,
            "field_order": [
              "agent_llm",
              "max_tokens",
              "model_kwargs",
              "json_mode",
              "model_name",
              "openai_api_base",
              "api_key",
              "temperature",
              "seed",
              "max_retries",
              "timeout",
              "system_prompt",
              "tools",
              "input_value",
              "handle_parsing_errors",
              "verbose",
              "max_iterations",
              "agent_description",
              "memory",
              "sender",
              "sender_name",
              "n_messages",
              "session_id",
              "order",
              "template",
              "add_current_date_tool"
            ],
            "frozen": false,
            "icon": "bot",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Response",
                "hidden": false,
                "method": "message_response",
                "name": "response",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "add_current_date_tool": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Current Date",
                "dynamic": false,
                "info": "If true, will add a tool to the agent that returns the current date.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "add_current_date_tool",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "agent_description": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Agent Description [Deprecated]",
                "dynamic": false,
                "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "agent_description",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "A helpful assistant with access to the following tools:"
              },
              "agent_llm": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model Provider",
                "dynamic": false,
                "info": "The provider of the language model that the agent will use to generate responses.",
                "input_types": [],
                "name": "agent_llm",
                "options": [
                  "Amazon Bedrock",
                  "Anthropic",
                  "Azure OpenAI",
                  "Google Generative AI",
                  "Groq",
                  "NVIDIA",
                  "OpenAI",
                  "SambaNova",
                  "Custom"
                ],
                "options_metadata": [
                  {
                    "icon": "Amazon"
                  },
                  {
                    "icon": "Anthropic"
                  },
                  {
                    "icon": "Azure"
                  },
                  {
                    "icon": "GoogleGenerativeAI"
                  },
                  {
                    "icon": "Groq"
                  },
                  {
                    "icon": "NVIDIA"
                  },
                  {
                    "icon": "OpenAI"
                  },
                  {
                    "icon": "SambaNova"
                  },
                  {
                    "icon": "brain"
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Google Generative AI"
              },
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Google API Key",
                "dynamic": false,
                "info": "The Google API Key to use for the Google Generative AI.",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langchain_core.tools import StructuredTool\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.base.agents.events import ExceptionWithMessageError\nfrom langflow.base.models.model_input_constants import (\n    ALL_PROVIDER_FIELDS,\n    MODEL_DYNAMIC_UPDATE_FIELDS,\n    MODEL_PROVIDERS_DICT,\n    MODELS_METADATA,\n)\nfrom langflow.base.models.model_utils import get_model_name\nfrom langflow.components.helpers import CurrentDateComponent\nfrom langflow.components.helpers.memory import MemoryComponent\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\nfrom langflow.custom.utils import update_component_build_config\nfrom langflow.io import BoolInput, DropdownInput, MultilineInput, Output\nfrom langflow.logging import logger\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.schema.message import Message\n\n\ndef set_advanced_true(component_input):\n    component_input.advanced = True\n    return component_input\n\n\nclass AgentComponent(ToolCallingAgentComponent):\n    display_name: str = \"Agent\"\n    description: str = \"Define the agent's instructions, then enter a task to complete using tools.\"\n    icon = \"bot\"\n    beta = False\n    name = \"Agent\"\n\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\n\n    inputs = [\n        DropdownInput(\n            name=\"agent_llm\",\n            display_name=\"Model Provider\",\n            info=\"The provider of the language model that the agent will use to generate responses.\",\n            options=[*sorted(MODEL_PROVIDERS_DICT.keys()), \"Custom\"],\n            value=\"OpenAI\",\n            real_time_refresh=True,\n            input_types=[],\n            options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())] + [{\"icon\": \"brain\"}],\n        ),\n        *MODEL_PROVIDERS_DICT[\"OpenAI\"][\"inputs\"],\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"Agent Instructions\",\n            info=\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\",\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\n            advanced=False,\n        ),\n        *LCToolsAgentComponent._base_inputs,\n        *memory_inputs,\n        BoolInput(\n            name=\"add_current_date_tool\",\n            display_name=\"Current Date\",\n            advanced=True,\n            info=\"If true, will add a tool to the agent that returns the current date.\",\n            value=True,\n        ),\n    ]\n    outputs = [Output(name=\"response\", display_name=\"Response\", method=\"message_response\")]\n\n    async def message_response(self) -> Message:\n        try:\n            # Get LLM model and validate\n            llm_model, display_name = self.get_llm()\n            if llm_model is None:\n                msg = \"No language model selected. Please choose a model to proceed.\"\n                raise ValueError(msg)\n            self.model_name = get_model_name(llm_model, display_name=display_name)\n\n            # Get memory data\n            self.chat_history = await self.get_memory_data()\n\n            # Add current date tool if enabled\n            if self.add_current_date_tool:\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\n                    self.tools = []\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\n                if not isinstance(current_date_tool, StructuredTool):\n                    msg = \"CurrentDateComponent must be converted to a StructuredTool\"\n                    raise TypeError(msg)\n                self.tools.append(current_date_tool)\n\n            # Validate tools\n            if not self.tools:\n                msg = \"Tools are required to run the agent. Please add at least one tool.\"\n                raise ValueError(msg)\n\n            # Set up and run agent\n            self.set(\n                llm=llm_model,\n                tools=self.tools,\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=self.system_prompt,\n            )\n            agent = self.create_agent_runnable()\n            return await self.run_agent(agent)\n\n        except (ValueError, TypeError, KeyError) as e:\n            logger.error(f\"{type(e).__name__}: {e!s}\")\n            raise\n        except ExceptionWithMessageError as e:\n            logger.error(f\"ExceptionWithMessageError occurred: {e}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Unexpected error: {e!s}\")\n            raise\n\n    async def get_memory_data(self):\n        memory_kwargs = {\n            component_input.name: getattr(self, f\"{component_input.name}\") for component_input in self.memory_inputs\n        }\n        # filter out empty values\n        memory_kwargs = {k: v for k, v in memory_kwargs.items() if v}\n\n        return await MemoryComponent(**self.get_base_args()).set(**memory_kwargs).retrieve_messages()\n\n    def get_llm(self):\n        if not isinstance(self.agent_llm, str):\n            return self.agent_llm, None\n\n        try:\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if not provider_info:\n                msg = f\"Invalid model provider: {self.agent_llm}\"\n                raise ValueError(msg)\n\n            component_class = provider_info.get(\"component_class\")\n            display_name = component_class.display_name\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\", \"\")\n\n            return self._build_llm_model(component_class, inputs, prefix), display_name\n\n        except Exception as e:\n            logger.error(f\"Error building {self.agent_llm} language model: {e!s}\")\n            msg = f\"Failed to initialize language model: {e!s}\"\n            raise ValueError(msg) from e\n\n    def _build_llm_model(self, component, inputs, prefix=\"\"):\n        model_kwargs = {input_.name: getattr(self, f\"{prefix}{input_.name}\") for input_ in inputs}\n        return component.set(**model_kwargs).build_model()\n\n    def set_component_params(self, component):\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n        if provider_info:\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\")\n            model_kwargs = {input_.name: getattr(self, f\"{prefix}{input_.name}\") for input_ in inputs}\n\n            return component.set(**model_kwargs)\n        return component\n\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\n        \"\"\"Delete specified fields from build_config.\"\"\"\n        for field in fields:\n            build_config.pop(field, None)\n\n    def update_input_types(self, build_config: dotdict) -> dotdict:\n        \"\"\"Update input types for all fields in build_config.\"\"\"\n        for key, value in build_config.items():\n            if isinstance(value, dict):\n                if value.get(\"input_types\") is None:\n                    build_config[key][\"input_types\"] = []\n            elif hasattr(value, \"input_types\") and value.input_types is None:\n                value.input_types = []\n        return build_config\n\n    async def update_build_config(\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\n    ) -> dotdict:\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\n        # Existing logic for updating build_config\n        if field_name in (\"agent_llm\",):\n            build_config[\"agent_llm\"][\"value\"] = field_value\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call the component class's update_build_config method\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\n                provider: (\n                    MODEL_PROVIDERS_DICT[provider][\"fields\"],\n                    [\n                        MODEL_PROVIDERS_DICT[other_provider][\"fields\"]\n                        for other_provider in MODEL_PROVIDERS_DICT\n                        if other_provider != provider\n                    ],\n                )\n                for provider in MODEL_PROVIDERS_DICT\n            }\n            if field_value in provider_configs:\n                fields_to_add, fields_to_delete = provider_configs[field_value]\n\n                # Delete fields from other providers\n                for fields in fields_to_delete:\n                    self.delete_fields(build_config, fields)\n\n                # Add provider-specific fields\n                if field_value == \"OpenAI\" and not any(field in build_config for field in fields_to_add):\n                    build_config.update(fields_to_add)\n                else:\n                    build_config.update(fields_to_add)\n                # Reset input types for agent_llm\n                build_config[\"agent_llm\"][\"input_types\"] = []\n            elif field_value == \"Custom\":\n                # Delete all provider fields\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\n                # Update with custom component\n                custom_component = DropdownInput(\n                    name=\"agent_llm\",\n                    display_name=\"Language Model\",\n                    options=[*sorted(MODEL_PROVIDERS_DICT.keys()), \"Custom\"],\n                    value=\"Custom\",\n                    real_time_refresh=True,\n                    input_types=[\"LanguageModel\"],\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\n                    + [{\"icon\": \"brain\"}],\n                )\n                build_config.update({\"agent_llm\": custom_component.to_dict()})\n            # Update input types for all fields\n            build_config = self.update_input_types(build_config)\n\n            # Validate required keys\n            default_keys = [\n                \"code\",\n                \"_type\",\n                \"agent_llm\",\n                \"tools\",\n                \"input_value\",\n                \"add_current_date_tool\",\n                \"system_prompt\",\n                \"agent_description\",\n                \"max_iterations\",\n                \"handle_parsing_errors\",\n                \"verbose\",\n            ]\n            missing_keys = [key for key in default_keys if key not in build_config]\n            if missing_keys:\n                msg = f\"Missing required keys in build_config: {missing_keys}\"\n                raise ValueError(msg)\n        if (\n            isinstance(self.agent_llm, str)\n            and self.agent_llm in MODEL_PROVIDERS_DICT\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\n        ):\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                component_class = self.set_component_params(component_class)\n                prefix = provider_info.get(\"prefix\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call each component class's update_build_config method\n                    # remove the prefix from the field_name\n                    if isinstance(field_name, str) and isinstance(prefix, str):\n                        field_name = field_name.replace(prefix, \"\")\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n        return dotdict({k: v.to_dict() if hasattr(v, \"to_dict\") else v for k, v in build_config.items()})\n"
              },
              "handle_parsing_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Handle Parse Errors",
                "dynamic": false,
                "info": "Should the Agent fix errors when reading user input for better processing?",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "handle_parsing_errors",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "input_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input provided by the user for the agent to process.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 15
              },
              "max_output_tokens": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Max Output Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "max_output_tokens",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "memory": {
                "_input_type": "HandleInput",
                "advanced": true,
                "display_name": "External Memory",
                "dynamic": false,
                "info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
                "input_types": [
                  "Memory"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "memory",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model",
                "dynamic": false,
                "info": "To see the model names, first choose a provider. Then, enter your API key and click the refresh button next to the model name.",
                "input_types": [],
                "name": "model_name",
                "options": [
                  "learnlm-2.0-flash-experimental",
                  "learnlm-1.5-pro-experimental",
                  "gemma-3-4b-it",
                  "gemma-3-27b-it",
                  "gemma-3-1b-it",
                  "gemma-3-12b-it",
                  "gemini-pro-vision",
                  "gemini-exp-1206",
                  "gemini-2.5-pro-preview-03-25",
                  "gemini-2.5-pro-exp-03-25",
                  "gemini-2.5-flash-preview-04-17",
                  "gemini-2.0-pro-exp-02-05",
                  "gemini-2.0-pro-exp",
                  "gemini-2.0-flash-thinking-exp-1219",
                  "gemini-2.0-flash-thinking-exp-01-21",
                  "gemini-2.0-flash-thinking-exp",
                  "gemini-2.0-flash-lite-preview-02-05",
                  "gemini-2.0-flash-lite-preview",
                  "gemini-2.0-flash-lite-001",
                  "gemini-2.0-flash-lite",
                  "gemini-2.0-flash-exp-image-generation",
                  "gemini-2.0-flash-exp",
                  "gemini-2.0-flash-001",
                  "gemini-2.0-flash",
                  "gemini-1.5-pro-latest",
                  "gemini-1.5-pro-002",
                  "gemini-1.5-pro-001",
                  "gemini-1.5-pro",
                  "gemini-1.5-flash-latest",
                  "gemini-1.5-flash-8b-latest",
                  "gemini-1.5-flash-8b-exp-0924",
                  "gemini-1.5-flash-8b-exp-0827",
                  "gemini-1.5-flash-8b-001",
                  "gemini-1.5-flash-8b",
                  "gemini-1.5-flash-002",
                  "gemini-1.5-flash-001-tuning",
                  "gemini-1.5-flash-001",
                  "gemini-1.5-flash",
                  "gemini-1.0-pro-vision-latest"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": false,
                "refresh_button": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "gemini-1.5-flash"
              },
              "n": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "N",
                "dynamic": false,
                "info": "Number of chat completions to generate for each prompt. Note that the API may not return the full n completions if duplicates are generated.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "n",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "n_messages": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Messages",
                "dynamic": false,
                "info": "Number of messages to retrieve.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "n_messages",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 100
              },
              "order": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Order",
                "dynamic": false,
                "info": "Order of the messages.",
                "input_types": [],
                "name": "order",
                "options": [
                  "Ascending",
                  "Descending"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Ascending"
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Filter by sender type.",
                "input_types": [],
                "name": "sender",
                "options": [
                  "Machine",
                  "User",
                  "Machine and User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine and User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Filter by sender name.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "system_prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Agent Instructions",
                "dynamic": false,
                "info": "System Prompt: Initial instructions and context provided to guide the agent's behavior.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_prompt",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are an AI agent in a multi-agent system. Your only task is to analyze the input question and determine whether it is a complex question that requires additional data retrieval or context to answer. If the question requires more data or context, respond with **Yes**. If the question can be answered directly without additional data or context, respond with **No**. Reply only with **Yes** or **No** and nothing else.\n\n**Example Inputs:**  \nInput: \"Hi, how are you?\"  \nOutput: No\n\nInput: \"What are the economic impacts of climate change in Southeast Asia over the last decade?\"  \nOutput: Yes"
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": true,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Controls randomness. Lower values are more deterministic, higher values are more creative.",
                "input_types": [],
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 2,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              },
              "template": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{sender_name}: {text}"
              },
              "tool_model_enabled": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Tool Model Enabled",
                "dynamic": false,
                "info": "Whether to use the tool model.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "tool_model_enabled",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "tools": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Tools",
                "dynamic": false,
                "info": "These are the tools that the agent can use to help with tasks.",
                "input_types": [
                  "Tool"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "tools",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "top_k": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Top K",
                "dynamic": false,
                "info": "Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "top_k",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "top_p": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Top P",
                "dynamic": false,
                "info": "The maximum cumulative probability of tokens to consider when sampling.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "top_p",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": ""
              },
              "verbose": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Verbose",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "verbose",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Agent"
        },
        "dragging": false,
        "id": "Agent-oyi9s",
        "measured": {
          "height": 702,
          "width": 320
        },
        "position": {
          "x": -2400.477359349679,
          "y": 931.651555505931
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "GoogleGenerativeAIModel-dusep",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generate text using Google Generative AI.",
            "display_name": "Google Generative AI",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_output_tokens",
              "model_name",
              "api_key",
              "top_p",
              "temperature",
              "n",
              "top_k",
              "tool_model_enabled"
            ],
            "frozen": false,
            "icon": "GoogleGenerativeAI",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": null,
                "method": "text_response",
                "name": "text_output",
                "options": null,
                "required_inputs": [],
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "hidden": null,
                "method": "build_model",
                "name": "model_output",
                "options": null,
                "required_inputs": [
                  "api_key"
                ],
                "selected": "LanguageModel",
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Google API Key",
                "dynamic": false,
                "info": "The Google API Key to use for the Google Generative AI.",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nimport requests\nfrom loguru import logger\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.google_generative_ai_constants import GOOGLE_GENERATIVE_AI_MODELS\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import DropdownInput, FloatInput, IntInput, SecretStrInput, SliderInput\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.schema import dotdict\n\n\nclass GoogleGenerativeAIComponent(LCModelComponent):\n    display_name = \"Google Generative AI\"\n    description = \"Generate text using Google Generative AI.\"\n    icon = \"GoogleGenerativeAI\"\n    name = \"GoogleGenerativeAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_output_tokens\", display_name=\"Max Output Tokens\", info=\"The maximum number of tokens to generate.\"\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model\",\n            info=\"The name of the model to use.\",\n            options=GOOGLE_GENERATIVE_AI_MODELS,\n            value=\"gemini-1.5-pro\",\n            refresh_button=True,\n            combobox=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Google API Key\",\n            info=\"The Google API Key to use for the Google Generative AI.\",\n            required=True,\n            real_time_refresh=True,\n        ),\n        FloatInput(\n            name=\"top_p\",\n            display_name=\"Top P\",\n            info=\"The maximum cumulative probability of tokens to consider when sampling.\",\n            advanced=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            range_spec=RangeSpec(min=0, max=2, step=0.01),\n            info=\"Controls randomness. Lower values are more deterministic, higher values are more creative.\",\n        ),\n        IntInput(\n            name=\"n\",\n            display_name=\"N\",\n            info=\"Number of chat completions to generate for each prompt. \"\n            \"Note that the API may not return the full n completions if duplicates are generated.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"top_k\",\n            display_name=\"Top K\",\n            info=\"Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"tool_model_enabled\",\n            display_name=\"Tool Model Enabled\",\n            info=\"Whether to use the tool model.\",\n            value=False,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        try:\n            from langchain_google_genai import ChatGoogleGenerativeAI\n        except ImportError as e:\n            msg = \"The 'langchain_google_genai' package is required to use the Google Generative AI model.\"\n            raise ImportError(msg) from e\n\n        google_api_key = self.api_key\n        model = self.model_name\n        max_output_tokens = self.max_output_tokens\n        temperature = self.temperature\n        top_k = self.top_k\n        top_p = self.top_p\n        n = self.n\n\n        return ChatGoogleGenerativeAI(\n            model=model,\n            max_output_tokens=max_output_tokens or None,\n            temperature=temperature,\n            top_k=top_k or None,\n            top_p=top_p or None,\n            n=n or 1,\n            google_api_key=SecretStr(google_api_key).get_secret_value(),\n        )\n\n    def get_models(self, tool_model_enabled: bool | None = None) -> list[str]:\n        try:\n            import google.generativeai as genai\n\n            genai.configure(api_key=self.api_key)\n            model_ids = [\n                model.name.replace(\"models/\", \"\")\n                for model in genai.list_models()\n                if \"generateContent\" in model.supported_generation_methods\n            ]\n            model_ids.sort(reverse=True)\n        except (ImportError, ValueError) as e:\n            logger.exception(f\"Error getting model names: {e}\")\n            model_ids = GOOGLE_GENERATIVE_AI_MODELS\n        if tool_model_enabled:\n            try:\n                from langchain_google_genai.chat_models import ChatGoogleGenerativeAI\n            except ImportError as e:\n                msg = \"langchain_google_genai is not installed.\"\n                raise ImportError(msg) from e\n            for model in model_ids:\n                model_with_tool = ChatGoogleGenerativeAI(\n                    model=self.model_name,\n                    google_api_key=self.api_key,\n                )\n                if not self.supports_tool_calling(model_with_tool):\n                    model_ids.remove(model)\n        return model_ids\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name in {\"base_url\", \"model_name\", \"tool_model_enabled\", \"api_key\"} and field_value:\n            try:\n                if len(self.api_key) == 0:\n                    ids = GOOGLE_GENERATIVE_AI_MODELS\n                else:\n                    try:\n                        ids = self.get_models(tool_model_enabled=self.tool_model_enabled)\n                    except (ImportError, ValueError, requests.exceptions.RequestException) as e:\n                        logger.exception(f\"Error getting model names: {e}\")\n                        ids = GOOGLE_GENERATIVE_AI_MODELS\n                build_config[\"model_name\"][\"options\"] = ids\n                build_config[\"model_name\"][\"value\"] = ids[0]\n            except Exception as e:\n                msg = f\"Error getting model names: {e}\"\n                raise ValueError(msg) from e\n        return build_config\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_output_tokens": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Max Output Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_output_tokens",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model",
                "dynamic": false,
                "info": "The name of the model to use.",
                "name": "model_name",
                "options": [
                  "learnlm-2.0-flash-experimental",
                  "learnlm-1.5-pro-experimental",
                  "gemma-3-4b-it",
                  "gemma-3-27b-it",
                  "gemma-3-1b-it",
                  "gemma-3-12b-it",
                  "gemini-pro-vision",
                  "gemini-exp-1206",
                  "gemini-2.5-pro-preview-03-25",
                  "gemini-2.5-pro-exp-03-25",
                  "gemini-2.5-flash-preview-04-17",
                  "gemini-2.0-pro-exp-02-05",
                  "gemini-2.0-pro-exp",
                  "gemini-2.0-flash-thinking-exp-1219",
                  "gemini-2.0-flash-thinking-exp-01-21",
                  "gemini-2.0-flash-thinking-exp",
                  "gemini-2.0-flash-lite-preview-02-05",
                  "gemini-2.0-flash-lite-preview",
                  "gemini-2.0-flash-lite-001",
                  "gemini-2.0-flash-lite",
                  "gemini-2.0-flash-exp-image-generation",
                  "gemini-2.0-flash-exp",
                  "gemini-2.0-flash-001",
                  "gemini-2.0-flash",
                  "gemini-1.5-pro-latest",
                  "gemini-1.5-pro-002",
                  "gemini-1.5-pro-001",
                  "gemini-1.5-pro",
                  "gemini-1.5-flash-latest",
                  "gemini-1.5-flash-8b-latest",
                  "gemini-1.5-flash-8b-exp-0924",
                  "gemini-1.5-flash-8b-exp-0827",
                  "gemini-1.5-flash-8b-001",
                  "gemini-1.5-flash-8b",
                  "gemini-1.5-flash-002",
                  "gemini-1.5-flash-001-tuning",
                  "gemini-1.5-flash-001",
                  "gemini-1.5-flash",
                  "gemini-1.0-pro-vision-latest"
                ],
                "options_metadata": [],
                "placeholder": "",
                "refresh_button": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "learnlm-2.0-flash-experimental"
              },
              "n": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "N",
                "dynamic": false,
                "info": "Number of chat completions to generate for each prompt. Note that the API may not return the full n completions if duplicates are generated.",
                "list": false,
                "list_add_label": "Add More",
                "name": "n",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "System message to pass to the model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Controls randomness. Lower values are more deterministic, higher values are more creative.",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 2,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              },
              "tool_model_enabled": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Tool Model Enabled",
                "dynamic": false,
                "info": "Whether to use the tool model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "tool_model_enabled",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "top_k": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Top K",
                "dynamic": false,
                "info": "Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_k",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "top_p": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Top P",
                "dynamic": false,
                "info": "The maximum cumulative probability of tokens to consider when sampling.",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_p",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "GoogleGenerativeAIModel"
        },
        "dragging": false,
        "id": "GoogleGenerativeAIModel-dusep",
        "measured": {
          "height": 734,
          "width": 320
        },
        "position": {
          "x": -1428.9178430269822,
          "y": 1646.3116453157165
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-4QeGI",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean the data",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            info=\"Whether to clean the data\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                if data.get_text() is None:\n                    msg = \"Empty Data object\"\n                    raise ValueError(msg)\n                return data.get_text()\n            if isinstance(data, DataFrame):\n                if self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n\n                # Replace pipe characters to avoid markdown table issues\n                processed_data = data.replace(r\"\\|\", r\"\\\\|\", regex=True)\n\n                processed_data = processed_data.map(\n                    lambda x: str(x).replace(\"\\n\", \"<br/>\") if isinstance(x, str) else x\n                )\n\n                return processed_data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            return \"\\n\".join([self._safe_convert(item) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return self._safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-4QeGI",
        "measured": {
          "height": 66,
          "width": 192
        },
        "position": {
          "x": -1068.8582204903378,
          "y": 2438.75315036662
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ConditionalRouter-oksv6",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Routes an input message to a corresponding output based on text comparison.",
            "display_name": "If-Else",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_text",
              "match_text",
              "operator",
              "case_sensitive",
              "message",
              "max_iterations",
              "default_route"
            ],
            "frozen": false,
            "icon": "split",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "True",
                "hidden": false,
                "method": "true_response",
                "name": "true_result",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "False",
                "hidden": false,
                "method": "false_response",
                "name": "false_result",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "case_sensitive": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Case Sensitive",
                "dynamic": false,
                "info": "If true, the comparison will be case sensitive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "case_sensitive",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import re\n\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\n\n\nclass ConditionalRouterComponent(Component):\n    display_name = \"If-Else\"\n    description = \"Routes an input message to a corresponding output based on text comparison.\"\n    icon = \"split\"\n    name = \"ConditionalRouter\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.__iteration_updated = False\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_text\",\n            display_name=\"Text Input\",\n            info=\"The primary text input for the operation.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"match_text\",\n            display_name=\"Match Text\",\n            info=\"The text input to compare against.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"operator\",\n            display_name=\"Operator\",\n            options=[\"equals\", \"not equals\", \"contains\", \"starts with\", \"ends with\", \"regex\"],\n            info=\"The operator to apply for comparing the texts.\",\n            value=\"equals\",\n            real_time_refresh=True,\n        ),\n        BoolInput(\n            name=\"case_sensitive\",\n            display_name=\"Case Sensitive\",\n            info=\"If true, the comparison will be case sensitive.\",\n            value=False,\n        ),\n        MessageInput(\n            name=\"message\",\n            display_name=\"Message\",\n            info=\"The message to pass through either route.\",\n        ),\n        IntInput(\n            name=\"max_iterations\",\n            display_name=\"Max Iterations\",\n            info=\"The maximum number of iterations for the conditional router.\",\n            value=10,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"default_route\",\n            display_name=\"Default Route\",\n            options=[\"true_result\", \"false_result\"],\n            info=\"The default route to take when max iterations are reached.\",\n            value=\"false_result\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"True\", name=\"true_result\", method=\"true_response\"),\n        Output(display_name=\"False\", name=\"false_result\", method=\"false_response\"),\n    ]\n\n    def _pre_run_setup(self):\n        self.__iteration_updated = False\n\n    def evaluate_condition(self, input_text: str, match_text: str, operator: str, *, case_sensitive: bool) -> bool:\n        if not case_sensitive and operator != \"regex\":\n            input_text = input_text.lower()\n            match_text = match_text.lower()\n\n        if operator == \"equals\":\n            return input_text == match_text\n        if operator == \"not equals\":\n            return input_text != match_text\n        if operator == \"contains\":\n            return match_text in input_text\n        if operator == \"starts with\":\n            return input_text.startswith(match_text)\n        if operator == \"ends with\":\n            return input_text.endswith(match_text)\n        if operator == \"regex\":\n            try:\n                return bool(re.match(match_text, input_text))\n            except re.error:\n                return False  # Return False if the regex is invalid\n        return False\n\n    def iterate_and_stop_once(self, route_to_stop: str):\n        if not self.__iteration_updated:\n            self.update_ctx({f\"{self._id}_iteration\": self.ctx.get(f\"{self._id}_iteration\", 0) + 1})\n            self.__iteration_updated = True\n            if self.ctx.get(f\"{self._id}_iteration\", 0) >= self.max_iterations and route_to_stop == self.default_route:\n                route_to_stop = \"true_result\" if route_to_stop == \"false_result\" else \"false_result\"\n            self.stop(route_to_stop)\n\n    def true_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n        if result:\n            self.status = self.message\n            self.iterate_and_stop_once(\"false_result\")\n            return self.message\n        self.iterate_and_stop_once(\"true_result\")\n        return Message(content=\"\")\n\n    def false_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n        if not result:\n            self.status = self.message\n            self.iterate_and_stop_once(\"true_result\")\n            return self.message\n        self.iterate_and_stop_once(\"false_result\")\n        return Message(content=\"\")\n\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        if field_name == \"operator\":\n            if field_value == \"regex\":\n                build_config.pop(\"case_sensitive\", None)\n\n            # Ensure case_sensitive is present for all other operators\n            elif \"case_sensitive\" not in build_config:\n                case_sensitive_input = next(\n                    (input_field for input_field in self.inputs if input_field.name == \"case_sensitive\"), None\n                )\n                if case_sensitive_input:\n                    build_config[\"case_sensitive\"] = case_sensitive_input.to_dict()\n        return build_config\n"
              },
              "default_route": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Default Route",
                "dynamic": false,
                "info": "The default route to take when max iterations are reached.",
                "name": "default_route",
                "options": [
                  "true_result",
                  "false_result"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "false_result"
              },
              "input_text": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Text Input",
                "dynamic": false,
                "info": "The primary text input for the operation.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_text",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "match_text": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Match Text",
                "dynamic": false,
                "info": "The text input to compare against.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "match_text",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Yes"
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of iterations for the conditional router.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 10
              },
              "message": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Message",
                "dynamic": false,
                "info": "The message to pass through either route.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "operator": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operator",
                "dynamic": false,
                "info": "The operator to apply for comparing the texts.",
                "name": "operator",
                "options": [
                  "equals",
                  "not equals",
                  "contains",
                  "starts with",
                  "ends with",
                  "regex"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "contains"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ConditionalRouter"
        },
        "dragging": false,
        "id": "ConditionalRouter-oksv6",
        "measured": {
          "height": 585,
          "width": 320
        },
        "position": {
          "x": -2016.7098879782454,
          "y": 1374.7118286623074
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatInput-IG2mZ",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get chat inputs from the Playground.",
            "display_name": "Chat Input",
            "documentation": "",
            "edited": true,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "files",
              "background_color",
              "chat_icon",
              "text_color"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": null,
                "method": "message_response",
                "name": "message",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n            input_types=[],\n            show=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n            temp_file=True,\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        background_color = self.background_color\n        text_color = self.text_color\n        icon = self.chat_icon\n\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n            properties={\n                \"background_color\": background_color,\n                \"text_color\": text_color,\n                \"icon\": icon,\n            },\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n"
              },
              "files": {
                "_input_type": "FileInput",
                "advanced": true,
                "display_name": "Files",
                "dynamic": false,
                "fileTypes": [
                  "txt",
                  "md",
                  "mdx",
                  "csv",
                  "json",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "pdf",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "file_path": "",
                "info": "Files to be sent with the message.",
                "list": true,
                "list_add_label": "Add More",
                "name": "files",
                "placeholder": "",
                "required": false,
                "show": true,
                "temp_file": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Message to be passed as input.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Don't based on given context above, using your general knowledge answer the question who is the director in making the hiroshima bomb project in world war II."
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatInput"
        },
        "dragging": false,
        "id": "ChatInput-IG2mZ",
        "measured": {
          "height": 66,
          "width": 192
        },
        "position": {
          "x": -2826.779014124477,
          "y": 763.9324900660893
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": -637.2963800929494,
      "y": -15.805239735938358,
      "zoom": 0.2
    }
  },
  "description": "Histomind is your intelligent history companion—a multi-agent AI designed to simplify complex historical events, answer textbook questions, and provide smart summaries, timelines, and context—all tailored for Grade 11 learners.",
  "endpoint_name": null,
  "id": "4436f8fb-cfdc-4bbf-94dc-f6693413dd5b",
  "is_component": false,
  "last_tested_version": "1.3.4",
  "name": "History Helper - The48Devs",
  "tags": []
}